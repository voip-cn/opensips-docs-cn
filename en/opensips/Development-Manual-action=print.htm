<!DOCTYPE html 
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head>
  <title>openSIPS | Documentation / Development-Manual</title>
  <link rel='stylesheet' href="print.css" tppabs="http://www.opensips.org/pub/skins/print/print.css" type='text/css' />
  <!--HTMLHeader--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
span.anchor {
	float: left;
	font-size: 10px;
	margin-left: -10px;
	width: 10px;
    position:relative; top:-0.1em;
	text-align: center;
}
span.anchor a { text-decoration: none; }
span.anchor a:hover { text-decoration: underline; }
ol.toc { text-indent:-20px; list-style: none; }
ol.toc ol.toc { text-indent:-40px; }
div.tocfloat { font-size: smaller; margin-bottom: 10px;
    border-top: 1px dotted #555555; border-bottom: 1px dotted #555555;
    padding-top: 5px; padding-bottom: 5px; 
    width: 38%; float: right; margin-left: 10px; clear: right;
    margin-right:-13px; padding-right: 13px; padding-left: 13px;
    background-color: #eeeeee; }
div.toc { font-size: smaller; 
    padding: 4px; border: 1px dotted #cccccc;
    background: #f7f7f7;
    margin-bottom: 10px; }
  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
  .editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }
 
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: , CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c .de1, .c .de2 {font-family: monospace; font-weight: normal;}
.c  {font-family:monospace;}
.c .imp {font-weight: bold; color: red;}
.c li, .c .li1 {font-family: monospace; color: black; font-weight: normal;}
.c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c .li2 {font-weight: bold;}
.c .kw1 {color: #b1b100;}
.c .kw2 {color: #000000; font-weight: bold;}
.c .kw3 {color: #000066;}
.c .kw4 {color: #993333;}
.c .co1 {color: #666666; font-style: italic;}
.c .co2 {color: #339933;}
.c .coMULTI {color: #808080; font-style: italic;}
.c .es0 {color: #000099; font-weight: bold;}
.c .es1 {color: #000099; font-weight: bold;}
.c .es2 {color: #660099; font-weight: bold;}
.c .es3 {color: #660099; font-weight: bold;}
.c .es4 {color: #660099; font-weight: bold;}
.c .es5 {color: #006699; font-weight: bold;}
.c .br0 {color: #009900;}
.c .sy0 {color: #339933;}
.c .st0 {color: #ff0000;}
.c .nu0 {color: #0000dd;}
.c .nu6 {color: #208080;}
.c .nu8 {color: #208080;}
.c .nu12 {color: #208080;}
.c .nu16 {color:#800080;}
.c .nu17 {color:#800080;}
.c .nu18 {color:#800080;}
.c .nu19 {color:#800080;}
.c .me1 {color: #202020;}
.c .me2 {color: #202020;}
.c .ln-xtra, .c li.ln-xtra, .c div.ln-xtra {background-color: #ffc;}
.c span.xtra { display:block; }

.sourceblocklink {
  text-align: right;
  font-size: smaller;
}
.sourceblocktext {
  padding: 0.5em;
  border: 1px solid #808080;
  color: #000000;
  background-color: #f1f0ed;
}
.sourceblocktext div {
  font-family: monospace;
  font-size: small;
  line-height: 1;
  height: 1%;
}
.sourceblocktext div.head,
.sourceblocktext div.foot {
  font: italic medium serif;
  padding: 0.5em;
}

--></style><script type="text/javascript">
function toggle(obj) {
    var elstyle = document.getElementById(obj).style;
    var text    = document.getElementById(obj + "tog");
    if (elstyle.display == 'none') {
        elstyle.display = 'block';
        text.innerHTML = "hide";
    } else {
        elstyle.display = 'none';
        text.innerHTML = "show";
    }
}
</script>
  <link href="commentboxplus.css" tppabs="http://www.opensips.org/pub/commentboxplus/commentboxplus.css" rel='stylesheet' type='text/css' />
  <link rel='stylesheet' href="wsplus.css" tppabs="http://www.opensips.org/pub/wsplus/wsplus.css" 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url("csshover.htc")/*tpa=http://www.opensips.org/pub/wsplus/csshover.htc*/; }
    .rollover * { visibility: visible; }
  </style><![endif]-->
  <meta name='robots' content='noindex,nofollow' />

</head>
<body>
  <div id='printhead'>
    <h3>From openSIPS</h3>
    <h1 class='pagename'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation%27" tppabs="http://www.opensips.org/Documentation">Documentation: Development-Manual</a></h1>
  </div>
<!--PageText-->
<div id='wikitext'>
<h5>Documentation -&gt; <a class='wikilink' href="Manuals-action=print.htm" tppabs="http://www.opensips.org/Documentation/Manuals?action=print">Manuals</a> -&gt; OpenSIPS Development Manual</h5>
<p>This page has been visited 3092 times.
</p><hr />
<p class='vspace'><br />
</p><table width='100%'><tr ><td  align='center'><span  style='color: #185662;'><span style='font-size:120%'><strong>OpenSIPS Development Manual</strong></span></span></td></tr>
</table>
<div class='vspace'></div><hr />
<div class='vspace'></div><div class='tocfloat'><p><a name='toc' id='toc'></a><b>Table of Content</b> (<a id="tocidtog" href="javascript:toggle('tocid');">hide</a>)</p><ol class='toc' id='tocid'><li>1.&nbsp;<a href='#toc1'>Introduction</a></li><li>2.&nbsp;<a href='#toc2'>General Architecture</a></li><li>3.&nbsp;<a href='#toc3'>Memory Management</a><ol class='toc'><li>3.1&nbsp;<a href='#toc4'>Private (PKG) Memory</a></li><li>3.2&nbsp;<a href='#toc5'>Shared (SHM) Memory</a></li></ol></li><li>4.&nbsp;<a href='#toc6'>Parsing SIP Messages</a><ol class='toc'><li>4.1&nbsp;<a href='#toc7'>Generic Header Parser</a></li><li>4.2&nbsp;<a href='#toc8'>Specific Header Parsing</a></li><li>4.3&nbsp;<a href='#toc9'>Parsing SIP URIs</a></li><li>4.4&nbsp;<a href='#toc10'>Parsing the SDP Body</a></li></ol></li><li>5.&nbsp;<a href='#toc11'>Changing SIP Messages</a><ol class='toc'><li>5.1&nbsp;<a href='#toc12'>SIP Message Lumps</a></li><li>5.2&nbsp;<a href='#toc13'>SIP Reply Lumps</a></li></ol></li><li>6.&nbsp;<a href='#toc14'>Extending OpenSIPS core Config File</a><ol class='toc'><li>6.1&nbsp;<a href='#toc15'>Adding a core parameter</a></li><li>6.2&nbsp;<a href='#toc16'>Adding a core function</a></li><li>6.3&nbsp;<a href='#toc17'>Adding a core Pseudo-Variable</a></li></ol></li><li>7.&nbsp;<a href='#toc18'>Adding Transformations</a></li><li>8.&nbsp;<a href='#toc19'>Locking API</a><ol class='toc'><li>8.1&nbsp;<a href='#toc20'>Single Lock API</a></li><li>8.2&nbsp;<a href='#toc21'>Lock Set API</a></li><li>8.3&nbsp;<a href='#toc22'>Readers-Writers Locking API</a></li></ol></li><li>9.&nbsp;<a href='#toc23'>Timer API</a><ol class='toc'><li>9.1&nbsp;<a href='#toc24'>Global Timer Process</a></li><li>9.2&nbsp;<a href='#toc25'>Dedicated Timer Process</a></li></ol></li><li>10.&nbsp;<a href='#toc26'>Management Interface API</a></li><li>11.&nbsp;<a href='#toc27'>Statistics API</a></li><li>12.&nbsp;<a href='#toc28'>SQL Database API</a></li><li>13.&nbsp;<a href='#toc29'>NoSQL API</a></li><li>14.&nbsp;<a href='#toc30'>Event Interface API</a></li><li>15.&nbsp;<a href='#toc31'>BIN Interface API</a></li><li>16.&nbsp;<a href='#toc32'>Module Development</a><ol class='toc'><li>16.1&nbsp;<a href='#toc33'>Introduction</a></li><li>16.2&nbsp;<a href='#toc34'>Compiling a module</a></li><li>16.3&nbsp;<a href='#toc35'>Initializing the module</a></li><li>16.4&nbsp;<a href='#toc36'>Destroying the module</a></li><li>16.5&nbsp;<a href='#toc37'>Adding module Parameters</a></li><li>16.6&nbsp;<a href='#toc38'>Adding module Functions</a></li><li>16.7&nbsp;<a href='#toc39'>Adding module MI Functions</a></li><li>16.8&nbsp;<a href='#toc40'>Adding module Statistics</a></li><li>16.9&nbsp;<a href='#toc41'>Adding module Pseudo-variables</a></li><li>16.10&nbsp;<a href='#toc42'>Adding module dedicated Processes</a></li></ol></li><li>17.&nbsp;<a href='#toc43'>Module APIs</a><ol class='toc'><li>17.1&nbsp;<a href='#toc44'>TM module</a></li><li>17.2&nbsp;<a href='#toc45'>RR Module</a></li><li>17.3&nbsp;<a href='#toc46'>Dialog Module</a></li></ol></li><li>18.&nbsp;<a href='#toc47'>Video Tutorial</a></li></ol></div>
<div class='vspace'></div><h4><a name='toc1' id='toc1'></a>1.&nbsp; Introduction</h4>
<p class='vspace'>The focus of the following document will be on the general architecture of OpenSIPS, as well as presenting all the major components and APIs that OpenSIPS exposes for building new modules / features.
<br />The tutorial does not aim to teach Linux / C programming. Below are a list of prerequisites :
</p><ul><li>C programming under Linux
</li><li>Multi-Process programming under Linux
</li><li>Basic Networking Concepts
</li><li>Basic SIP knowledge
</li></ul><p class='vspace'><br />The tutorial is accurate as of OpenSIPS 1.11
</p>
<div class='vspace'></div><h4><a name='toc2' id='toc2'></a>2.&nbsp; General Architecture</h4>
<p>TBD \\ 
</p>
<p class='vspace'>TBD <br />
TBD <br />
</p><h4><a name='toc3' id='toc3'></a>3.&nbsp; Memory Management</h4>
<p>OpenSIPS has it's own memory allocator, and this provides some important advantages over the system memory allocator :
</p><ul><li>the ability to hard limit the memory that OpenSIPS uses
</li><li>improved performance over the system memory allocator
</li><li>multiple allocators are available, each with different use cases ( options are the standard allocator, the memory debugging allocator – useful for debugging memory leaks and memory corruptions – and some others , check the menuconfig configurations options ).
</li></ul><p><br />Furthermore, since OpenSIPS is a multi-process application, the use of shared memory is required in many very common scenarios. The OpenSIPS allocators also hide the shared memory implementations details, and expose a very simple API, very similar to the system allocator.
<br />All OpenSIPS allocators request from the system memory, at startup, the maximum configured memory for OpenSIPS, and then it manages it internally as OpenSIPS starts to use memory while processing traffic.
<br />From OpenSIPS perspective, there are two types of memory, one that is related to the context of a single Process ( Private Memory ) , and another that is shared between all OpenSIPS processes ( Shared Memory ).
<br />
</p><h5><a name='toc4' id='toc4'></a>3.1&nbsp; Private (PKG) Memory</h5>
<p>Private memory is only specific to a single OpenSIPS process. Since it has no visibility outside the current process, no locking mechanisms are required while using such memory. 
<br />
</p><div class='round lrindent tip' > 
<p>Note the common use case where , before forking OpenSIPS processes, the developer stores some static variables in private memory of the main process. After forking, all the child processes will inherit that private memory chunk and each will have it's individual copy of it.
</p></div>
<p class='vspace'><br /><strong>mem/mem.h</strong> exposes all the private memory related functions
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock1'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* <br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; size - size in bytes of the request private memory<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; the actual allocated buffer, or NULL is case of error<br />
*/</span><br />
<span class="kw4">void</span> <span class="sy0">*</span>pkg_malloc<span class="br0">&#40;</span><span class="kw4">unsigned</span> <span class="kw4">int</span> size<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; buf - the buffer to be freed<br />
*/</span><br />
<span class="kw4">void</span> pkg_free<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>buf<span class="br0">&#41;</span><br />
<br />
<span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; buf - buffer that we want to reallocate<br />
&nbsp; &nbsp; &nbsp; size - the new desired buffer size<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; &nbsp; the new buffer address if reallocation is successful, or NULL in case of error. <br />
<br />
Note that pkg_realloc(NULL,size) is equivalent to pkg_malloc(size)<br />
*/</span><br />
<span class="kw4">void</span> <span class="sy0">*</span>pkg_realloc<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>buf<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> size<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc5' id='toc5'></a>3.2&nbsp; Shared (SHM) Memory</h5>
<p>Shared memory can be accessible from all OpenSIPS processes. Thus, generally speaking, all write access to a shared memory buffer should be guarded by some form of synchronization mechanism in order to ensure consistency.<br />Also, since allocations of chunks of shared memory can be requested from all the OpenSIPS processes, the shared memory allocator internally uses locking in order to ensure consistency. Due to this, as a general guideline, it is recommended to avoid big fragmentation of the shared memory ( by requesting many small chunks ), by merging as much information that is meaningfully tied together in a single shared memory chunk.
</p>
<p class='vspace'>mem/shm_mem.h exposes all the shared memory related functions :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock2'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* <br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; size - size in bytes of the request shared memory<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; the actual allocated buffer, or NULL is case of error<br />
*/</span><br />
<span class="kw4">void</span> <span class="sy0">*</span>shm_malloc<span class="br0">&#40;</span><span class="kw4">unsigned</span> <span class="kw4">int</span> size<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; buf - the buffer to be freed<br />
*/</span><br />
<span class="kw4">void</span> shm_free<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>buf<span class="br0">&#41;</span><br />
<br />
<span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; buf - buffer that we want to reallocate<br />
&nbsp; &nbsp; &nbsp; size - the new desired buffer size<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; &nbsp; the new buffer address if reallocation is successful, or NULL in case of error. <br />
<br />
Note that shm_realloc(NULL,size) is equivalent to shm_malloc(size)<br />
*/</span><br />
<span class="kw4">void</span> <span class="sy0">*</span>shm_realloc<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>buf<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> size<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h4><a name='toc6' id='toc6'></a>4.&nbsp; Parsing SIP Messages</h4>
<p>The OpenSIPS SIP message parser is a lazy parser, which performs very well in terms of performance. The behavior is the following :
</p><ul><li>when the message is received, only the 'critical' headers are parsed ( eg : topmost VIA )
</li><li>for known header types, when the developer wants to extract the first occurrence of a header, it does not have to parse the entire message, but rather the parser will stop parsing when the first needed header type was identified
</li></ul><p><br />Also, important to note that there are two types of parsing :
</p><ul><li>parsing in the sense of identifying header boundaries and separating between the header name and header body ( eg : parsing the 'To : vlad@opensips.org;tag=123\r\n' header, and identifying that first, the header is present, and secondly that the body is 'vlad@opensips.org;tag=123\r\n' )
</li><li>in-depth parsing of a specific header type, for identifying header specific information ( in our example, extracting the to-tag in the TO header, etc ).
</li></ul><p><br />Also, all parsing is done in a stateful manner, in the sense that the OpenSIPS parser know which header was parsed and by internally storing a bitmask. Thus, once the TO header was first parsed, any subsequent attempts of parsing the TO header will return immediately.
<br />Parser implementations are generally exported in the <strong>parser/</strong> folder.
</p>
<div class='vspace'></div><h5><a name='toc7' id='toc7'></a>4.1&nbsp; Generic Header Parser</h5>
<p>The generic parser of SIP headers is exposed by <strong>parser/msg_parser.h</strong> . The function to be used is :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock3'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; msg : the SIP message that needs to be parsed – see parser/msg_parser.h for details on the struct sip_msg structure<br />
&nbsp; &nbsp; &nbsp; flags : bitmask of header types that need to be parsed<br />
&nbsp; &nbsp; &nbsp; next : specifies whether the parser should explicitly force the parsing of new headers from the provided bitmask, even though those header types were already previously found. Can be useful when trying to find a second occurrence of a header ( in the case that header can appear multiple times in a SIP message – eg. Route )<br />
<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 in case of error, -1 in case of error ( either header was not found or some other error occurred ).<br />
*/</span><br />
<span class="kw4">int</span> parse_headers<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span> hdr_flags_t flags<span class="sy0">,</span> <span class="kw4">int</span> next<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Example of usage :
<br />
<div class='sourceblock ' id='sourceblock4'>
  <div class='sourceblocktext'><div class="c"><span class="kw1">if</span><span class="br0">&#40;</span>parse_headers<span class="br0">&#40;</span>req<span class="sy0">,</span>HDR_CALLID_F<span class="sy0">|</span>HDR_TO_F<span class="sy0">|</span>HDR_FROM_F<span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span> <span class="sy0">||</span> <span class="sy0">!</span>req<span class="sy0">-&gt;</span>callid <span class="sy0">||</span> <span class="sy0">!</span>req<span class="sy0">-&gt;</span>to <span class="sy0">||</span> <span class="sy0">!</span>req<span class="sy0">-&gt;</span>from<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;bad request or missing CALLID/TO/FROM hdr <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<br /><strong>HDR_EOH_F</strong> is exposed in case the developer wants to parse all the headers in the current SIP message.
<br />
</p><div class='round lrindent tip' > 
<p>The parse_headers() function will not duplicate SIP headers at all – the hooks in the struct sip_msg structure will be populated with pointers that point directly in the SIP message buffer.
</p></div>
<p class='vspace'><br />Upon return, if successful, the function will populate the respective hooks in the  sip_msg structure for known headers.The hdr_field* structures are allocated in pkg memory, and will automatically be freed when the SIP message processing has finished.
<br />After succesful parsing, the developer can access the header name and body like this :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock5'>
  <div class='sourceblocktext'><div class="c">LM_INFO<span class="br0">&#40;</span>“The callid header name is <span class="sy0">%</span>.<span class="sy0">*</span>s and the callid header body is <span class="sy0">%</span>.<span class="sy0">*</span>s \n”<span class="sy0">,</span> req<span class="sy0">-&gt;</span>callid<span class="sy0">-&gt;</span>name.<span class="me1">len</span><span class="sy0">,</span> req<span class="sy0">-&gt;</span>callid<span class="sy0">-&gt;</span>name.<span class="me1">s</span><span class="sy0">,</span> req<span class="sy0">-&gt;</span>callid<span class="sy0">-&gt;</span>bodylen. &nbsp;<span class="me1">req</span><span class="sy0">-&gt;</span>callid<span class="sy0">-&gt;</span>body.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc8' id='toc8'></a>4.2&nbsp; Specific Header Parsing</h5>
<p>For parsing a specific header type, and extracting the header type relevant information, the parser/ folder contains all implementations for known headers. 
The naming convention is that parser/parse_X.h will expose the parsing for the X header name.
<br />For example, here is the implementation of the parsing of the TO header, exposed by <strong>parser/parse_to.h</strong> :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock6'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">int</span> parse_to_header<span class="br0">&#40;</span> <span class="kw4">struct</span> sip_msg <span class="sy0">*</span>msg<span class="br0">&#41;</span> <br />
<span class="br0">&#123;</span> &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> to_body<span class="sy0">*</span> to_b<span class="sy0">;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">!</span>msg<span class="sy0">-&gt;</span>to <span class="sy0">&amp;&amp;</span> <span class="br0">&#40;</span> parse_headers<span class="br0">&#40;</span>msg<span class="sy0">,</span>HDR_TO_F<span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">==-</span><span class="nu0">1</span> <span class="sy0">||</span> <span class="sy0">!</span>msg<span class="sy0">-&gt;</span>to<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;bad msg or missing To header<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* maybe the header is already parsed! */</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>msg<span class="sy0">-&gt;</span>to<span class="sy0">-&gt;</span>parsed<span class="br0">&#41;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* bad luck! :-( - we have to parse it */</span> <br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* first, get some memory */</span> <br />
&nbsp; &nbsp; &nbsp; to_b <span class="sy0">=</span> pkg_malloc<span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">struct</span> to_body<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>to_b <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;out of pkg_memory<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* now parse it!! */</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw3">memset</span><span class="br0">&#40;</span>to_b<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">struct</span> to_body<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; parse_to<span class="br0">&#40;</span>msg<span class="sy0">-&gt;</span>to<span class="sy0">-&gt;</span>body.<span class="me1">s</span><span class="sy0">,</span>msg<span class="sy0">-&gt;</span>to<span class="sy0">-&gt;</span>body.<span class="me1">s</span><span class="sy0">+</span>msg<span class="sy0">-&gt;</span>to<span class="sy0">-&gt;</span>body.<span class="me1">len</span><span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span>to_b<span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>to_b<span class="sy0">-&gt;</span>error <span class="sy0">==</span> PARSE_ERROR<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;bad to header<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkg_free<span class="br0">&#40;</span>to_b<span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; msg<span class="sy0">-&gt;</span>to<span class="sy0">-&gt;</span>parsed <span class="sy0">=</span> to_b<span class="sy0">;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span> <br />
error<span class="sy0">:</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
<span class="br0">&#125;</span> </div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent tip' > 
<p>Note that the <strong>void *parsed</strong> element in the hdr_field structure will contain the header specific  parser structure, which will also be allocated into private memory and automatically freed when the SIP message processing has finished.
</p></div>
<p class='vspace'><br />After parse_to_header() successfully returns, the developer can start accessing the parsed TO header in the following way :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock7'>
  <div class='sourceblocktext'><div class="c">LM_INFO<span class="br0">&#40;</span>“The TO header tag value is <span class="sy0">%</span>.<span class="sy0">*</span>s \n”<span class="sy0">,</span>get_to<span class="br0">&#40;</span>msg<span class="br0">&#41;</span><span class="sy0">-&gt;</span>tag_value.<span class="me1">len</span><span class="sy0">,</span> get_to<span class="br0">&#40;</span>msg<span class="br0">&#41;</span><span class="sy0">-&gt;</span>tag_value.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc9' id='toc9'></a>4.3&nbsp; Parsing SIP URIs</h5>
<p>The OpenSIPS parser also exposes the functionality of parsing individual SIP URI.<br /><strong>parser/parse_uri.h</strong> exposes :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock8'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; buf - the string which contains our SIP URI<br />
&nbsp; &nbsp; &nbsp; len - length of the SIP URI buffer<br />
&nbsp; &nbsp; &nbsp; uri - structure which will be populated by the function in case of success. <br />
&nbsp; &nbsp; &nbsp; See full struct sip_uri members in parser/msg_parser.h<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 in case of success, negative value in case of error parsing the URI<br />
*/</span><br />
<span class="kw4">int</span> parse_uri<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span>buf<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">struct</span> sip_uri<span class="sy0">*</span> uri<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The parse_uri() function does not allocate any memory, it just populates the sip_uri structure with references to the buf parameter provided as input.
<br />Here is an example of parsing the TO URI :
</p>
<div class='sourceblock ' id='sourceblock9'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* make sure TO header is parsed before this */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> to_body <span class="sy0">*</span>tb <span class="sy0">=</span> get_to<span class="br0">&#40;</span>msg<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>parse_uri<span class="br0">&#40;</span>tb<span class="sy0">-&gt;</span>uri.<span class="me1">s</span><span class="sy0">,</span> tb<span class="sy0">-&gt;</span>uri.<span class="me1">len</span> <span class="sy0">,</span> <span class="sy0">&amp;</span>tb<span class="sy0">-&gt;</span>parsed_uri<span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;failed to parse To uri<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; LM_INFO<span class="br0">&#40;</span>“TO URI user is <span class="sy0">%</span>.<span class="sy0">*</span>s and TO URI domain is <span class="sy0">%</span>.<span class="sy0">*</span>s\n”<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; tb<span class="sy0">-&gt;</span>parsed_uri.<span class="me1">user</span>.<span class="me1">len</span><span class="sy0">,</span> tb<span class="sy0">-&gt;</span>parsed_uri.<span class="me1">user</span>.<span class="me1">s</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; tb<span class="sy0">-&gt;</span>parsed_uri.<span class="me1">domain</span>.<span class="me1">len</span><span class="sy0">,</span> tb<span class="sy0">-&gt;</span>parsed_uri.<span class="me1">domain</span>.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc10' id='toc10'></a>4.4&nbsp; Parsing the SDP Body</h5>
<p>OpenSIPS exposes functions for operating on the SIP message body.
<br /><strong>parser/msg_parser.h</strong> exposes 
</p>
<div class='sourceblock ' id='sourceblock10'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; msg - the SIP message to fetch the body for<br />
&nbsp; &nbsp; &nbsp; body - output param, which will hold the body pointer inside the SIP message and the body length, or {NULL,0} in case of no body present<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 in case of success, or -1 in the case of parsing errors ( the function needs to internally parse all the headers in order to detect the body length ).<br />
*/</span><br />
<span class="kw4">int</span> get_body<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg <span class="sy0">*</span>msg<span class="sy0">,</span> str <span class="sy0">*</span>body<span class="br0">&#41;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />For parsing the SDP body and extracting various information about the session(s) , <strong>parser/sdp/sdp.h</strong> exposes
</p>
<div class='sourceblock ' id='sourceblock11'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; _m - the SIP message to have it's SDP parsed<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 in case of success, negative in case of error<br />
*/</span><br />
<span class="kw4">int</span> parse_sdp<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> _m<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The function will internally populate <strong>_m-&gt;sdp</strong> , see <strong>parser/sdp/sdp.h</strong> for more details on the <strong>sdp_info</strong> structure.
</p>
<div class='vspace'></div><h4><a name='toc11' id='toc11'></a>5.&nbsp; Changing SIP Messages</h4>
<p>The standard mechanism for performing changes on SIP messages within OpenSIPS is by using the so called <strong>lumps system</strong>.
<br />The lump system works very similarly to the diff/patch tools in the Linux environment – the developer adds add and/or remove operations to a SIP message. The lumps are stored in a list, and are only applied after the OpenSIPS script is fully executed and before the SIP message is relayed. Because of this, changes done on a SIP message are not immediately reflected on the SIP message upon further inspection ( eg. Adding a new header from the script and then checking for the header's existence ).
<br />When talking about the SIP message they have an effect on, the lumps can be split into the following categories :
</p>
<div class='vspace'></div><h5><a name='toc12' id='toc12'></a>5.1&nbsp; SIP Message Lumps</h5>
<p>This type of lumps operate on the current SIP message context. 
<br />From operational point of view, they are also split into two categories :
</p>
<div class='vspace'></div><h6>Delete Lumps</h6>
<p><strong>data_lump.h</strong> exposes 
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock12'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; msg - the SIP message the lump will affect<br />
&nbsp; &nbsp; &nbsp; offset - the offset in the SIP message at which to start deleting<br />
&nbsp; &nbsp; &nbsp; len - the number of characters to delete from the SIP message<br />
&nbsp; &nbsp; &nbsp; type - indication on which header the current lump affects ( can be 0 )<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; the created lump structure for deleting part of the SIP message. Can be further used to chain together different types of lumps in the message attached list of lumps. NULL is returned in case of internal error.<br />
*/</span><br />
<span class="kw4">struct</span> lump<span class="sy0">*</span> del_lump<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> offset<span class="sy0">,</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw2">enum</span> _hdr_types_t type<span class="br0">&#41;</span><span class="sy0">;</span> </div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Example of deleting the RPID header :
</p>
<div class='sourceblock ' id='sourceblock13'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* first parse the header to figure out where it actually starts in the SIP message */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span> parse_headers<span class="br0">&#40;</span>msg<span class="sy0">,</span>HDR_RPID_F<span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span> <span class="sy0">||</span> msg<span class="sy0">-&gt;</span>rpid <span class="sy0">==</span> NULL <span class="br0">&#41;</span><span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_DBG<span class="br0">&#40;</span>“No rpid header – nothing to delete \n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* delete the entire RPID header */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> del_lump<span class="br0">&#40;</span>msg<span class="sy0">,</span> msg<span class="sy0">-&gt;</span>rpid<span class="sy0">-&gt;</span>name.<span class="me1">s</span><span class="sy0">-</span>msg<span class="sy0">-&gt;</span>buf<span class="sy0">,</span> msg<span class="sy0">-&gt;</span>rpid<span class="sy0">-&gt;</span>len<span class="sy0">,</span>HDR_RPID_T <span class="br0">&#41;</span><span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“Failed to delete RPID header \n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h6>Add Lumps</h6>
<p><strong>data_lump.h</strong> exposes 
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock14'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; after/before - the lump where we will connect our new lump<br />
&nbsp; &nbsp; &nbsp; new_hdr - string to be added<br />
&nbsp; &nbsp; &nbsp; len - length of the string to be added<br />
&nbsp; &nbsp; &nbsp; type - header type that is affected by the current change ( can be 0 )<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; the created lump structure for adding to the SIP message. Can be further used to chain together different types of lumps in the message attached list of lumps. NULL is returned in case of internal error.<br />
*/</span><br />
<span class="kw4">struct</span> lump<span class="sy0">*</span> insert_new_lump_after<span class="br0">&#40;</span><span class="kw4">struct</span> lump<span class="sy0">*</span> after<span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span><span class="sy0">*</span> new_hdr<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw2">enum</span> _hdr_types_t type<span class="br0">&#41;</span><span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
<span class="kw4">struct</span> lump<span class="sy0">*</span> insert_new_lump_before<span class="br0">&#40;</span><span class="kw4">struct</span> lump<span class="sy0">*</span> before<span class="sy0">,</span> <span class="kw4">char</span><span class="sy0">*</span> new_hdr<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> len<span class="sy0">,</span><span class="kw2">enum</span> _hdr_types_t type<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />If the developer's desire is just to add a particular string to the SIP message, a new anchor lump must be created, that will then have to be provided as the first parameter to insert_new_lump_after/insert_new_lump_before.
<br />For creating a new anchor lump, data_lump.h also exports
</p>
<div class='sourceblock ' id='sourceblock15'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; msg - the SIP message that will be affected by the lump anchor<br />
&nbsp; &nbsp; &nbsp; offset - the offset in the SIP message where the anchor will be placed<br />
&nbsp; &nbsp; &nbsp; len - not currently used ( should be 0 )<br />
&nbsp; &nbsp; &nbsp; type - header type that is affected by the current change ( can be 0 )<br />
Returns:<br />
&nbsp; &nbsp; &nbsp; the created lump structure for adding to the SIP message. Can be further used to chain together different types of lumps in the message attached list of lumps. NULL is returned in case of internal error.<br />
*/</span><br />
<span class="kw4">struct</span> lump<span class="sy0">*</span> anchor_lump<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> offset<span class="sy0">,</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> <span class="kw4">unsigned</span> len<span class="sy0">,</span> <span class="kw2">enum</span> _hdr_types_t type<span class="br0">&#41;</span> </div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Example of adding a new SIP header at the end of the SIP message headers :
</p>
<div class='sourceblock ' id='sourceblock16'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* make sure we detect all headers */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>parse_headers<span class="br0">&#40;</span>msg<span class="sy0">,</span> HDR_EOH_F<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="sy0">==</span> <span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;error while parsing message<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* add the anchor at the very end of the SIP headers */</span><br />
&nbsp; &nbsp; &nbsp; anchor <span class="sy0">=</span> anchor_lump<span class="br0">&#40;</span>msg<span class="sy0">,</span> msg<span class="sy0">-&gt;</span>unparsed <span class="sy0">-</span> msg<span class="sy0">-&gt;</span>buf<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>anchor <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“Failed to create lump anchor\n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; len <span class="sy0">=</span> &nbsp;<span class="kw4">sizeof</span><span class="br0">&#40;</span>“MY_HDR<span class="sy0">:</span> MY_VAL\r\n”<span class="br0">&#41;</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; new_hdr<span class="sy0">=</span>pkg_malloc<span class="br0">&#40;</span>len<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>new_hdr<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“No more pkg mem\n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw3">memcpy</span><span class="br0">&#40;</span>new_hdr<span class="sy0">,</span>”MY_HDR<span class="sy0">:</span> MY_VAL\r\n”<span class="sy0">,</span>len<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>insert_new_lump_after<span class="br0">&#40;</span>anchor<span class="sy0">,</span> new_hdr<span class="sy0">,</span> len<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;can't insert lump<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkg_free<span class="br0">&#40;</span>new_hdr<span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* job done, the PKG new_hdr mem will be free internally when the lump will be applied */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p class='vspace'>If we want to replace a particular part of a SIP message, the operation can be split in two steps, first deleting the part we don't need anymore by calling del_lump, and then using the returned lump to add a new lump after it.
<br />Example of replacing the content of the RPID header :
</p>
<div class='sourceblock ' id='sourceblock17'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* first parse the header to figure out where it actually starts in the SIP message */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span> parse_headers<span class="br0">&#40;</span>msg<span class="sy0">,</span>HDR_RPID_F<span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span> <span class="sy0">||</span> msg<span class="sy0">-&gt;</span>rpid <span class="sy0">==</span> NULL <span class="br0">&#41;</span><span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_DBG<span class="br0">&#40;</span>“No rpid header – nothing to delete \n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* delete just the contents of the RPID header */</span><br />
&nbsp; &nbsp; &nbsp; del <span class="sy0">=</span> &nbsp;del_lump<span class="br0">&#40;</span>msg<span class="sy0">,</span> msg<span class="sy0">-&gt;</span>rpid<span class="sy0">-&gt;</span>body.<span class="me1">s</span><span class="sy0">-</span>msg<span class="sy0">-&gt;</span>buf<span class="sy0">,</span> msg<span class="sy0">-&gt;</span>rpid<span class="sy0">-&gt;</span>body.<span class="me1">len</span><span class="sy0">,</span>HDR_RPID_T<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> del <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“Failed to delete RPID header \n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; len <span class="sy0">=</span> &nbsp;<span class="kw4">sizeof</span><span class="br0">&#40;</span>“sip<span class="sy0">:</span>new_rpid@my_domain.<span class="me1">com</span>\r\n”<span class="br0">&#41;</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; new_rpid<span class="sy0">=</span>pkg_malloc<span class="br0">&#40;</span>len<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>new_rpid<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“No more pkg mem\n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw3">memcpy</span><span class="br0">&#40;</span>new_rpid<span class="sy0">,</span>“sip<span class="sy0">:</span>new_rpid@my_domain.<span class="me1">com</span>\r\n”<span class="sy0">,</span>len<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>insert_new_lump_after<span class="br0">&#40;</span>del<span class="sy0">,</span>new_rpid<span class="sy0">,</span>len<span class="sy0">,</span>HDR_RPID_T<span class="br0">&#41;</span><span class="sy0">==</span>NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to insert new callid<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkg_free<span class="br0">&#40;</span>new_rpid<span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> </div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc13' id='toc13'></a>5.2&nbsp; SIP Reply Lumps</h5>
<p>When used in the case of a SIP request, these lumps will operate on the SIP reply that will be internally generated when rejecting a request from within OpenSIPS ( if the Request if forwarded instead of rejected at OpenSIPS level, these lumps will have no effect ). Since the reply will be internally generated by OpenSIPS,  the Reply Lumps can only add new content.
<br /><strong>data_lump_rpl.h</strong>  exposes
</p>
<div class='sourceblock ' id='sourceblock18'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; msg - the SIP Request that the reply will be generated for<br />
&nbsp; &nbsp; &nbsp; s - the string to be added to the reply<br />
&nbsp; &nbsp; &nbsp; len - the length of the string to be added<br />
&nbsp; &nbsp; &nbsp; flags - Since the reply will be generated by OpenSIPS, it is important to mark your lump if it should be added to the Reply headers or to the Reply body. Relevant flags for these cases are LUMP_RPL_HDR and LUMP_RPL_BODY.<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; the created lump structure for adding to the SIP reply. Can be further used to chain together lumps in the message attached list of lumps. NULL is returned in case of internal error.<br />
*/</span><br />
<span class="kw4">struct</span> lump_rpl<span class="sy0">*</span> add_lump_rpl<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg <span class="sy0">*</span>msg<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>s<span class="sy0">,</span> <span class="kw4">int</span> len<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Example of Adding contact header to the internally generated reply :
</p>
<div class='sourceblock ' id='sourceblock19'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; <span class="kw4">static</span> <span class="kw4">char</span> ct<span class="br0">&#91;</span>CT_LEN<span class="br0">&#93;</span> <span class="sy0">=</span> “Contact<span class="sy0">:</span> opensips@my_domain.<span class="me1">com</span>\r\n”<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* we are adding a lump to the headers, so we pass the &nbsp;LUMP_RPL_HDR flag<br />
&nbsp; &nbsp; &nbsp; also , our buffer is located in a static buffer, thus no need for the core to allocate memory for this lump, we also pass the LUMP_RPL_NODUP flag */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>add_lump_rpl<span class="br0">&#40;</span>msg<span class="sy0">,</span> ct<span class="sy0">,</span> CT_LEN<span class="sy0">,</span> LUMP_RPL_HDR <span class="sy0">|</span> &nbsp;LUMP_RPL_NODUP<span class="br0">&#41;</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;unable to add lump<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> </div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h4><a name='toc14' id='toc14'></a>6.&nbsp; Extending OpenSIPS core Config File</h4>
<p>OpenSIPS uses flex and bison in order to parse the configuration file and then build the entire action tree that a SIP message will go through once it is read from network level. <br />When it comes to extending the OpenSIPS configuration file directly in the core, the developer can either choose to add a new core parameter, or a new core function. 
</p>
<div class='vspace'></div><h5><a name='toc15' id='toc15'></a>6.1&nbsp; Adding a core parameter</h5>
<p>In the following step by step tutorial, we will follow the implementation of the <strong>children</strong> core parameter, which is an integer controlling the number of OpenSIPS processes per UDP interface. <br />First of all, we will have to add the variable that will hold the value of our new core parameter. <br />In our case, in <strong>globals.h</strong> we have added 
</p>
<div class='sourceblock ' id='sourceblock20'>
  <div class='sourceblocktext'><div class="c"><span class="kw2">extern</span> <span class="kw4">int</span> children_no<span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Adding the variable here will make it visible in both the OpenSIPS core and the OpenSIPS modules. <strong>main.c</strong> will hold the actual variable :
</p>
<div class='sourceblock ' id='sourceblock21'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* Default value in case the parameter is not set from the script */</span><br />
<span class="kw4">int</span> children_no <span class="sy0">=</span> <span class="nu0">8</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Next, we will have to modify the grammar in order to accept our new parameter.
In <strong>cfg.y</strong> , first we will define our new token :
</p>
<div class='sourceblock ' id='sourceblock22'>
  <div class='sourceblocktext'><div class="c"><span class="sy0">%</span>token CHILDREN</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />And then we'll set the parsing rules for the new token
</p>
<div class='sourceblock ' id='sourceblock23'>
  <div class='sourceblocktext'><div class="c"><span class="sy0">|</span> CHILDREN EQUAL NUMBER <span class="br0">&#123;</span> children_no<span class="sy0">=</span>$<span class="nu19">3</span><span class="sy0">;</span> <span class="br0">&#125;</span> <br />
<span class="sy0">|</span> CHILDREN EQUAL error <span class="br0">&#123;</span> yyerror<span class="br0">&#40;</span><span class="st0">&quot;number expected&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Our variable will have a numeric variable, anything else will trigger and error in parsing the OpenSIPS script.
</p>
<div class='vspace'></div><h5><a name='toc16' id='toc16'></a>6.2&nbsp; Adding a core function</h5>
<p>In the following step by step tutorial, we will follow the implementation of the <strong>xlog</strong> core parameter, which is used to print debugging information to the logging facility.
</p>
<div class='vspace'></div><div class='round lrindent tip' > 
<p>Note that xlog can receive either a single parameter ( the string to be printed ), or two parameters ( the log level and then the string to be printed ).
</p></div>
<p class='vspace'>First, the grammar will have to be extended. In <strong>cfg,y</strong> we have :
</p>
<div class='sourceblock ' id='sourceblock24'>
  <div class='sourceblocktext'><div class="c"><span class="sy0">%</span>token XLOG<br />
...<br />
...<br />
<span class="sy0">|</span> XLOG LPAREN STRING RPAREN <span class="br0">&#123;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp; &nbsp; mk_action1<span class="br0">&#40;</span>$$<span class="sy0">,</span> XLOG_T<span class="sy0">,</span> STR_ST<span class="sy0">,</span> $<span class="nu19">3</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="br0">&#125;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;XLOG LPAREN STRING COMMA STRING RPAREN <span class="br0">&#123;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp; &nbsp; &nbsp; mk_action2<span class="br0">&#40;</span>$$<span class="sy0">,</span> XLOG_T<span class="sy0">,</span> STR_ST<span class="sy0">,</span> STR_ST<span class="sy0">,</span> $<span class="nu19">3</span><span class="sy0">,</span> $<span class="nu19">5</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="br0">&#125;</span> </div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Note the two different forms of xlog displayed above.
<br />From the grammar, we will start building the actions. In <strong>route.c</strong> we will define the fixup part of the function, where all the sanity checks and parameter parsing should be done. The fixup part will be invoked only once, at script parsing.
</p>
<div class='sourceblock ' id='sourceblock25'>
  <div class='sourceblocktext'><div class="c"><span class="kw1">case</span> XLOG_T<span class="sy0">:</span> <br />
&nbsp; &nbsp; &nbsp; s.<span class="me1">s</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">char</span><span class="sy0">*</span><span class="br0">&#41;</span>t<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">u</span>.<span class="me1">data</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>s.<span class="me1">s</span> <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* commands have only one parameter */</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.<span class="me1">s</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span><span class="br0">&#41;</span>t<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">u</span>.<span class="me1">data</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s.<span class="me1">len</span> <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">&#40;</span>s.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>s.<span class="me1">len</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;param is empty string!<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> E_CFG<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* parse the format provided to xlog - we can have variables inside */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>pv_parse_format<span class="br0">&#40;</span><span class="sy0">&amp;</span>s <span class="sy0">,&amp;</span>model<span class="br0">&#41;</span> <span class="sy0">||</span> model<span class="sy0">==</span>NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;wrong format [%s] for value param!<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> s.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<span class="sy0">=</span>E_BUG<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* overwrite the data that will be passed to contain our new parsed model */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">u</span>.<span class="me1">data</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">void</span><span class="sy0">*</span><span class="br0">&#41;</span>model<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">type</span> <span class="sy0">=</span> SCRIPTVAR_ELEM_ST<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* two parameters */</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />In <strong>action.c</strong> we will have to add the actual code that needs to get executed when the function gets called from the OpenSIPS script at runtime :
</p>
<div class='sourceblock ' id='sourceblock26'>
  <div class='sourceblocktext'><div class="c"><span class="kw1">case</span> XLOG_T<span class="sy0">:</span><br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* add helpers for tracing the script */</span><br />
&nbsp; &nbsp; &nbsp; script_trace<span class="br0">&#40;</span><span class="st0">&quot;core&quot;</span><span class="sy0">,</span> <span class="st0">&quot;xlog&quot;</span><span class="sy0">,</span> msg<span class="sy0">,</span> a<span class="sy0">-&gt;</span>line<span class="br0">&#41;</span> <span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>a<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">u</span>.<span class="me1">data</span> <span class="sy0">!=</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* we have two parameters */</span> <br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* do security checks for the types of the provided parameters, second param has to be a SCRIPTVAR model as we've coded in the fixup */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>a<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">type</span> <span class="sy0">!=</span> SCRIPTVAR_ELEM_ST<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ALERT<span class="br0">&#40;</span><span class="st0">&quot;BUG in xlog() type %d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> a<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">type</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<span class="sy0">=</span>E_BUG<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw2">break</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* log level should be a plaintext string */</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>a<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">type</span> <span class="sy0">!=</span> STR_ST<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ALERT<span class="br0">&#40;</span><span class="st0">&quot;BUG in xlog() type %d<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> a<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">type</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<span class="sy0">=</span>E_BUG<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw2">break</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* call our C code function implementing the desired actions */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>xlog_2<span class="br0">&#40;</span>msg<span class="sy0">,</span>a<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">u</span>.<span class="me1">data</span><span class="sy0">,</span> a<span class="sy0">-&gt;</span>elem<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">u</span>.<span class="me1">data</span><span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ALERT<span class="br0">&#40;</span><span class="st0">&quot;Cannot print xlog debug message&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw2">break</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* one parameter case */</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc17' id='toc17'></a>6.3&nbsp; Adding a core Pseudo-Variable</h5>
<p>All the OpenSIPS core pseudo-variables are defined in <strong>pvar.c</strong> :
</p>
<div class='sourceblock ' id='sourceblock27'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">static</span> pv_export_t _pv_names_table<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="br0">&#123;</span><span class="st0">&quot;avp&quot;</span><span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="st0">&quot;avp&quot;</span><span class="br0">&#41;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy0">,</span> PVT_AVP<span class="sy0">,</span> pv_get_avp<span class="sy0">,</span> pv_set_avp<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pv_parse_avp_name<span class="sy0">,</span> pv_parse_index<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="br0">&#123;</span><span class="st0">&quot;hdr&quot;</span><span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="st0">&quot;hdr&quot;</span><span class="br0">&#41;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy0">,</span> PVT_HDR<span class="sy0">,</span> pv_get_hdr<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> pv_parse_hdr_name<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pv_parse_index<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#125;</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="br0">&#123;</span><span class="st0">&quot;hdrcnt&quot;</span><span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="st0">&quot;hdrcnt&quot;</span><span class="br0">&#41;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy0">,</span> PVT_HDRCNT<span class="sy0">,</span> pv_get_hdrcnt<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> pv_parse_hdr_name<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="br0">&#123;</span><span class="st0">&quot;var&quot;</span><span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="st0">&quot;var&quot;</span><span class="br0">&#41;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy0">,</span> PVT_SCRIPTVAR<span class="sy0">,</span> pv_get_scriptvar<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pv_set_scriptvar<span class="sy0">,</span> pv_parse_scriptvar_name<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="br0">&#123;</span><span class="st0">&quot;ai&quot;</span><span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="st0">&quot;ai&quot;</span><span class="br0">&#41;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy0">,</span> <span class="coMULTI">/* */</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVT_PAI_URI<span class="sy0">,</span> pv_get_pai<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#125;</span><span class="sy0">,</span> &nbsp;<br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="br0">&#123;</span><span class="st0">&quot;au&quot;</span><span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="st0">&quot;au&quot;</span><span class="br0">&#41;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy0">,</span> <span class="coMULTI">/* */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVT_AUTH_USERNAME<span class="sy0">,</span> pv_get_authattr<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> pv_init_iname<span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#125;</span><span class="sy0">,</span><br />
...<br />
...<br />
...</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The general syntax of an OpenSIPS pseudo-variable, along with the pv_export_t structure to be used in OpenSIPS ( both in core and in modules ) to expose new PVARs are shown below :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock28'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*! \brief<br />
&nbsp;* PV spec format:<br />
&nbsp;* - $class_name<br />
&nbsp;* - $class_name(inner_name)<br />
&nbsp;* - $(class_name[index])<br />
&nbsp;* - $(class_name(inner_name)[index])<br />
&nbsp;* - $(class_name{transformation})<br />
&nbsp;* - $(class_name(inner_name){transformation})<br />
&nbsp;* - $(class_name[index]{transformation}) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp;* - $(class_name(inner_name)[index]{transformation})<br />
&nbsp;*/</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
<span class="kw4">typedef</span> <span class="kw4">struct</span> _pv_export <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str name<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/*!&lt; class name of PV */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; pv_type_t type<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/*!&lt; type of PV */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; pv_getf_t &nbsp;getf<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; function to get the value */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; pv_setf_t &nbsp;setf<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; function to set the value */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; pv_parse_name_f parse_name<span class="sy0">;</span> &nbsp; &nbsp;<span class="coMULTI">/*!&lt; function to parse the inner name */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; pv_parse_index_f parse_index<span class="sy0">;</span> &nbsp;<span class="coMULTI">/*!&lt; function to parse the index of PV */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; pv_init_param_f init_param<span class="sy0">;</span> &nbsp; &nbsp;<span class="coMULTI">/*!&lt; function to init the PV spec */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> iparam<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/*!&lt; parameter for the init function */</span><br />
<span class="br0">&#125;</span> pv_export_t<span class="sy0">;</span> &nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Further on we will follow the implementation of the <strong>$ru</strong> pseudovariable, which offers read/write access to the SIP message Request-URI.
<br />First, PVT_RURI was added in <strong>pvar.h</strong> in <strong>enum _pv_type</strong>.
<br /><br />Afterwards, the following was added in <strong>_pv_names_table</strong> :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock29'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="br0">&#123;</span><span class="st0">&quot;ru&quot;</span><span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="st0">&quot;ru&quot;</span><span class="br0">&#41;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#125;</span><span class="sy0">,</span> <span class="coMULTI">/* */</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PVT_RURI<span class="sy0">,</span> pv_get_ruri<span class="sy0">,</span> pv_set_ruri<span class="sy0">,</span> &nbsp;<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#125;</span><span class="sy0">,</span> &nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p class='vspace'>Our new pvar will be accessible from script by using <strong>$ru</strong>. Read access from the script will lead to <strong>pv_get_ruri</strong> getting called, while write requests to $ru will make a call to <strong>pv_set_ruri</strong>.
<br />Since the $ru pvar does not support indexing by concept ( the SIP message has one and only one Request-URI ), there is no need to add a parsing or an indexing function for our pseudovariable. Also, no special initialization is needed for our psedovariable case, since we will operate directly on the currently processed SIP message in the script.
<br />
</p>
<div class='sourceblock ' id='sourceblock30'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* <br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; msg - the message context to evaluate the current pvar <br />
&nbsp; &nbsp; &nbsp; param - the parameter provided for evaluating the pvar<br />
&nbsp; &nbsp; &nbsp; res - the output value of our pvar <br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 in case of success, negative in case of error<br />
*/</span> &nbsp; &nbsp; &nbsp;<br />
<span class="kw4">static</span> <span class="kw4">int</span> pv_get_ruri<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg <span class="sy0">*</span>msg<span class="sy0">,</span> pv_param_t <span class="sy0">*</span>param<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pv_value_t <span class="sy0">*</span>res<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>msg<span class="sy0">==</span>NULL <span class="sy0">||</span> res<span class="sy0">==</span>NULL<span class="br0">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>msg<span class="sy0">-&gt;</span>first_line.<span class="me1">type</span> <span class="sy0">==</span> SIP_REPLY<span class="br0">&#41;</span> &nbsp; <span class="coMULTI">/* REPLY doesnt have a ruri */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> pv_get_null<span class="br0">&#40;</span>msg<span class="sy0">,</span> param<span class="sy0">,</span> res<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>msg<span class="sy0">-&gt;</span>parsed_uri_ok<span class="sy0">==</span><span class="nu0">0</span> <span class="coMULTI">/* R-URI not parsed*/</span> <span class="sy0">&amp;&amp;</span> parse_sip_msg_uri<span class="br0">&#40;</span>msg<span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;failed to parse the R-URI<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> pv_get_null<span class="br0">&#40;</span>msg<span class="sy0">,</span> param<span class="sy0">,</span> res<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>msg<span class="sy0">-&gt;</span>new_uri.<span class="me1">s</span><span class="sy0">!=</span>NULL<span class="br0">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> pv_get_strval<span class="br0">&#40;</span>msg<span class="sy0">,</span> param<span class="sy0">,</span> res<span class="sy0">,</span> <span class="sy0">&amp;</span>msg<span class="sy0">-&gt;</span>new_uri<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> pv_get_strval<span class="br0">&#40;</span>msg<span class="sy0">,</span> param<span class="sy0">,</span> res<span class="sy0">,</span> <span class="sy0">&amp;</span>msg<span class="sy0">-&gt;</span>first_line.<span class="me1">u</span>.<span class="me1">request</span>.<span class="me1">uri</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent important' > 
<p>For all read access on the PVARs from contexts where the PVAR does not have any meaningful value (eg. Request-URI from a Reply Context), make sure to use <strong>pv_get_null</strong> to signal this to the script writer.
</p></div>
<p class='vspace'><br />
<div class='sourceblock ' id='sourceblock31'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; msg - the SIP message to apply the changes to<br />
&nbsp; &nbsp; &nbsp; param - the parameter provided for evaluating the pvar<br />
&nbsp; &nbsp; &nbsp; op - further indication on the type of write access to be done<br />
&nbsp; &nbsp; &nbsp; val - value to be pushed to our pvar<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 in case of success, negative in case of error<br />
*/</span><br />
<span class="kw4">int</span> pv_set_ruri<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span> pv_param_t <span class="sy0">*</span>param<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> op<span class="sy0">,</span> pv_value_t <span class="sy0">*</span>val<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>msg<span class="sy0">==</span>NULL <span class="sy0">||</span> param<span class="sy0">==</span>NULL <span class="sy0">||</span> val<span class="sy0">==</span>NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;bad parameters<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* type checking, we can only push strings to R-URI */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">!</span><span class="br0">&#40;</span>val<span class="sy0">-&gt;</span>flags<span class="sy0">&amp;</span>PV_VAL_STR<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;str value required to set R-URI<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* populate the message R-URI with the string value from the provided val */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>set_ruri<span class="br0">&#40;</span> msg<span class="sy0">,</span> <span class="sy0">&amp;</span>val<span class="sy0">-&gt;</span>rs<span class="br0">&#41;</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;failed to set RURI<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
error<span class="sy0">:</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

</p>
<div class='vspace'></div><h4><a name='toc18' id='toc18'></a>7.&nbsp; Adding Transformations</h4>
<p>The so called transformations are methods operating directly on the OpenSIPS various pseudo-variables. A transformation takes as input the value of the provided pseudo-variable and processes it, outputing a 'transformed' version. 
<br />Transformation examples are the URI transformations ( working on a SIP URI, and they allow extracting various useful information from the URI, like the user , domain, various parameters, etc ), the S class of transformations ( work on generic strings, and provide various useful methods as fetching the length of the string, searching the first occurrence of a character inside the string, etc ), and many others – see <a class='urllink' href="Script-Tran-1-10.htm" tppabs="http://www.opensips.org/Documentation/Script-Tran-1-10" rel='nofollow'>http://www.opensips.org/Documentation/Script-Tran-1-10</a>
<br />
<div class='sourceblock ' id='sourceblock32'>
  <div class='sourceblocktext'><div class="c"><span class="co2"># example of usage</span><br />
$var<span class="br0">&#40;</span>tutorial<span class="br0">&#41;</span> &nbsp;<span class="sy0">=</span> “OpenSIPSDevel”<span class="sy0">;</span><br />
xlog<span class="br0">&#40;</span>“Our variable has $<span class="br0">&#40;</span>var<span class="br0">&#40;</span>tutorial<span class="br0">&#41;</span><span class="br0">&#123;</span>s.<span class="me1">len</span><span class="br0">&#125;</span><span class="br0">&#41;</span> characters \n”<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<br />
</p><div class='round lrindent tip' > 
<p>Note that transformations can be chained together, which will have an impact on the transformations C development
</p></div>
<p class='vspace'><br />
<div class='sourceblock ' id='sourceblock33'>
  <div class='sourceblocktext'><div class="c">$var<span class="br0">&#40;</span>our_uri<span class="br0">&#41;</span> <span class="sy0">=</span> “sip<span class="sy0">:</span>vlad@opensips.<span class="me1">org</span>”<span class="sy0">;</span><br />
xlog<span class="br0">&#40;</span>“The username of our URI has $<span class="br0">&#40;</span>var<span class="br0">&#40;</span>our_uri<span class="br0">&#41;</span><span class="br0">&#123;</span>uri.<span class="me1">user</span><span class="br0">&#125;</span><span class="br0">&#123;</span>s.<span class="me1">len</span><span class="br0">&#125;</span><span class="br0">&#41;</span> characters \n”<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<br />In our examples, <strong>uri</strong> and <strong>s</strong> are the so called <strong>classes of transformations</strong>, while <strong>user</strong> and <strong>len</strong> are the actual operations within the class.
<br />We will further follow the implementation of the uri class of transformation, and then focusing on the user function.<br />Adding new classes of transformations is done in <strong>transformations.h</strong> , where , for our example's case, <strong>TR_URI</strong> was added. Then, each class of transformations should have it's own functions enumeration, which is our case is enum <strong>_tr_uri_subtype</strong> . <br /><strong>transformations.c</strong> holds the actual implementation of transformations. <strong>parse_transformation</strong> will get called when the script needs to evaluate a transformation. There, we should add the matching for our new class of transformations :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock34'>
  <div class='sourceblocktext'><div class="c"><span class="kw1">else</span> <span class="kw1">if</span><span class="br0">&#40;</span>tclass.<span class="me1">len</span><span class="sy0">==</span><span class="nu0">3</span> <span class="sy0">&amp;&amp;</span> strncasecmp<span class="br0">&#40;</span>tclass.<span class="me1">s</span><span class="sy0">,</span> <span class="st0">&quot;uri&quot;</span><span class="sy0">,</span> <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; t<span class="sy0">-&gt;</span>type <span class="sy0">=</span> TR_URI<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; t<span class="sy0">-&gt;</span>trf <span class="sy0">=</span> tr_eval_uri<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; s.<span class="me1">s</span> <span class="sy0">=</span> p<span class="sy0">;</span> s.<span class="me1">len</span> <span class="sy0">=</span> in<span class="sy0">-&gt;</span>s <span class="sy0">+</span> in<span class="sy0">-&gt;</span>len <span class="sy0">-</span> p<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; p0 <span class="sy0">=</span> tr_parse_uri<span class="br0">&#40;</span><span class="sy0">&amp;</span>s<span class="sy0">,</span> t<span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>p0<span class="sy0">==</span>NULL<span class="br0">&#41;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; p <span class="sy0">=</span> p0<span class="sy0">;</span> <br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Here, there are two main functions of interest. First, there is the <strong>tr_parse_uri</strong> function responsible for matching the actual function that needs to get executed inside our class of transformation, doing whatever parsing that is necessary for the transformation and advancing the position of the current pointer in the transformation string. This is a fixup type function and is only evaluated once :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock35'>
  <div class='sourceblocktext'><div class="c">p <span class="sy0">=</span> in<span class="sy0">-&gt;</span>s<span class="sy0">;</span><br />
name.<span class="me1">s</span> <span class="sy0">=</span> in<span class="sy0">-&gt;</span>s<span class="sy0">;</span><br />
<br />
<span class="coMULTI">/* find next token */</span><br />
<span class="kw1">while</span><span class="br0">&#40;</span><span class="sy0">*</span>p <span class="sy0">&amp;&amp;</span> <span class="sy0">*</span>p<span class="sy0">!=</span>TR_PARAM_MARKER <span class="sy0">&amp;&amp;</span> <span class="sy0">*</span>p<span class="sy0">!=</span>TR_RBRACKET<span class="br0">&#41;</span> p<span class="sy0">++;</span><br />
<span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">*</span>p<span class="sy0">==</span><span class="st0">'<span class="es5">\0</span>'</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;invalid transformation: %.*s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> in<span class="sy0">-&gt;</span>len<span class="sy0">,</span> in<span class="sy0">-&gt;</span>s<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
name.<span class="me1">len</span> <span class="sy0">=</span> p <span class="sy0">-</span> name.<span class="me1">s</span><span class="sy0">;</span><br />
trim<span class="br0">&#40;</span><span class="sy0">&amp;</span>name<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="kw1">if</span><span class="br0">&#40;</span>name.<span class="me1">len</span><span class="sy0">==</span><span class="nu0">4</span> <span class="sy0">&amp;&amp;</span> strncasecmp<span class="br0">&#40;</span>name.<span class="me1">s</span><span class="sy0">,</span> <span class="st0">&quot;user&quot;</span><span class="sy0">,</span> <span class="nu0">4</span><span class="br0">&#41;</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; t<span class="sy0">-&gt;</span>subtype <span class="sy0">=</span> TR_URI_USER<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> p<span class="sy0">;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />After we've decided what actually needs to be done and did all the parsing,the  <strong>tr_eval_uri</strong> will be the one gets called at runtime and that actually evaluates our transformation and returns the new transformation output. <br />In our case, the function parses the provided string into a SIP URI, and then populates the output pv_value_t accordingly to the subtype provided :
</p>
<div class='sourceblock ' id='sourceblock36'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* make a PKG copy of the input */</span><br />
_tr_uri.<span class="me1">s</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">char</span><span class="sy0">*</span><span class="br0">&#41;</span>pkg_malloc<span class="br0">&#40;</span><span class="br0">&#40;</span>val<span class="sy0">-&gt;</span>rs.<span class="me1">len</span><span class="sy0">+</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">*</span><span class="kw4">sizeof</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="kw3">memcpy</span><span class="br0">&#40;</span>_tr_uri.<span class="me1">s</span><span class="sy0">,</span> val<span class="sy0">-&gt;</span>rs.<span class="me1">s</span><span class="sy0">,</span> val<span class="sy0">-&gt;</span>rs.<span class="me1">len</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
_tr_uri.<span class="me1">s</span><span class="br0">&#91;</span>_tr_uri.<span class="me1">len</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="sy0">;</span><br />
...<br />
...<br />
<span class="coMULTI">/* parse the input URI */</span><br />
<span class="kw1">if</span><span class="br0">&#40;</span>parse_uri<span class="br0">&#40;</span>_tr_uri.<span class="me1">s</span><span class="sy0">,</span> _tr_uri.<span class="me1">len</span><span class="sy0">,</span> <span class="sy0">&amp;</span>_tr_parsed_uri<span class="br0">&#41;</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;invalid uri [%.*s]<span class="es1">\n</span>&quot;</span><span class="sy0">,</span> val<span class="sy0">-&gt;</span>rs.<span class="me1">len</span><span class="sy0">,</span>val<span class="sy0">-&gt;</span>rs.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
...<br />
...<br />
<span class="coMULTI">/* zero out the output val */</span><br />
<span class="kw3">memset</span><span class="br0">&#40;</span>val<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">&#40;</span>pv_value_t<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="coMULTI">/* the output pvar will be a string */</span><br />
val<span class="sy0">-&gt;</span>flags <span class="sy0">=</span> PV_VAL_STR<span class="sy0">;</span><br />
<br />
<span class="kw1">switch</span><span class="br0">&#40;</span>subtype<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">case</span> TR_URI_USER<span class="sy0">:</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val<span class="sy0">-&gt;</span>rs <span class="sy0">=</span> <span class="br0">&#40;</span>_tr_parsed_uri.<span class="me1">user</span>.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">?</span>_tr_parsed_uri.<span class="me1">user</span><span class="sy0">:</span>_tr_empty<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw2">break</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<h4><a name='toc19' id='toc19'></a>8.&nbsp; Locking API</h4>
<p>OpenSIPS has it's own locking API, and it is recommended to use it instead of the system exposed locks, since they offer greater flexibility - depending on the usage case and the menuconfig provided compilation flags, the OpenSIPS generic locks can be converted either to busy locks, futexes, SysV locks, etc. 
<br />The Locking API offers two distinct functionalities, one for using single lock elements, and another for operating on entire sets of locks.
</p>
<div class='vspace'></div><h5><a name='toc20' id='toc20'></a>8.1&nbsp; Single Lock API</h5>
<p>The API can be used by including “locking.h” . The OpenSIPS generic lock is defined by the gen_lock_t structure. <br />Allocating a new lock is done by calling lock_alloc :
</p>
<div class='sourceblock ' id='sourceblock37'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* <br />
Returns : <br />
&nbsp; &nbsp; &nbsp; A shared memory allocated lock, or NULL in case of an error.<br />
*/</span><br />
gen_lock_t <span class="sy0">*</span>lock_alloc<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Since  the locks usually have to be reachable by all processes fighting on some resource, the locks are allocated by default in shared memory. Also, note that it is not necessary to always allocate the lock separately - if the lock is embedded within a structure which is allocated in SHM, the effect is the same. <br />Before any operation on the lock, it must be initialized :
</p>
<div class='sourceblock ' id='sourceblock38'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock instance to be initialized<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; The initialized lock in case of success, or NULL in case of error.<br />
*/</span><br />
gen_lock_t<span class="sy0">*</span> lock_init<span class="br0">&#40;</span>gen_lock_t<span class="sy0">*</span> lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />In order to acquire a lock, one must use the lock_get function :
</p>
<div class='sourceblock ' id='sourceblock39'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be acquired<br />
*/</span><br />
<span class="kw4">void</span> lock_get<span class="br0">&#40;</span>gen_lock_t <span class="sy0">*</span>lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The function will block if the lock is acquired by another process, and will only return once the lock has been acquired by the current process.
<br />For releasing a lock, lock_release should be used :
</p>
<div class='sourceblock ' id='sourceblock40'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be released.<br />
*/</span><br />
<span class="kw4">void</span> lock_release<span class="br0">&#40;</span>gen_lock_t <span class="sy0">*</span>lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Once a lock is no longer needed, one must first destroy the lock, and then the lock can be safely deallocated.
</p>
<div class='sourceblock ' id='sourceblock41'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be destroyed<br />
*/</span><br />
<span class="kw4">void</span> lock_destroy<span class="br0">&#40;</span>gen_lock_t <span class="sy0">*</span>lock<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be deallocated<br />
*/</span><br />
<span class="kw4">void</span> lock_dealloc<span class="br0">&#40;</span>gen_lock_t <span class="sy0">*</span>lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Here is a code snippet showing the typical code used when dealing with single lock instances :
</p>
<div class='sourceblock ' id='sourceblock42'>
  <div class='sourceblocktext'><div class="c"><br />
gen_lock_t <span class="sy0">*</span>my_lock<span class="sy0">;</span><br />
<br />
<span class="kw4">int</span> init_function<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; my_lock <span class="sy0">=</span> lock_alloc<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>my_lock <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“Failed to allocate lock \n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>lock_init<span class="br0">&#40;</span>my_lock<span class="br0">&#41;</span> <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“Failed to init lock \n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
<br />
<br />
<span class="kw4">int</span> do_work<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <br />
<span class="br0">&#123;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_get<span class="br0">&#40;</span>my_lock<span class="br0">&#41;</span><br />
<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* critical region protected by our lock<br />
&nbsp; &nbsp; &nbsp; &nbsp; generally recommended to keep critical regions short<br />
&nbsp; &nbsp; &nbsp; &nbsp; I/O operations to be avoided in such critical regions */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_release<span class="br0">&#40;</span>my_lock<span class="br0">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw4">void</span> destroy_function<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_destroy<span class="br0">&#40;</span>my_lock<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_dealloc<span class="br0">&#40;</span>my_lock<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc21' id='toc21'></a>8.2&nbsp; Lock Set API</h5>
<p>Operating on an entire array of locks can become very useful when dealing with structures like hashes, where you would need a lock per each hash entry.<br />The API can be used by including <strong>locking.h</strong> . The OpenSIPS generic array of locks is defined by the gen_lock_set_t structure, and working with it is very similar in concept to operating a single lock entry.
<br />Allocating a new lock set is done by calling lock_set_alloc :
</p>
<div class='sourceblock ' id='sourceblock43'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* <br />
Returns : <br />
&nbsp; &nbsp; &nbsp; A shared memory allocated lock set, or NULL in case of an error.<br />
*/</span><br />
gen_lock_set_t <span class="sy0">*</span>lock_set_alloc<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Since  the locks usually have to be reachable by all processes fighting on some resource, the locks are allocated by default in shared memory. Also, note that it is not necessary to always allocate the lock set separately - if the lock set is embedded within a structure which is allocated in SHM, the effect is the same. <br />Before any operation on the lock set, it must be initialized :
</p>
<div class='sourceblock ' id='sourceblock44'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock set instance to be initialized<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; The initialized lock in case of success, or NULL in case of error.<br />
*/</span><br />
gen_lock_set_t<span class="sy0">*</span> lock_set_init<span class="br0">&#40;</span>gen_lock_set_t<span class="sy0">*</span> lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />In order to acquire a lock in a lock set, one must use the lock_set_get function :
</p>
<div class='sourceblock ' id='sourceblock45'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be acquired<br />
&nbsp; &nbsp; &nbsp; entry - the entry in the lock set that needs to be acquired<br />
*/</span><br />
<span class="kw4">void</span> lock_set_get<span class="br0">&#40;</span>gen_lock_set_t <span class="sy0">*</span>lock<span class="sy0">,</span><span class="kw4">int</span> entry<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The function will block if the lock is acquired by another process, and will only return once the lock has been acquired by the current process.
<br />For releasing a lock, lock_set_release should be used :
</p>
<div class='sourceblock ' id='sourceblock46'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be released.<br />
&nbsp; &nbsp; &nbsp; entry - the entry in the lock set that needs to be released<br />
*/</span><br />
<span class="kw4">void</span> lock_set_release<span class="br0">&#40;</span>gen_lock_set_t <span class="sy0">*</span>lock<span class="sy0">,</span><span class="kw4">int</span> entry<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Once a lock set is no longer needed, one must first destroy the lock set, and then the lock set can be safely deallocated.
</p>
<div class='sourceblock ' id='sourceblock47'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock set to be destroyed<br />
*/</span><br />
<span class="kw4">void</span> lock_set_destroy<span class="br0">&#40;</span>gen_lock_set_t <span class="sy0">*</span>lock<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock set to be deallocated<br />
*/</span><br />
<span class="kw4">void</span> lock_set_dealloc<span class="br0">&#40;</span>gen_lock_set_t <span class="sy0">*</span>lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Here is a code snippet showing the typical code used when dealing with single lock instances :
</p>
<div class='sourceblock ' id='sourceblock48'>
  <div class='sourceblocktext'><div class="c">gen_lock_set_t <span class="sy0">*</span>my_lock<span class="sy0">;</span><br />
<br />
<span class="kw4">int</span> init_function<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* allocate lock set with 32 entries */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; my_lock <span class="sy0">=</span> lock_set_alloc<span class="br0">&#40;</span><span class="nu0">32</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>my_lock <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“Failed to allocate lock set \n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>lock_set_init<span class="br0">&#40;</span>my_lock<span class="br0">&#41;</span> <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span>“Failed to init lock set \n”<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw4">int</span> do_work<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <br />
<span class="br0">&#123;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* acquire entry 5 in the lock set */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_set_get<span class="br0">&#40;</span>my_lock<span class="sy0">,</span><span class="nu0">5</span><span class="br0">&#41;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* also acquire entry 21 in the lock set */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_set_get<span class="br0">&#40;</span>my_lock<span class="sy0">,</span><span class="nu0">21</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* critical region protected by our lock<br />
&nbsp; &nbsp; &nbsp; &nbsp; generally recommended to keep critical regions short<br />
&nbsp; &nbsp; &nbsp; &nbsp; I/O operations to be avoided in such critical regions */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_set_release<span class="br0">&#40;</span>my_lock<span class="sy0">,</span><span class="nu0">21</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_set_release<span class="br0">&#40;</span>my_lock<span class="sy0">,</span><span class="nu0">5</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw4">void</span> destroy_function<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_set_destroy<span class="br0">&#40;</span>my_lock<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; lock_set_dealloc<span class="br0">&#40;</span>my_lock<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* … */</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc22' id='toc22'></a>8.3&nbsp; Readers-Writers Locking API</h5>
<p>A readers-writer lock is like a mutex, in that it controls access to a shared resource, allowing concurrent access to multiple threads for reading but restricting access to a single thread for writes (or other changes) to the resource. <br />This can prove very useful when having an use case where all the OpenSIPS processes need read-only access to a resource, but you need to have an MI command to reload that resource ( eg. from a database ). In such scenarios, using a readers-writers lock can improve performance by a considerable margin. <br />The API can be used by including “rw_locking.h” . The OpenSIPS generic lock is defined by the <strong>rw_lock_t</strong> structure. 
</p>
<p class='vspace'>Allocating a new readers-writers lock into shared memory and initializing it is done by calling lock_init_rw :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock49'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; A shared memory allocated rw lock, or NULL in case of an error.<br />
*/</span><br />
<span class="kw2">inline</span> <span class="kw4">static</span> rw_lock_t <span class="sy0">*</span> lock_init_rw<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />In order to acquire the lock for reading purpose, one should use lock_start_read :
</p>
<div class='sourceblock ' id='sourceblock50'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be acquired<br />
*/</span><br />
<span class="kw4">void</span> lock_start_read<span class="br0">&#40;</span>rw_lock_t <span class="sy0">*</span> lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />In case there is currently a write access ongoing, the lock will block until the write is done. Otherwise, the lock will be acquired immediately. <br />After the read is finished, you must call lock_stop_read :
</p>
<div class='sourceblock ' id='sourceblock51'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be released<br />
*/</span><br />
<span class="kw4">void</span> lock_stop_read<span class="br0">&#40;</span>rw_lock_t <span class="sy0">*</span> lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />For requesting a write access, you can use lock_start_write :
</p>
<div class='sourceblock ' id='sourceblock52'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be acquired<br />
*/</span><br />
<span class="kw4">void</span> lock_start_write<span class="br0">&#40;</span>rw_lock_t <span class="sy0">*</span> lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />In case there are other ongoing writes, the op will block until the other writes complete. Otherwise, the lock will block until all the existing readers finish reading. <br />After the write operation is finished, call lock_stop_write :
</p>
<div class='sourceblock ' id='sourceblock53'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be release<br />
*/</span><br />
<span class="kw4">void</span> lock_stop_write<span class="br0">&#40;</span>rw_lock_t <span class="sy0">*</span> lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Upon calling the above function, readers will again be allowed in the critical section. <br />For destroying and deallocating a rw lock, use lock_destroy_rw :
</p>
<div class='sourceblock ' id='sourceblock54'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; lock - the lock to be destroyed<br />
*/</span><br />
<span class="kw4">void</span> lock_destroy_rw<span class="br0">&#40;</span>rw_lock_t <span class="sy0">*</span> lock<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h4><a name='toc23' id='toc23'></a>9.&nbsp; Timer API</h4>
<p>OpenSIPS exposes it's own API for implementing timer functions, with seconds and microsecond precision.<br />The OpenSIPS timer architecture is made out of the so called 'timer keeper' , which is a process which just increments global counter of second and microsecond precision, and one process which will execute the various timer functions when their time to execute has arrived.<br />Also, the OpenSIPS timers support automatic re-calibration in order to compensate timer drifting in case the timer executed functions do not complete in timely manners.
</p>
<div class='vspace'></div><h5><a name='toc24' id='toc24'></a>9.1&nbsp; Global Timer Process</h5>
<p><strong>timer.h</strong> exposes all the relevant functionalities for operating the OpenSIPS timers. For registering a new timer function with second precision, use :
</p>
<div class='sourceblock ' id='sourceblock55'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; label – opaque string containing a short timer function description ( to be used for logging )<br />
&nbsp; &nbsp; &nbsp; &nbsp; f – the actual function to be called<br />
&nbsp; &nbsp; &nbsp; &nbsp; param – parameter to be provided to the timer function<br />
&nbsp; &nbsp; &nbsp; &nbsp; interval – the interval, in seconds, that the function needs to be called at<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; &nbsp; 0 in case of success, negative code in case of internal error.<br />
*/</span><br />
<span class="kw4">int</span> register_timer<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span>label<span class="sy0">,</span> timer_function f<span class="sy0">,</span> <span class="kw4">void</span><span class="sy0">*</span> param<span class="sy0">,</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> interval<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="coMULTI">/*<br />
The seconds callback <br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; ticks - represents the current number of seconds since OpenSIPS startup when the callback is called at<br />
&nbsp; &nbsp; &nbsp; param - is the parameter provided at timer function registration.<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span>timer_function<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">unsigned</span> <span class="kw4">int</span> ticks<span class="sy0">,</span> <span class="kw4">void</span><span class="sy0">*</span> param<span class="br0">&#41;</span><span class="sy0">;</span> </div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />For registering a microsecond timer, you should use 
</p>
<div class='sourceblock ' id='sourceblock56'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; label – opaque string containing a short timer function description ( to be used for logging )<br />
&nbsp; &nbsp; &nbsp; &nbsp; f – the actual function to be called<br />
&nbsp; &nbsp; &nbsp; &nbsp; param – parameter to be provided to the timer function<br />
&nbsp; &nbsp; &nbsp; &nbsp; interval – the interval, in microseconds, that the function needs to be called at<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; &nbsp; 0 in case of success, negative code in case of internal error.<br />
*/</span><br />
<span class="kw4">int</span> register_utimer<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span>label<span class="sy0">,</span> utimer_function f<span class="sy0">,</span> <span class="kw4">void</span><span class="sy0">*</span> param<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> interval<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc25' id='toc25'></a>9.2&nbsp; Dedicated Timer Process</h5>
<p>Since, by default, all the registered timer functions are called from within the same process context, in case you are writing a timer process that is doing I/O, it is better to register an entirely new process where to run your code, since your function might slow down all the other timer functions running in OpenSIPS.<br />Registering a new timer process can be done by calling :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock57'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; label - opaque string containing a short timer function description ( to be used for logging )<br />
&nbsp; &nbsp; &nbsp; f - the actual function to be called<br />
&nbsp; &nbsp; &nbsp; param - parameter to be provided to the timer function<br />
&nbsp; &nbsp; &nbsp; interval - the interval, in seconds, that the function needs to be called at<br />
&nbsp; &nbsp; &nbsp; flags - flags controlling process behavior. Currently only option is TIMER_PROC_INIT_FLAG , which leads to child_init to be called in the new timer process context. To be used when inside the timer you need to operate various I/O options which generally require a per process connection.<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; struct sr_timer_process pointer in case of success, or NULL in case of error.<br />
*/</span><br />
<span class="kw4">void</span><span class="sy0">*</span> register_timer_process<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span>label<span class="sy0">,</span> timer_function f<span class="sy0">,</span> <span class="kw4">void</span><span class="sy0">*</span> param<span class="sy0">,</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> interval<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The output struct sr_timer_process pointer can be further use to group together multiple functions inside the same process, by calling :
</p>
<div class='sourceblock ' id='sourceblock58'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters:<br />
&nbsp; &nbsp; &nbsp; label – opaque string containing a short timer function description ( to be used for logging )<br />
&nbsp; &nbsp; &nbsp; f – the actual function to be called<br />
&nbsp; &nbsp; &nbsp; param – parameter to be provided to the timer function<br />
&nbsp; &nbsp; &nbsp; interval – the interval, in seconds, that the function needs to be called at<br />
&nbsp; &nbsp; &nbsp; timer – the &nbsp;struct sr_timer_process pointer obtained by previously calling &nbsp;register_timer_process<br />
Returns:<br />
&nbsp; &nbsp; &nbsp; 0 in case of success, negative code in case of internal error.<br />
*/</span><br />
<span class="kw4">int</span> append_timer_to_process<span class="br0">&#40;</span> <span class="kw4">char</span> <span class="sy0">*</span>label<span class="sy0">,</span> timer_function f<span class="sy0">,</span> <span class="kw4">void</span><span class="sy0">*</span> param<span class="sy0">,</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> interval<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>timer<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent important' > 
<p>Important to note here that all the above timer related functions MUST be called in the context of the attendant process before forking is done ( so either from the modules mod_init or directly from the core, before forking ).
</p></div>
<p class='vspace'>Below is a code snippet exemplifying how the dialog module's code used for registering two timers, with an option to either use the global timer process or to have it's own separate timer :
</p>
<div class='sourceblock ' id='sourceblock59'>
  <div class='sourceblocktext'><div class="c"><span class="kw1">if</span> <span class="br0">&#40;</span>dlg_have_own_timer_proc<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; LM_INFO<span class="br0">&#40;</span><span class="st0">&quot;Running with dedicated dialog timer process<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; dlg_own_timer_proc <span class="sy0">=</span> register_timer_process<span class="br0">&#40;</span> <span class="st0">&quot;dlg-timer&quot;</span><span class="sy0">,</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlg_timer_routine<span class="sy0">,</span> NULL<span class="sy0">,</span><span class="nu0">1</span><span class="sy0">,</span>TIMER_PROC_INIT_FLAG <span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>dlg_own_timer_proc <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to init dialog own timer proc<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>append_timer_to_process<span class="br0">&#40;</span><span class="st0">&quot;dlg-pinger&quot;</span><span class="sy0">,</span> dlg_ping_routine<span class="sy0">,</span> NULL<span class="sy0">,</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ping_interval<span class="sy0">,</span>dlg_own_timer_proc<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to append ping timer <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> register_timer<span class="br0">&#40;</span> <span class="st0">&quot;dlg-timer&quot;</span><span class="sy0">,</span> dlg_timer_routine<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;failed to register timer <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> register_timer<span class="br0">&#40;</span> <span class="st0">&quot;dlg-pinger&quot;</span><span class="sy0">,</span> dlg_ping_routine<span class="sy0">,</span> NULL<span class="sy0">,</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ping_interval<span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;failed to register timer 2 <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <br />
<span class="br0">&#125;</span> </div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Also, the OpenSIPS API also exposes the number of seconds and microseconds passed from the OpenSIPS start time. These can be accessed by calling 
</p>
<div class='sourceblock ' id='sourceblock60'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; the number of seconds elapsed from OpenSIPS start<br />
*/</span><br />
<span class="kw4">unsigned</span> <span class="kw4">int</span> get_ticks<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/*<br />
Returns:<br />
&nbsp; &nbsp; &nbsp; the number of microseconds elapsed from OpenSIPS start<br />
*/</span><br />
utime_t get_uticks<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h4><a name='toc26' id='toc26'></a>10.&nbsp; Management Interface API</h4>
<p>The Management Interface is the abstract layer that is commonly used to control and monitor OpenSIPS. The MI Interface supports multiple actual back-ends ( eg. FIFO, Datagram, XMLRPC, HTTP GET JSON, etc ) - due to the modularity of the interface and also due to the clear separation between the  logic and the transport layer, the developer just defines the functions to be externally called, and then it is up to the OpenSIPS script writer to chose what transport he will actually use for controlling OpenSIPS.
<br />The MI interface heavily uses trees :
</p><ul><li>the Interface will provide as input a tree with the parameters provided by the user
</li><li>an MI function has to also return a tree, which will then be converted by the transport module to it's specific representation
</li></ul><p><br />Further on we will focus on the core MI functions, with a specific focus on the <strong>debug</strong> function. Note that modules can ( an commonly ) also export MI functions - see the Modules Development MI functions topic for more information on that.
<br />The structures commonly used for exporting MI functions are found in <strong>mi/mi.h</strong> :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock61'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">typedef</span> <span class="kw4">struct</span> mi_export_ <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* the name of the function ( users will call this from their transport of choice */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* short description of the usage of this function */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>help<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* actual function that will get called */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; mi_cmd_f <span class="sy0">*</span>cmd<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* flags for this function. Currently options are :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- MI_ASYNC_RPL_FLAG - the function has an asynchronous behaviour ( eg: MI functions that send SIP messages and wait for their reply )<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- MI_NO_INPUT_FLAG - the function does not receive any parameters <br />
&nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> flags<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* parameter that will be passed when the cmd function gets called */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">void</span> <span class="sy0">*</span>param<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* the initialization function to be called by OpenSIPS ( one time ) */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; mi_child_init_f <span class="sy0">*</span>init_f<span class="sy0">;</span><br />
<span class="br0">&#125;</span>mi_export_t<span class="sy0">;</span><br />
<br />
<span class="coMULTI">/* Example of core MI exported function */</span><br />
<span class="kw4">static</span> mi_export_t mi_core_cmds<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span> <span class="st0">&quot;uptime&quot;</span><span class="sy0">,</span> <span class="st0">&quot;prints various time information about OpenSIPS - &quot;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="st0">&quot;when it started to run, for how long it runs&quot;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mi_uptime<span class="sy0">,</span> &nbsp; &nbsp; MI_NO_INPUT_FLAG<span class="sy0">,</span> &nbsp;<span class="nu0">0</span><span class="sy0">,</span> &nbsp;init_mi_uptime <span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span> <span class="st0">&quot;version&quot;</span><span class="sy0">,</span> <span class="st0">&quot;prints the version string of a runningOpenSIPS&quot;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mi_version<span class="sy0">,</span> &nbsp; &nbsp;MI_NO_INPUT_FLAG<span class="sy0">,</span> &nbsp;<span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="nu0">0</span> <span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span> <span class="st0">&quot;pwd&quot;</span><span class="sy0">,</span> <span class="st0">&quot;prints the working directory of OpenSIPS&quot;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mi_pwd<span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp;MI_NO_INPUT_FLAG<span class="sy0">,</span> &nbsp;<span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="nu0">0</span> <span class="br0">&#125;</span><span class="sy0">,</span><br />
...<br />
...<br />
...<br />
<span class="coMULTI">/* For exporting the populated array of MI functions<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; mod_name : the name of the module exporting these functions<br />
&nbsp; &nbsp; &nbsp; mis : the array of exported MI functions<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 on success, negative in case of error<br />
*/</span><br />
<span class="kw4">int</span> register_mi_mod<span class="br0">&#40;</span> <span class="kw4">char</span> <span class="sy0">*</span>mod_name<span class="sy0">,</span> mi_export_t <span class="sy0">*</span>mis<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/* Example of usage */</span><br />
<span class="kw1">if</span> <span class="br0">&#40;</span>register_mi_mod<span class="br0">&#40;</span> <span class="st0">&quot;core&quot;</span><span class="sy0">,</span> mi_core_cmds<span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;unable to register core MI cmds<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span> &nbsp;<br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The structures commonly used for implementing MI functions are also found in <strong>mi/mi.h</strong> :
</p>
<div class='sourceblock ' id='sourceblock62'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; input : the tree that contains the command paramenters<br />
&nbsp; &nbsp; &nbsp; param : the parameter provided at function registration<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; A mi_root tree containing the function reply<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">struct</span> mi_root<span class="sy0">*</span> <span class="br0">&#40;</span>mi_cmd_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> mi_root <span class="sy0">*</span>input<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>param<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/* below are the used structures for representing the tree root and the tree nodes */</span><br />
<span class="kw4">struct</span> mi_root <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* int code - similar to SIP or HTTP code */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> &nbsp; &nbsp; &nbsp; code<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* string reason for code - similar to SIP or HTTP reason */</span><br />
&nbsp; &nbsp; &nbsp; str &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reason<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* handler in case of asynchronous MI commands */</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_handler &nbsp;<span class="sy0">*</span>async_hdl<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* the actual root node in our tree */</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_node &nbsp; &nbsp; node<span class="sy0">;</span> <br />
<span class="br0">&#125;</span><span class="sy0">;</span><br />
<br />
<span class="kw4">struct</span> mi_node <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; str value<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; str name<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> flags<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_node <span class="sy0">*</span>kids<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_node <span class="sy0">*</span>next<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_node <span class="sy0">*</span>last<span class="sy0">;</span> <br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_attr <span class="sy0">*</span>attributes<span class="sy0">;</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span> &nbsp; &nbsp; &nbsp;<br />
<br />
<span class="kw4">struct</span> mi_attr<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str name<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str value<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_attr <span class="sy0">*</span>next<span class="sy0">;</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />As can be noted from the above tree definition, a node has a name and a value associated to it,it can have one or multiple children ( stored in kids pointer ), and also it can have a list of key-value attributes associated to it.
<br />For building the output MI tree, <strong>mi/tree.h</strong> and <strong>mi/attr.h</strong> expose the following functions :
</p>
<div class='sourceblock ' id='sourceblock63'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* Use for creating a new output reply tree<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; code : success code for this tree ( &gt;=200&lt;300 for success, anything else for errors )<br />
&nbsp; &nbsp; &nbsp; reason : string reasons representation for the code<br />
&nbsp; &nbsp; &nbsp; reason_len : length of the reason parameter<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; A new mi_root tree, or NULL in case of error. Note that this function will allocate the node in PKG and it typically has to be returned - the freeing will be done in the MI core, after the output tree is written by the transport module */</span><br />
<span class="kw4">struct</span> mi_root <span class="sy0">*</span>init_mi_tree<span class="br0">&#40;</span><span class="kw4">unsigned</span> <span class="kw4">int</span> code<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>reason<span class="sy0">,</span> <span class="kw4">int</span> reason_len<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/* Adding a new child node to our tree - typically first called to mi_root-&gt;node.kids<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; parent : the parent node for our newly added node<br />
&nbsp; &nbsp; &nbsp; flags : Current options are :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MI_DUP_NAME : the name of this node needs to be duplicated in PKG <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MI_DUP_VALUE : the value of the current node needs to be duplicated in PKG<br />
&nbsp; &nbsp; &nbsp; name : the name of the current node<br />
&nbsp; &nbsp; &nbsp; name_len : length of the node's name<br />
&nbsp; &nbsp; &nbsp; value : the value of the current node<br />
&nbsp; &nbsp; &nbsp; value_len : length of the node's value<br />
*/</span><br />
<span class="kw4">struct</span> mi_node <span class="sy0">*</span>add_mi_node_child<span class="br0">&#40;</span><span class="kw4">struct</span> mi_node <span class="sy0">*</span>parent<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> name_len<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>value<span class="sy0">,</span> <span class="kw4">int</span> value_len<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="coMULTI">/* Adding a new sibling node to one of our nodes<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; brother : the brother node for our newly added node<br />
&nbsp; &nbsp; &nbsp; flags : Current options are :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MI_DUP_NAME : the name of this node needs to be duplicated in PKG <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MI_DUP_VALUE : the value of the current node needs to be duplicated in PKG<br />
&nbsp; &nbsp; &nbsp; name : the name of the current node<br />
&nbsp; &nbsp; &nbsp; name_len : length of the node's name<br />
&nbsp; &nbsp; &nbsp; value : the value of the current node<br />
&nbsp; &nbsp; &nbsp; value_len : length of the node's value<br />
*/</span><br />
<span class="kw4">struct</span> mi_node <span class="sy0">*</span>add_mi_node_sibling<span class="br0">&#40;</span><span class="kw4">struct</span> mi_node <span class="sy0">*</span>brother<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> name_len<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>value<span class="sy0">,</span> <span class="kw4">int</span> value_len<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="coMULTI">/* Adding a new attribute to one of our nodes<br />
&nbsp; &nbsp; &nbsp; node : the node we will be adding the key-value attribute to<br />
&nbsp; &nbsp; &nbsp; flags : Current options are :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MI_DUP_NAME : the name of this attribute needs to be duplicated in PKG <br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MI_DUP_VALUE : the value of the current attribute needs to be duplicated in PKG<br />
&nbsp; &nbsp; &nbsp; name : the name of the current attribute<br />
&nbsp; &nbsp; &nbsp; name_len : length of the node's attribute name<br />
&nbsp; &nbsp; &nbsp; value : the value of the current value<br />
&nbsp; &nbsp; &nbsp; value_len : length of the node's attribute value<br />
*/</span><br />
<span class="kw4">struct</span> mi_attr <span class="sy0">*</span>add_mi_attr<span class="br0">&#40;</span><span class="kw4">struct</span> mi_node <span class="sy0">*</span>node<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> <span class="kw4">int</span> name_len<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>value<span class="sy0">,</span> <span class="kw4">int</span> value_len<span class="br0">&#41;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Further on, we will follow the implementation of the <strong>debug</strong> MI function. If called with no parameters, the function will return the current debug level in OpenSIPS. If called with one integer parameter, then the function will set the current debug level to the provided parameter.
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock64'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">struct</span> mi_root <span class="sy0">*</span>mi_debug<span class="br0">&#40;</span><span class="kw4">struct</span> mi_root <span class="sy0">*</span>cmd<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>param<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_root <span class="sy0">*</span>rpl_tree<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> mi_node <span class="sy0">*</span>node<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>p<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">int</span> len<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">int</span> new_debug<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* check the kids member of our root node - <br />
&nbsp; &nbsp; &nbsp; if the input root node has kids, our command was called with parameters */</span><br />
&nbsp; &nbsp; &nbsp; node <span class="sy0">=</span> cmd<span class="sy0">-&gt;</span>node.<span class="me1">kids</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>node<span class="sy0">!=</span>NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* take the node's value and convert it to int, to make sure the parameter is valid */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>str2sint<span class="br0">&#40;</span> <span class="sy0">&amp;</span>node<span class="sy0">-&gt;</span>value<span class="sy0">,</span> <span class="sy0">&amp;</span>new_debug<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* if failed to convert to int, still return a RPL tree with an &gt;=400 code and reason */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> init_mi_tree<span class="br0">&#40;</span> <span class="nu0">400</span><span class="sy0">,</span> MI_SSTR<span class="br0">&#40;</span>MI_BAD_PARM<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_debug <span class="sy0">=</span> <span class="sy0">*</span>debug<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* all is good so far, initialize a new output ROOT tree which has a 200 OK code &amp; reason */</span><br />
&nbsp; &nbsp; &nbsp; rpl_tree <span class="sy0">=</span> init_mi_tree<span class="br0">&#40;</span> <span class="nu0">200</span><span class="sy0">,</span> MI_SSTR<span class="br0">&#40;</span>MI_OK<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>rpl_tree<span class="sy0">==</span><span class="nu0">0</span><span class="br0">&#41;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; p <span class="sy0">=</span> sint2str<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">long</span><span class="br0">&#41;</span>new_debug<span class="sy0">,</span> <span class="sy0">&amp;</span>len<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* add a new node to our output tree, which the current debug level */</span><br />
&nbsp; &nbsp; &nbsp; node <span class="sy0">=</span> add_mi_node_child<span class="br0">&#40;</span> <span class="sy0">&amp;</span>rpl_tree<span class="sy0">-&gt;</span>node<span class="sy0">,</span> MI_DUP_VALUE<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MI_SSTR<span class="br0">&#40;</span><span class="st0">&quot;DEBUG&quot;</span><span class="br0">&#41;</span><span class="sy0">,</span>p<span class="sy0">,</span> len<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>node<span class="sy0">==</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_mi_tree<span class="br0">&#40;</span>rpl_tree<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* if all was successful, overwrite the actual debug level, and return our tree */</span><br />
&nbsp; &nbsp; &nbsp; <span class="sy0">*</span>debug <span class="sy0">=</span> new_debug<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> rpl_tree<span class="sy0">;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent tip' > 
<p>For more generic information on the MI Interface as well as some examples used for running MI commands with the <strong>opensipsctl</strong> utility, see the <a class='urllink' href="Interface-MI-2-2.htm" tppabs="http://www.opensips.org/Documentation/Interface-MI" rel='nofollow'>MI Interface</a> documentation page.
</p></div>
<div class='vspace'></div><h4><a name='toc27' id='toc27'></a>11.&nbsp; Statistics API</h4>
<p>OpenSIPS exposes a statistics API that can be used both from the core or the modules. The statistics are essentially counters that will be internally incremented/decremented by OpenSIPS and that can be fetched by the outside world ( via the MI interface ) for understanding the OpenSIPS load / health status / etc.
<br />The advantages of using the OpenSIPS Statistics API instead of regular counters is :
</p><ul><li>easily fetched from the MI Interface
</li><li>on supported architectures, the statistics do not use an explicit lock ( the consistency is ensured by employing assembly code ), thus you will get better performance
</li></ul><p><br />The most important structures used for extending statistics are exported by <strong>statistics.h</strong> :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock65'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">typedef</span> <span class="kw4">struct</span> stat_export_ <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span><span class="sy0">*</span> name<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* null terminated statistic name */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">short</span> flags<span class="sy0">;</span> &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* flags */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; stat_var<span class="sy0">**</span> stat_pointer<span class="sy0">;</span> &nbsp; <span class="coMULTI">/* pointer to the variable's mem location *<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * NOTE - it's in shm mem */</span><br />
<span class="br0">&#125;</span> stat_export_t<span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />For example, the core stats exported by OpenSIPS are defined in the following array :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock66'>
  <div class='sourceblocktext'><div class="c">stat_var<span class="sy0">*</span> rcv_reqs<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> rcv_rpls<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> fwd_reqs<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> fwd_rpls<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> drp_reqs<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> drp_rpls<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> err_reqs<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> err_rpls<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> bad_URIs<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> unsupported_methods<span class="sy0">;</span><br />
stat_var<span class="sy0">*</span> bad_msg_hdr<span class="sy0">;</span><br />
<br />
stat_export_t core_stats<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;rcv_requests&quot;</span> <span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>rcv_reqs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;rcv_replies&quot;</span> <span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>rcv_rpls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;fwd_requests&quot;</span> <span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>fwd_reqs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;fwd_replies&quot;</span> <span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>fwd_rpls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;drop_requests&quot;</span> <span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>drp_reqs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;drop_replies&quot;</span> <span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>drp_rpls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;err_requests&quot;</span> <span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>err_reqs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;err_replies&quot;</span> <span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>err_rpls &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;bad_URIs_rcvd&quot;</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>bad_URIs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;unsupported_methods&quot;</span><span class="sy0">,</span> &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>unsupported_methods &nbsp; <span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;bad_msg_hdr&quot;</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="sy0">&amp;</span>bad_msg_hdr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;timestamp&quot;</span><span class="sy0">,</span> &nbsp;STAT_IS_FUNC<span class="sy0">,</span> <span class="br0">&#40;</span>stat_var<span class="sy0">**</span><span class="br0">&#41;</span>get_ticks &nbsp; <span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#125;</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent tip' > 
<p>As note from the above structure, statistics can either be a simple counter ( eg. rcv_requests ), but it can also be a function. Statistics function might come in handy when the developer needs to do extra processing on the raw counters before providing the final output.
</p></div>
<p class='vspace'><br />After defining your array of statistics that you want to export, one should use the following for exporting the stats to be accessible by all
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock67'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* <br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; module - a string describing the module the current statistics belong to. Will be used when fetching the statistics via MI<br />
&nbsp; &nbsp; &nbsp; stats - the statistics to be registered<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 in case of success, negative in case of error<br />
*/</span><br />
<span class="kw4">int</span> register_module_stats<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span>module<span class="sy0">,</span> stat_export_t <span class="sy0">*</span>stats<span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Note that <strong>register_module_stats</strong> will export the statistics, and also allocate them in SHM memory, for them to be accessible by all OpenSIPS processes.
<br />
</p><div class='round lrindent important' > 
<p>Important to note here that all the above statistics related functions MUST be called in the context of the attendant process before forking is done.
</p></div>
<p class='vspace'><br />At runtime, the developer has access to the following functions for operating on statistics :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock68'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* <br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; var : the statistics to be updated<br />
&nbsp; &nbsp; &nbsp; n : the value ( if positive -&gt; stat will be increment. negative -&gt; stat will be decremented )<br />
*/</span><br />
<span class="kw4">void</span> update_stat<span class="br0">&#40;</span>stat_var<span class="sy0">*</span> var<span class="sy0">,</span> <span class="kw4">int</span> n<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/* <br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; var : the statistics to be reseted<br />
*/</span><br />
<span class="kw4">void</span> reset_stat<span class="br0">&#40;</span>stat_var<span class="sy0">*</span> var<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/*<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; var : the statistics to be fetched<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; statistic value<br />
*/</span><br />
<span class="kw4">unsigned</span> <span class="kw4">long</span> get_stat_val<span class="br0">&#40;</span>stat_var<span class="sy0">*</span> var<span class="br0">&#41;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><div class='round lrindent important' > 
<p>All statistics related code should be guarded by <strong>#ifdef STATISTICS</strong> , since the statistics are not a mandatory part of the OpenSIPS core ( they can be disabled from within menuconfig ).
</p></div>
<p class='vspace'><br />
</p><div class='round lrindent tip' > 
<p>For fetching the <strong>mynewstat</strong> statistic exported by the <strong>mynewmod</strong> module, one can use the <strong>opensipsctl</strong> like this : <br />opensipsctl fifo get_statistics mynewmod mynewstat <br />For fetching all the statistics exported by the <strong>mynewmod</strong> module, you can use <br />opensipsctl fifo get_statistics mynewmod:
</p></div>
<div class='vspace'></div><h4><a name='toc28' id='toc28'></a>12.&nbsp; SQL Database API</h4>
<p>OpenSIPS exposes a SQL database API that the module developers can use for operating the most common SQL queries. Advantages here are :
</p><ul><li>writing back-end independent code, since the DB API is decoupled from the actual modules implementing the back-end specific code
</li><li>the ability to expose SQL-like capabilities to back-ends who are not internally SQL ( eg. the db_flatstore modules operates directly with flat-text files, yet the developer can insert into the file as if he was inserting into a regular SQL database
</li></ul><p><br /><strong>db/db.h</strong> exposes most of the database related functions. At startup, the developer will have just the database URL where he needs to connect. By calling <strong>db_bind_mod</strong> , the OpenSIPS DB API will try to automatically locate the actual DB module that support that specific back-end, and will return all the needed functions for operating on the back-end.
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock69'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp;* \brief Bind database module functions &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp;* This function is special, it's only purpose is to call find_export function in<br />
&nbsp;* the core and find the addresses of all other database related functions. The<br />
&nbsp;* db_func_t callback given as parameter is updated with the found addresses.<br />
&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;* This function must be called before any other database API call!<br />
&nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;* The database URL is of the form &quot;mysql://username:password@host:port/database&quot; or<br />
&nbsp;* &quot;mysql&quot; (database module name).<br />
&nbsp;* In the case of a database connection URL, this function looks only at the first<br />
&nbsp;* token (the database protocol). In the example above that would be &quot;mysql&quot;:<br />
&nbsp;* \see db_func_t &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp;* \param mod database connection URL or a database module name<br />
&nbsp;* \param dbf database module callbacks to be further used &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
<span class="kw4">int</span> db_bind_mod<span class="br0">&#40;</span><span class="kw4">const</span> str<span class="sy0">*</span> mod<span class="sy0">,</span> db_func_t<span class="sy0">*</span> dbf<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="kw4">typedef</span> <span class="kw4">struct</span> db_func <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cap<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* Capability vector of the database transport */</span><br />
&nbsp; &nbsp; &nbsp; db_use_table_f &nbsp; &nbsp; &nbsp; &nbsp; use_table<span class="sy0">;</span> &nbsp; &nbsp; <span class="coMULTI">/* Specify table name */</span><br />
&nbsp; &nbsp; &nbsp; db_init_f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;init<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* Initialize database connection */</span><br />
&nbsp; &nbsp; &nbsp; db_close_f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* Close database connection */</span><br />
&nbsp; &nbsp; &nbsp; db_query_f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* query a table */</span><br />
&nbsp; &nbsp; &nbsp; db_fetch_result_f &nbsp; &nbsp; &nbsp;fetch_result<span class="sy0">;</span> &nbsp;<span class="coMULTI">/* fetch result */</span><br />
&nbsp; &nbsp; &nbsp; db_raw_query_f &nbsp; &nbsp; &nbsp; &nbsp; raw_query<span class="sy0">;</span> &nbsp; &nbsp; <span class="coMULTI">/* Raw query - SQL */</span><br />
&nbsp; &nbsp; &nbsp; db_free_result_f &nbsp; &nbsp; &nbsp; free_result<span class="sy0">;</span> &nbsp; <span class="coMULTI">/* Free a query result */</span><br />
&nbsp; &nbsp; &nbsp; db_insert_f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;insert<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* Insert into table */</span><br />
&nbsp; &nbsp; &nbsp; db_delete_f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* Delete from table */</span><br />
&nbsp; &nbsp; &nbsp; db_update_f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;update<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* Update table */</span><br />
&nbsp; &nbsp; &nbsp; db_replace_f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* Replace row in a table */</span><br />
&nbsp; &nbsp; &nbsp; db_last_inserted_id_f &nbsp;last_inserted_id<span class="sy0">;</span> &nbsp;<span class="coMULTI">/* Retrieve the last inserted ID<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in a table */</span><br />
&nbsp; &nbsp; &nbsp; db_insert_update_f insert_update<span class="sy0">;</span> &nbsp; &nbsp; <span class="coMULTI">/* Insert into table, update on duplicate key */</span><br />
<span class="br0">&#125;</span> db_func_t<span class="sy0">;</span><br />
<br />
<span class="coMULTI">/* Example of usage below */</span><br />
db_func_t sql_functions<span class="sy0">;</span><br />
db_url <span class="sy0">=</span> str_init<span class="br0">&#40;</span><span class="st0">&quot;mysql://root:vlad@localhost/opensips&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="kw1">if</span> <span class="br0">&#40;</span>db_bind_mod<span class="br0">&#40;</span>db_url<span class="sy0">,</span> <span class="sy0">&amp;</span>sql_functions<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* most likely the db_mysql modules was not loaded, or it was loaded after our module */</span><br />
&nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Unable to bind to a database driver<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
&nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p class='vspace'>After successfully binding to the module, the developer must also make sure that the URL provided from the script writer point of a back-end which also supports the capabilities that will be further used ( eg. when operating on a flat text file, the db_last_inserted_id_f function will not be populated, and thus if the C code calls that function, the module will crash ). This is done by using the <strong>DB_CAPABILITY</strong> macro :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock70'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* Returns true if all the capabilities in cpv are supported by module<br />
&nbsp;* represented by dbf, false otherwise<br />
&nbsp;*/</span><br />
<span class="co2">#define DB_CAPABILITY(dbf, cpv) (((dbf).cap &amp; (cpv)) == (cpv))</span><br />
<br />
<span class="coMULTI">/**<br />
&nbsp;* Represents the capabilities that a database driver supports.<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw2">enum</span> db_cap <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_QUERY <span class="sy0">=</span> &nbsp; &nbsp; <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">0</span><span class="sy0">,</span> &nbsp;<span class="coMULTI">/**&lt; driver can perform queries &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_RAW_QUERY <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">1</span><span class="sy0">,</span> &nbsp;<span class="coMULTI">/**&lt; driver can perform raw queries &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_INSERT <span class="sy0">=</span> &nbsp; &nbsp;<span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">2</span><span class="sy0">,</span> &nbsp;<span class="coMULTI">/**&lt; driver can insert data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_DELETE <span class="sy0">=</span> &nbsp; &nbsp;<span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">3</span><span class="sy0">,</span> &nbsp;<span class="coMULTI">/**&lt; driver can delete data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_UPDATE <span class="sy0">=</span> &nbsp; &nbsp;<span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">4</span><span class="sy0">,</span> &nbsp;<span class="coMULTI">/**&lt; driver can update data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_REPLACE <span class="sy0">=</span> &nbsp; <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">5</span><span class="sy0">,</span> &nbsp;<span class="coMULTI">/**&lt; driver can replace (also known as INSERT OR UPDATE) data &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_FETCH &nbsp; <span class="sy0">=</span> &nbsp; <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">6</span><span class="sy0">,</span> &nbsp;<span class="coMULTI">/**&lt; driver supports fetch result queries &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_LAST_INSERTED_ID <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">7</span><span class="sy0">,</span> &nbsp;<span class="coMULTI">/**&lt; driver can return the ID of the last insert operation &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_INSERT_UPDATE <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">8</span><span class="sy0">,</span> <span class="coMULTI">/**&lt; driver can insert data into database and update on duplicate */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DB_CAP_MULTIPLE_INSERT <span class="sy0">=</span> <span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">9</span> <span class="coMULTI">/**&lt; driver can insert multiple rows at once */</span><br />
<span class="br0">&#125;</span> db_cap_t<span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/**<br />
&nbsp;* All database capabilities except raw_query, replace, insert_update and<br />
&nbsp;* last_inserted_id which should be checked separately when needed<br />
&nbsp;*/</span><br />
<span class="co2">#define DB_CAP_ALL (DB_CAP_QUERY | DB_CAP_INSERT | DB_CAP_DELETE | DB_CAP_UPDATE)</span><br />
<br />
<span class="coMULTI">/* Example of usage below */</span><br />
<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>DB_CAPABILITY<span class="br0">&#40;</span>sql_functions<span class="sy0">,</span> DB_CAP_ALL<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; LM_CRIT<span class="br0">&#40;</span><span class="st0">&quot;Database modules does not &quot;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="st0">&quot;provide all functions needed by our module<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Now that we have binded to the needed module and also made sure it supports our needed capabilities, we can go ahead and connect to the back-end, by invoking the init function from the binded functions :
</p>
<div class='sourceblock ' id='sourceblock71'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Initialize database connection and obtain the connection handle.<br />
&nbsp;*<br />
&nbsp;* This function initialize the database API and open a new database<br />
&nbsp;* connection. This function must be called after db_bind_mod but before any<br />
&nbsp;* other database API function is called.<br />
&nbsp;*<br />
&nbsp;* The function takes one parameter, the parameter must contain the database<br />
&nbsp;* connection URL. The URL is of the form<br />
&nbsp;* mysql://username:password\@host:port/database where:<br />
&nbsp;*<br />
&nbsp;* username: Username to use when logging into database (optional).<br />
&nbsp;* password: password if it was set (optional)<br />
&nbsp;* host: &nbsp; &nbsp; Hosname or IP address of the host where database server lives (mandatory)<br />
&nbsp;* port: &nbsp; &nbsp; Port number of the server if the port differs from default value (optional)<br />
&nbsp;* database: If the database server supports multiple databases, you must specify the<br />
&nbsp;* name of the database (optional).<br />
&nbsp;* \see bind_dbmod<br />
&nbsp;* \param _sqlurl database connection URL<br />
&nbsp;* \return returns a pointer to the db_con_t representing the connection if it was<br />
&nbsp;* successful, otherwise 0 is returned<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> db_con_t<span class="sy0">*</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_init_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> str<span class="sy0">*</span> _sqlurl<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<span class="coMULTI">/* Example of usage below */</span><br />
<span class="kw4">static</span> db_con_t<span class="sy0">*</span> db_connection<span class="sy0">;</span><br />
<br />
<span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>db_connection <span class="sy0">=</span> sql_functions.<span class="me1">init</span><span class="br0">&#40;</span>db_url<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">==</span> NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to connect to the database <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent important' > 
<p>Connection sharing between multiple processes does not work for the majority of back-end specific connectors ( eg. MySQL, Postgres, etc ). Due to this fact, the developers MUST make sure to create a sepparate database connection for each process that will eventually need one - in the context of Module development, the connections need to be opened in the child_init function.
</p></div>
<p class='vspace'>The output of the init() function will be the handler to be further used for all database interactions. When the connection is not needed anymore, the <strong>close</strong> method should be called :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock72'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Close a database connection and free all memory used.<br />
&nbsp;*<br />
&nbsp;* The function closes previously open connection and frees all previously<br />
&nbsp;* allocated memory. The function db_close must be the very last function called.<br />
&nbsp;* \param _h db_con_t structure representing the database connection<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_close_f<span class="br0">&#41;</span> <span class="br0">&#40;</span>db_con_t<span class="sy0">*</span> _h<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Before running any queries on the back-end, common practice dictates that the used tables should be versioned, in order to ensure that the user is not running your code on top of an older database structure.
<br />db/db.h exposes db_check_table_version for this purpose, that checks the <strong>version</strong> table in the default OpenSIPS database structure :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock73'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; dbf - the functions to be used for running the version query<br />
&nbsp; &nbsp; &nbsp; dbh - the connection to run the version query<br />
&nbsp; &nbsp; &nbsp; table - str containing the table name we want to check for version<br />
&nbsp; &nbsp; &nbsp; version - the version we expect to find<br />
Returns :<br />
&nbsp; &nbsp; &nbsp; 0 means table version was successfully validated, negative in case of error ( internal error or older version found )<br />
&nbsp;*/</span><br />
<span class="kw4">int</span> db_check_table_version<span class="br0">&#40;</span>db_func_t<span class="sy0">*</span> dbf<span class="sy0">,</span> db_con_t<span class="sy0">*</span> dbh<span class="sy0">,</span> <span class="kw4">const</span> str<span class="sy0">*</span> table<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> version<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Before running a query through the API, we need to choose the table that the query will run on :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock74'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Specify table name that will be used for subsequent operations.<br />
&nbsp;*<br />
&nbsp;* The function db_use_table takes a table name and stores it db_con_t structure.<br />
&nbsp;* All subsequent operations (insert, delete, update, query) are performed on<br />
&nbsp;* that table.<br />
&nbsp;* \param _h database connection handle<br />
&nbsp;* \param _t table name<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_use_table_f<span class="br0">&#41;</span><span class="br0">&#40;</span>db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> <span class="kw4">const</span> str <span class="sy0">*</span> _t<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent important' > 
<p>All queries must be preceded by a call to the <strong>use_table</strong> function. OpenSIPS internally does connection pooling - in case multiple module request connections to the same database, the connection will be shared between all those modules. Thus, in the context of a process, the same connection might be used by different modules - never assume a connection is dedicated to a single module.
</p></div>
<p class='vspace'>For running a <strong>SELECT</strong> query, you should use the <strong>query</strong> function. Prototype is :
</p>
<div class='sourceblock ' id='sourceblock75'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Query table for specified rows.<br />
&nbsp;*<br />
&nbsp;* This function implements the SELECT SQL directive.<br />
&nbsp;* If _k and _v parameters are NULL and _n is zero, you will get the whole table.<br />
&nbsp;*<br />
&nbsp;* if _c is NULL and _nc is zero, you will get all table columns in the result.<br />
&nbsp;* _r will point to a dynamically allocated structure, it is neccessary to call<br />
&nbsp;* db_free_result function once you are finished with the result.<br />
&nbsp;*<br />
&nbsp;* If _op is 0, equal (=) will be used for all key-value pairs comparisons.<br />
&nbsp;*<br />
&nbsp;* Strings in the result are not duplicated, they will be discarded if you call<br />
&nbsp;* db_free_result, make a copy yourself if you need to keep it after db_free_result.<br />
&nbsp;*<br />
&nbsp;* You must call db_free_result before you can call db_query again!<br />
&nbsp;* \see db_free_result<br />
&nbsp;*<br />
&nbsp;* \param _h database connection handle<br />
&nbsp;* \param _k array of column names that will be compared and their values must match<br />
&nbsp;* \param _op array of operators to be used with key-value pairs<br />
&nbsp;* \param _v array of values, columns specified in _k parameter must match these values<br />
&nbsp;* \param _c array of column names that you are interested in<br />
&nbsp;* \param _n number of key-value pairs to match in _k and _v parameters<br />
&nbsp;* \param _nc number of columns in _c parameter<br />
&nbsp;* \param _o order by statement for query<br />
&nbsp;* \param _r address of variable where pointer to the result will be stored<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_query_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> <span class="kw4">const</span> db_key_t<span class="sy0">*</span> _k<span class="sy0">,</span> <span class="kw4">const</span> db_op_t<span class="sy0">*</span> _op<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> db_val_t<span class="sy0">*</span> _v<span class="sy0">,</span> <span class="kw4">const</span> db_key_t<span class="sy0">*</span> _c<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">int</span> _n<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">int</span> _nc<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> db_key_t _o<span class="sy0">,</span> db_res_t<span class="sy0">**</span> _r<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Upon a successful select query call, the developer will have to manipulate the output db_res_t in order to use the results of his select query. Below are the used structures for interpreting a query result set.
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock76'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* This type represents a result returned by db_query function (see below). The<br />
&nbsp;* result can consist of zero or more rows (see db_row_t description).<br />
&nbsp;*<br />
&nbsp;* Note: A variable of type db_res_t returned by db_query function uses dynamicaly<br />
&nbsp;* allocated memory, don't forget to call db_free_result if you don't need the<br />
&nbsp;* variable anymore. You will encounter memory leaks if you fail to do this!<br />
&nbsp;*<br />
&nbsp;* In addition to zero or more rows, each db_res_t object contains also an array<br />
&nbsp;* of db_key_t objects. The objects represent keys (names of columns). *<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">struct</span> db_res <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db_key_t<span class="sy0">*</span> names<span class="sy0">;</span> &nbsp; <span class="coMULTI">/**&lt; Column names &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db_type_t<span class="sy0">*</span> types<span class="sy0">;</span> &nbsp;<span class="coMULTI">/**&lt; Column types &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> n<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/**&lt; Number of columns &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> col<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> db_row<span class="sy0">*</span> rows<span class="sy0">;</span> &nbsp; <span class="coMULTI">/**&lt; Rows &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> n<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/**&lt; Number of rows in current fetch */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> res_rows<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/**&lt; Number of total rows in query &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> last_row<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/**&lt; Last row &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br />
<span class="br0">&#125;</span> db_res_t<span class="sy0">;</span><br />
<br />
<span class="coMULTI">/**<br />
&nbsp;* Structure holding the result of a query table function.<br />
&nbsp;* It represents one row in a database table. In other words, the row is an<br />
&nbsp;* array of db_val_t variables, where each db_val_t variable represents exactly<br />
&nbsp;* one cell in the table.<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">struct</span> db_row <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; db_val_t<span class="sy0">*</span> values<span class="sy0">;</span> &nbsp;<span class="coMULTI">/**&lt; Columns in the row */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> n<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/**&lt; Number of columns in the row */</span><br />
<span class="br0">&#125;</span> db_row_t<span class="sy0">;</span><br />
<br />
<span class="coMULTI">/**<br />
&nbsp;* This structure represents a value in the database. Several datatypes are<br />
&nbsp;* recognized and converted by the database API. These datatypes are automaticaly<br />
&nbsp;* recognized, converted from internal database representation and stored in the<br />
&nbsp;* variable of corresponding type.<br />
&nbsp;*<br />
&nbsp;* Module that want to use this values needs to copy them to another memory<br />
&nbsp;* location, because after the call to free_result there are not more available.<br />
&nbsp;*<br />
&nbsp;* If the structure holds a pointer to a string value that needs to be freed<br />
&nbsp;* because the module allocated new memory for it then the free flag must<br />
&nbsp;* be set to a non-zero value. A free flag of zero means that the string<br />
&nbsp;* data must be freed internally by the database driver.<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">struct</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; db_type_t type<span class="sy0">;</span> <span class="coMULTI">/**&lt; Type of the value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> nul<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/**&lt; Means that the column in database has no value */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> <span class="kw3">free</span><span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/**&lt; Means that the value should be freed */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/** Column value structure that holds the actual data in a union. &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">union</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int_val<span class="sy0">;</span> &nbsp; &nbsp;<span class="coMULTI">/**&lt; integer value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">long</span> <span class="kw4">long</span> &nbsp; &nbsp; bigint_val<span class="sy0">;</span> <span class="coMULTI">/**&lt; big integer value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">double</span> &nbsp; &nbsp; &nbsp; &nbsp;double_val<span class="sy0">;</span> <span class="coMULTI">/**&lt; double value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time_t &nbsp; &nbsp; &nbsp; &nbsp;time_val<span class="sy0">;</span> &nbsp; <span class="coMULTI">/**&lt; unix time_t value &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> <span class="kw4">char</span><span class="sy0">*</span> &nbsp; string_val<span class="sy0">;</span> <span class="coMULTI">/**&lt; zero terminated string &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str_val<span class="sy0">;</span> &nbsp; &nbsp;<span class="coMULTI">/**&lt; str type string value &nbsp; &nbsp; &nbsp;*/</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blob_val<span class="sy0">;</span> &nbsp; <span class="coMULTI">/**&lt; binary object data &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> &nbsp;bitmap_val<span class="sy0">;</span> <span class="coMULTI">/**&lt; Bitmap data type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> val<span class="sy0">;</span><br />
<span class="br0">&#125;</span> db_val_t<span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Many macros are in place in order to help writing faster and easier to read code :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock77'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* Macros below work on result sets ( db_res_t )<br />
/** Return the column names */</span><br />
<span class="co2">#define RES_NAMES(re) ((re)-&gt;col.names)</span><br />
<span class="coMULTI">/** Return the column types */</span><br />
<span class="co2">#define RES_TYPES(re) ((re)-&gt;col.types)</span><br />
<span class="coMULTI">/** Return the number of columns */</span><br />
<span class="co2">#define RES_COL_N(re) ((re)-&gt;col.n)</span><br />
<span class="coMULTI">/** Return the result rows */</span><br />
<span class="co2">#define RES_ROWS(re) &nbsp;((re)-&gt;rows)</span><br />
<span class="coMULTI">/** Return the number of current result rows */</span><br />
<span class="co2">#define RES_ROW_N(re) ((re)-&gt;n)</span><br />
<span class="coMULTI">/** Return the last row of the result */</span><br />
<span class="co2">#define RES_LAST_ROW(re) &nbsp;((re)-&gt;last_row)</span><br />
<span class="coMULTI">/** Return the number of total result rows */</span><br />
<span class="co2">#define RES_NUM_ROWS(re) ((re)-&gt;res_rows)</span><br />
<br />
<span class="coMULTI">/* Macros below work on rows */</span><br />
<span class="coMULTI">/** Return the columns in the row */</span><br />
<span class="co2">#define ROW_VALUES(rw) ((rw)-&gt;values)</span><br />
<span class="coMULTI">/** Return the number of colums */</span><br />
<span class="co2">#define ROW_N(rw) &nbsp; &nbsp; &nbsp;((rw)-&gt;n)</span><br />
<br />
<span class="coMULTI">/* Macros below work on values */</span><br />
<span class="coMULTI">/**<br />
&nbsp;* Use this macro if you need to set/get the type of the value.<br />
&nbsp;*/</span><br />
<span class="co2">#define VAL_TYPE(dv) &nbsp; ((dv)-&gt;type)</span><br />
<span class="coMULTI">/**<br />
&nbsp;* Use this macro if you need to set/get the null flag. A non-zero flag means that<br />
&nbsp;* the corresponding cell in the database contains no data (a NULL value in MySQL<br />
&nbsp;* terminology).<br />
&nbsp;*/</span><br />
<span class="co2">#define VAL_NULL(dv) &nbsp; ((dv)-&gt;nul)</span><br />
<span class="coMULTI">/**<br />
&nbsp;* Use this macro if you need to access the integer value in the db_val_t structure.<br />
&nbsp;*/</span><br />
<span class="co2">#define VAL_INT(dv) &nbsp; &nbsp;((dv)-&gt;val.int_val)</span><br />
<span class="coMULTI">/**<br />
&nbsp;* Use this macro if you need to access the str structure in the db_val_t structure.<br />
&nbsp;*/</span><br />
<span class="co2">#define VAL_STR(dv) &nbsp; &nbsp;((dv)-&gt;val.str_val)</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Find below an example of a full select query from start to finish :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock78'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* we will work on 'mytable' table with just two columns, keyname and value.<br />
The select query we will run is 'select value from mytable where keyname='abc';'<br />
*/</span><br />
db_key_t key<span class="sy0">;</span><br />
db_val_t val<span class="sy0">;</span><br />
db_key_t col<span class="sy0">;</span><br />
db_res_t<span class="sy0">*</span> db_res <span class="sy0">=</span> NULL<span class="sy0">;</span><br />
db_row_t <span class="sy0">*</span> rows<span class="sy0">;</span><br />
db_val_t <span class="sy0">*</span> values<span class="sy0">;</span><br />
<br />
<span class="co2">#define KEY_COL &quot;keyname&quot;</span><br />
<span class="co2">#define VALUE_COL &quot;value&quot;</span><br />
str key_column <span class="sy0">=</span> str_init<span class="br0">&#40;</span>KEY_COL<span class="br0">&#41;</span><span class="sy0">;</span><br />
str value_column <span class="sy0">=</span> str_init<span class="br0">&#40;</span>VALUE_COL<span class="br0">&#41;</span><span class="sy0">;</span><br />
str db_table <span class="sy0">=</span> str_init<span class="br0">&#40;</span><span class="st0">&quot;mytable&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
val.<span class="me1">type</span> <span class="sy0">=</span> DB_STR<span class="sy0">;</span><br />
val.<span class="me1">nul</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span><br />
val.<span class="me1">val</span>.<span class="me1">str_val</span>.<span class="me1">s</span> <span class="sy0">=</span> <span class="st0">&quot;abc&quot;</span><span class="sy0">;</span><br />
val.<span class="me1">val</span>.<span class="me1">str_val</span>.<span class="me1">len</span> <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span><br />
<br />
key <span class="sy0">=</span> <span class="sy0">&amp;</span>key_column<span class="sy0">;</span><br />
col <span class="sy0">=</span> <span class="sy0">&amp;</span>value_column<span class="sy0">;</span><br />
<br />
<span class="kw1">if</span> <span class="br0">&#40;</span>sql_functions.<span class="me1">use_table</span><span class="br0">&#40;</span>db_handle<span class="sy0">,</span> <span class="sy0">&amp;</span>db_table<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;sql use_table failed<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw1">if</span><span class="br0">&#40;</span>sql_functions.<span class="me1">query</span><span class="br0">&#40;</span>db_handle<span class="sy0">,</span> <span class="sy0">&amp;</span>key<span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="sy0">&amp;</span>val<span class="sy0">,</span> <span class="sy0">&amp;</span>col<span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span> NULL<span class="sy0">,</span> <span class="sy0">&amp;</span>db_res<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp;LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;failed to query database<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp;<span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
<br />
nr_rows <span class="sy0">=</span> RES_ROW_N<span class="br0">&#40;</span>db_res<span class="br0">&#41;</span><span class="sy0">;</span><br />
rows <span class="sy0">=</span> RES_ROWS<span class="br0">&#40;</span>db_res<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="kw1">if</span> <span class="br0">&#40;</span>nr_rows <span class="sy0">&lt;=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; LM_DBG<span class="br0">&#40;</span><span class="st0">&quot;no rows found<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; sql_functions.<span class="me1">free_result</span><span class="br0">&#40;</span>db_handle<span class="sy0">,</span> db_res<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw1">for</span> <span class="br0">&#40;</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span>i<span class="sy0">&lt;</span>nr_rows<span class="sy0">;</span>i<span class="sy0">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; values <span class="sy0">=</span> ROW_VALUES<span class="br0">&#40;</span>rows <span class="sy0">+</span> i<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>VAL_NULL<span class="br0">&#40;</span>values<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_WARN<span class="br0">&#40;</span><span class="st0">&quot;Column value should not be null - skipping <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">continue</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; LM_DBG<span class="br0">&#40;</span><span class="st0">&quot;We have feteched %s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span>VAL_STRING<span class="br0">&#40;</span>values<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; <span class="coMULTI">/* do further rows processing here */</span><br />
<span class="br0">&#125;</span><br />
<br />
sql_functions.<span class="me1">free_result</span><span class="br0">&#40;</span>db_handle<span class="sy0">,</span> db_res<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
&nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />As can be seen from the example above, any successful call to the <strong>query</strong> SQL function must be followed by the freeing of the returned result set, which is done by calling the <strong>free_result</strong> API function :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock79'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Free a result allocated by db_query.<br />
&nbsp;*<br />
&nbsp;* This function frees all memory allocated previously in db_query. Its<br />
&nbsp;* neccessary to call this function on a db_res_t structure if you don't need the<br />
&nbsp;* structure anymore. You must call this function before you call db_query again!<br />
&nbsp;* \param _h database connection handle<br />
&nbsp;* \param _r pointer to db_res_t structure to destroy<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_free_result_f<span class="br0">&#41;</span> <span class="br0">&#40;</span>db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> db_res_t<span class="sy0">*</span> _r<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent tip' > 
<p>Sometimes, especially when querying large tables, it is not desirable to fetch all the rows in one chunk, since that might lead to the filling of the OpenSIPS private memory. <br />For such scenarios, using the <strong>fetch_result</strong> API function is highly recommended
</p></div>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock80'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;* \brief Fetch a number of rows from a result. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;*<br />
&nbsp;* The function fetches a number of rows from a database result. If the number <br />
&nbsp;* of wanted rows is zero, the function returns anything with a result of zero.<br />
&nbsp;* \param _h structure representing database connection<br />
&nbsp;* \param _r structure for the result<br />
&nbsp;* \param _n the number of rows that should be fetched &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0 &nbsp; &nbsp; &nbsp; &nbsp; <br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_fetch_result_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> db_res_t<span class="sy0">**</span> _r<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">int</span> _n<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Find below a full example of using <strong>fetch_result</strong> :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock81'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* check if our used DB driver supports fetching a limited number of rows */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>DB_CAPABILITY<span class="br0">&#40;</span><span class="sy0">*</span>dr_dbf<span class="sy0">,</span> DB_CAP_FETCH<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* run our query as usual, but DO NOT provide a result set pointer ( last parameter 0 ) */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> dr_dbf<span class="sy0">-&gt;</span>query<span class="br0">&#40;</span> db_hdl<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> columns<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> db_cols<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span> <span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;DB query failed<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* estimate how many rows we can fit into our current PKG memory */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; no_rows <span class="sy0">=</span> estimate_available_rows<span class="br0">&#40;</span> <span class="nu0">4</span><span class="sy0">+</span><span class="nu0">32</span><span class="sy0">+</span><span class="nu0">15</span><span class="sy0">+</span><span class="nu0">4</span><span class="sy0">+</span><span class="nu0">32</span><span class="sy0">+</span><span class="nu0">4</span><span class="sy0">+</span><span class="nu0">128</span><span class="sy0">+</span><span class="nu0">4</span><span class="sy0">+</span><span class="nu0">32</span><span class="sy0">+</span><span class="nu0">4</span><span class="sy0">,</span> db_cols<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>no_rows<span class="sy0">==</span><span class="nu0">0</span><span class="br0">&#41;</span> no_rows <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* try to fetch our rows */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>dr_dbf<span class="sy0">-&gt;</span>fetch_result<span class="br0">&#40;</span>db_hdl<span class="sy0">,</span> <span class="sy0">&amp;</span>res<span class="sy0">,</span> no_rows <span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Error fetching rows<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* no fetching rows support - fallback to full rows loading */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> dr_dbf<span class="sy0">-&gt;</span>query<span class="br0">&#40;</span>db_hdl<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>columns<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span>db_cols<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,&amp;</span>res<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;DB query failed<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">do</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">for</span><span class="br0">&#40;</span>i<span class="sy0">=</span><span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> RES_ROW_N<span class="br0">&#40;</span>res<span class="br0">&#41;</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; row <span class="sy0">=</span> RES_ROWS<span class="br0">&#40;</span>res<span class="br0">&#41;</span> <span class="sy0">+</span> i<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* start processing our loaded rows */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>DB_CAPABILITY<span class="br0">&#40;</span><span class="sy0">*</span>dr_dbf<span class="sy0">,</span> DB_CAP_FETCH<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* any more rows to fetch ? */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span><span class="br0">&#40;</span>dr_dbf<span class="sy0">-&gt;</span>fetch_result<span class="br0">&#40;</span>db_hdl<span class="sy0">,</span> <span class="sy0">&amp;</span>res<span class="sy0">,</span> no_rows<span class="br0">&#41;</span><span class="sy0">&lt;</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span> <span class="st0">&quot;fetching rows (1)<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* success in fetching more rows - continue the loop */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* we were not supporting fetching rows in the first place, processed everything */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw2">break</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">while</span><span class="br0">&#40;</span>RES_ROW_N<span class="br0">&#40;</span>res<span class="br0">&#41;</span><span class="sy0">&gt;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; dr_dbf<span class="sy0">-&gt;</span>free_result<span class="br0">&#40;</span>db_hdl<span class="sy0">,</span> res<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Inserting rows in a table can be done by calling the <strong>insert</strong> API function :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock82'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Insert a row into the specified table.<br />
&nbsp;*<br />
&nbsp;* This function implements INSERT SQL directive, you can insert one or more<br />
&nbsp;* rows in a table using this function.<br />
&nbsp;* \param _h database connection handle<br />
&nbsp;* \param _k array of keys (column names)<br />
&nbsp;* \param _v array of values for keys specified in _k parameter<br />
&nbsp;* \param _n number of keys-value pairs int _k and _v parameters<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_insert_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> <span class="kw4">const</span> db_key_t<span class="sy0">*</span> _k<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> db_val_t<span class="sy0">*</span> _v<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">int</span> _n<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Deleting rows from a table is accomplished by calling the <strong>delete</strong> API function :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock83'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Delete a row from the specified table.<br />
&nbsp;*<br />
&nbsp;* This function implements DELETE SQL directive, it is possible to delete one or<br />
&nbsp;* more rows from a table.<br />
&nbsp;* If _k is NULL and _v is NULL and _n is zero, all rows are deleted, the<br />
&nbsp;* resulting table will be empty.<br />
&nbsp;* If _o is NULL, the equal operator &quot;=&quot; will be used for the comparison.<br />
&nbsp;*<br />
&nbsp;* \param _h database connection handle<br />
&nbsp;* \param _k array of keys (column names) that will be matched<br />
&nbsp;* \param _o array of operators to be used with key-value pairs<br />
&nbsp;* \param _v array of values that the row must match to be deleted<br />
&nbsp;* \param _n number of keys-value parameters in _k and _v parameters<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_delete_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> <span class="kw4">const</span> db_key_t<span class="sy0">*</span> _k<span class="sy0">,</span> <span class="kw4">const</span> db_op_t<span class="sy0">*</span> _o<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> db_val_t<span class="sy0">*</span> _v<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">int</span> _n<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Updating rows in a table can be done by calling the <strong>update</strong> API function :
</p>
<div class='sourceblock ' id='sourceblock84'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Update some rows in the specified table.<br />
&nbsp;*<br />
&nbsp;* The function implements UPDATE SQL directive. It is possible to modify one<br />
&nbsp;* or more rows in a table using this function.<br />
&nbsp;* \param _h database connection handle<br />
&nbsp;* \param _k array of keys (column names) that will be matched<br />
&nbsp;* \param _o array of operators to be used with key-value pairs<br />
&nbsp;* \param _v array of values that the row must match to be modified<br />
&nbsp;* \param _uk array of keys (column names) that will be modified<br />
&nbsp;* \param _uv new values for keys specified in _k parameter<br />
&nbsp;* \param _n number of key-value pairs in _k and _v parameters<br />
&nbsp;* \param _un number of key-value pairs in _uk and _uv parameters<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_update_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> <span class="kw4">const</span> db_key_t<span class="sy0">*</span> _k<span class="sy0">,</span> <span class="kw4">const</span> db_op_t<span class="sy0">*</span> _o<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> db_val_t<span class="sy0">*</span> _v<span class="sy0">,</span> <span class="kw4">const</span> db_key_t<span class="sy0">*</span> _uk<span class="sy0">,</span> <span class="kw4">const</span> db_val_t<span class="sy0">*</span> _uv<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> <span class="kw4">int</span> _n<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">int</span> _un<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Replacing rows in a database table can be done with the <strong>replace</strong> function from the API :
</p>
<div class='sourceblock ' id='sourceblock85'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Insert a row and replace if one already exists.<br />
&nbsp;*<br />
&nbsp;* The function implements the REPLACE SQL directive. It is possible to insert<br />
&nbsp;* a row and replace if one already exists. The old row will be deleted before<br />
&nbsp;* the insertion of the new data.<br />
&nbsp;* \param _h structure representing database connection<br />
&nbsp;* \param _k key names<br />
&nbsp;* \param _v values of the keys<br />
&nbsp;* \param _n number of key=value pairs<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_replace_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> handle<span class="sy0">,</span> <span class="kw4">const</span> db_key_t<span class="sy0">*</span> keys<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> db_val_t<span class="sy0">*</span> vals<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">int</span> n<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Sometimes, for optimizing database operations, it is useful to know the auto-increment primary key value upon inserting / updating a record. For such cases, the <strong>last_inserted_id</strong> API call can be used :
</p>
<div class='sourceblock ' id='sourceblock86'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Retrieve the last inserted ID in a table.<br />
&nbsp;*<br />
&nbsp;* The function returns the value generated for an AUTO_INCREMENT column by the<br />
&nbsp;* previous INSERT or UPDATE &nbsp;statement. Use this function after you have<br />
&nbsp;* performed an INSERT statement into a table that contains an AUTO_INCREMENT<br />
&nbsp;* field.<br />
&nbsp;* \param _h structure representing database connection<br />
&nbsp;* \return returns the ID as integer or returns 0 if the previous statement<br />
&nbsp;* does not use an AUTO_INCREMENT value.<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_last_inserted_id_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> _h<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Also, when we want to insert a row into a table, and update the row in case of duplicate key errors, we should use the <strong>insert_update</strong> API call :
</p>
<div class='sourceblock ' id='sourceblock87'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Insert a row into specified table, update on duplicate key.<br />
&nbsp;*<br />
&nbsp;* The function implements the INSERT ON DUPLICATE KEY UPDATE SQL directive.<br />
&nbsp;* It is possible to insert a row and update if one already exists.<br />
&nbsp;* The old row will not deleted before the insertion of the new data.<br />
&nbsp;* \param _h structure representing database connection<br />
&nbsp;* \param _k key names<br />
&nbsp;* \param _v values of the keys<br />
&nbsp;* \param _n number of key=value pairs<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_insert_update_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> <span class="kw4">const</span> db_key_t<span class="sy0">*</span> _k<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">const</span> db_val_t<span class="sy0">*</span> _v<span class="sy0">,</span> <span class="kw4">const</span> <span class="kw4">int</span> _n<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />For running all other database queries, one should use the <strong>raw_query</strong> API function. 
</p>
<div class='sourceblock ' id='sourceblock88'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* \brief Raw SQL query.<br />
&nbsp;*<br />
&nbsp;* This function can be used to do database specific queries. Please<br />
&nbsp;* use this function only if needed, as this creates portability issues<br />
&nbsp;* for the different databases. Also keep in mind that you need to<br />
&nbsp;* escape all external data sources that you use. You could use the<br />
&nbsp;* escape_common and unescape_common functions in the core for this task.<br />
&nbsp;* \see escape_common<br />
&nbsp;* \see unescape_common<br />
&nbsp;* \param _h structure representing database connection<br />
&nbsp;* \param _s the SQL query<br />
&nbsp;* \param _r structure for the result<br />
&nbsp;* \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />
&nbsp;*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>db_raw_query_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">const</span> db_con_t<span class="sy0">*</span> _h<span class="sy0">,</span> <span class="kw4">const</span> str<span class="sy0">*</span> _s<span class="sy0">,</span> db_res_t<span class="sy0">**</span> _r<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<h4><a name='toc29' id='toc29'></a>13.&nbsp; NoSQL API</h4>
<h4><a name='toc30' id='toc30'></a>14.&nbsp; Event Interface API</h4>
<h4><a name='toc31' id='toc31'></a>15.&nbsp; BIN Interface API</h4>
<p>The <strong>Binary Internal Interface</strong> is an OpenSIPS core interface which offers an efficient way for communication between individual OpenSIPS instances.<br />This is especially useful in scenarios where realtime data (such as dialogs) cannot be simply stored in a database anymore, because failover would require entire minutes to complete. This issue can be solved with the new internal binary interface by replicating all the events related to the runtime data (creation / updating / deletion) to a backup OpenSIPS instance. <br />The BIN interface functionality is exported by the <strong>bin_interface.h</strong> file. <br />Using the interface has two steps :
</p>
<div class='vspace'></div><ul><li>creating and sending the new event from the Active OpenSIPS server
</li><li>receiving and processing the event in the Backup OpenSIPS server
</li></ul><p class='vspace'>For creating and sending a new event, the following methods are to be used :
</p>
<div class='sourceblock ' id='sourceblock89'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* bin_init - begins the construction of a new binary packet (header part):<br />
&nbsp;*<br />
&nbsp;* +-------------------+------------------------------------------------------+<br />
&nbsp;* | &nbsp;8-byte HEADER &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BODY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max 65535 bytes &nbsp;|<br />
&nbsp;* +-------------------+------------------------------------------------------+<br />
&nbsp;* | PK_MARKER | &nbsp;CRC &nbsp;| LEN | MOD_NAME | CMD | LEN | FIELD | LEN | FIELD |...|<br />
&nbsp;* +-------------------+------------------------------------------------------+<br />
&nbsp;*<br />
&nbsp;* @param: { LEN, MOD_NAME } + CMD<br />
&nbsp;*/</span><br />
<span class="kw4">int</span> bin_init<span class="br0">&#40;</span>str <span class="sy0">*</span>mod_name<span class="sy0">,</span> <span class="kw4">int</span> cmd_type<span class="br0">&#41;</span><br />
<br />
<span class="coMULTI">/*<br />
&nbsp;* copies the given string at the 'cpos' position in the buffer<br />
&nbsp;* allows null strings (NULL content or NULL param)<br />
&nbsp;*<br />
&nbsp;* @return: 0 on success<br />
&nbsp;*/</span><br />
<span class="kw4">int</span> bin_push_str<span class="br0">&#40;</span><span class="kw4">const</span> str <span class="sy0">*</span>info<span class="br0">&#41;</span><br />
<br />
<span class="coMULTI">/*<br />
&nbsp;* adds a new integer value at the 'cpos' position in the buffer<br />
&nbsp;*<br />
&nbsp;* @return: 0 on success<br />
&nbsp;*/</span><br />
<span class="kw4">int</span> bin_push_int<span class="br0">&#40;</span><span class="kw4">int</span> info<span class="br0">&#41;</span><br />
<br />
<span class="coMULTI">/**<br />
&nbsp;* bin_send - computes the checksum of the current packet and then<br />
&nbsp;* sends the packet over UDP to the @dest destination<br />
&nbsp;*<br />
&nbsp;* @return: number of bytes sent, or -1 on error<br />
&nbsp;*/</span><br />
<span class="kw4">int</span> bin_send<span class="br0">&#40;</span><span class="kw4">union</span> sockaddr_union <span class="sy0">*</span>dest<span class="br0">&#41;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />On the receiving end, the developer must first register a callback that will be trigger when receiving special types of BIN message, by using the following :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock90'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/**<br />
&nbsp;* bin_register_cb - registers a module handler for specific packets<br />
&nbsp;* @mod_name: used to classify the incoming packets<br />
&nbsp;* @cb: &nbsp; &nbsp; &nbsp; the handler function, called once for each matched packet<br />
&nbsp;*<br />
&nbsp;* @return: &nbsp; 0 on success<br />
&nbsp;*/</span><br />
<span class="kw4">int</span> bin_register_cb<span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span>mod_name<span class="sy0">,</span> <span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>cb<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#41;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The callback will only be triggered for the mod_name class of BIN packages, and also the callback will receive the packet type as well, in order to be able to differentiate between multiple types of events ( eg. create, update, delete, etc ).
<br />Afterwards, you should use the pop methods for extracting the contents of the package :
</p>
<div class='sourceblock ' id='sourceblock91'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
&nbsp;* pops an str from the current position in the buffer<br />
&nbsp;* @info: &nbsp; pointer to store the result<br />
&nbsp;*<br />
&nbsp;* @return: 0 on success<br />
&nbsp;*<br />
&nbsp;* Note: The pointer returned in @info str is only valid for the duration of<br />
&nbsp;* &nbsp; &nbsp; &nbsp; the callback. Don't forget to copy the info into a safe buffer!<br />
&nbsp;*/</span><br />
<span class="kw4">int</span> bin_pop_str<span class="br0">&#40;</span>str <span class="sy0">*</span>info<span class="br0">&#41;</span><br />
<br />
<span class="coMULTI">/*<br />
&nbsp;* pops an integer value from the current position in the buffer<br />
&nbsp;* @info: &nbsp; pointer to store the result<br />
&nbsp;*<br />
&nbsp;* @return: 0 on success<br />
&nbsp;*/</span><br />
<span class="kw4">int</span> bin_pop_int<span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>info<span class="br0">&#41;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />See the main page dedicated to the <a class='urllink' href="Interface-Binary-2-2.htm" tppabs="http://www.opensips.org/Documentation/Interface-Binary" rel='nofollow'>Binary Interface</a> on how to then configure OpenSIPS listeners for the binary packages.
</p>
<div class='vspace'></div><h4><a name='toc32' id='toc32'></a>16.&nbsp; Module Development</h4>
<h5><a name='toc33' id='toc33'></a>16.1&nbsp; Introduction</h5>
<p>Due to the OpenSIPS modular architecture, the easiest way to add new features ( new parameters, script functions, MI function etc ) is to incorporate them into a new <strong>OpenSIPS module</strong>. <br />An OpenSIPS module is actually a shared library ( .so file ) which OpenSIPS can dinamically load at OpenSIPS startup, if the module is loaded from within the OpenSIPS script, by using the <strong>loadmodule</strong> directive :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock92'>
  <div class='sourceblocktext'><div class="c">loadmodule <span class="st0">&quot;mynewmod.so&quot;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p class='vspace'><br />Upon loading a new module, the OpenSIPS core will lookup the <strong>exports</strong> variable, of type <strong>struct module_exports</strong>. This structure and variable are of the utmost importance when developing a new OpenSIPS module
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock93'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> module_exports<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span><span class="sy0">*</span> name<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; null terminated module name */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>version<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/*!&lt; module version */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>compile_flags<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/*!&lt; compile flags used on the module */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> dlflags<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; flags for dlopen */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd_export_t<span class="sy0">*</span> cmds<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; null terminated array of the exported<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;commands */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; param_export_t<span class="sy0">*</span> params<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; null terminated array of the exported<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;module parameters */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat_export_t<span class="sy0">*</span> stats<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; null terminated array of the exported<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;module statistics */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mi_export_t<span class="sy0">*</span> mi_cmds<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; null terminated array of the exported<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;MI functions */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pv_export_t<span class="sy0">*</span> items<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; null terminated array of the exported<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;module items (pseudo-variables) */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc_export_t<span class="sy0">*</span> procs<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; null terminated array of the additional<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;processes reqired by the module */</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; init_function init_f<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; Initialization function */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response_function response_f<span class="sy0">;</span> &nbsp; <span class="coMULTI">/*!&lt; function used for responses,<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;returns yes or no; can be null */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; destroy_function destroy_f<span class="sy0">;</span> &nbsp; &nbsp; <span class="coMULTI">/*!&lt; function called when the module should<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be &quot;destroyed&quot;, e.g: on opensips exit */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_init_function init_child_f<span class="sy0">;</span><span class="coMULTI">/*!&lt; function called by all processes<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; after the fork */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The module_exports contents ( along with the above coments ) are self-explanatory. <br />
Further on, we will discuss about each member of the module_exports structure and how it is meant to be used when building a nw OpenSIPS. Purely as an example, See below the exports used by the dialog module
</p>
<div class='sourceblock ' id='sourceblock94'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> module_exports exports<span class="sy0">=</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="st0">&quot;dialog&quot;</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* module's name */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MODULE_VERSION<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEFAULT_DLFLAGS<span class="sy0">,</span> <span class="coMULTI">/* dlopen flags */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmds<span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* exported functions */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mod_params<span class="sy0">,</span> &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* param exports */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mod_stats<span class="sy0">,</span> &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* exported statistics */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mi_cmds<span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* exported MI functions */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mod_items<span class="sy0">,</span> &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* exported pseudo-variables */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* extra processes */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mod_init<span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* module initialization function */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* reply processing function */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mod_destroy<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_init &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* per-child init function */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc34' id='toc34'></a>16.2&nbsp; Compiling a module</h5>
<p>Further on, we will be following the various options we have in building our new module, named <strong>ournewmod</strong>.
<br />After creating the <strong>ournewmod</strong> folder in the OpenSIPS modules/ path, we should create a Makefile for our module, located also in the <strong>ournewmod</strong> folder.
The most basic Makefile for a module with no external library dependencies is the following :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock95'>
  <div class='sourceblocktext'><div class="c"><span class="co2"># $Id$</span><br />
<span class="co2">#</span><br />
<span class="co2"># WARNING: do not run this directly, it should be run by the master Makefile</span><br />
<br />
include ..<span class="sy0">/</span>..<span class="sy0">/</span>Makefile.<span class="me1">defs</span><br />
auto_gen<span class="sy0">=</span><br />
NAME<span class="sy0">=</span>ournewmod.<span class="me1">so</span><br />
LIBS<span class="sy0">=</span><br />
<br />
include ..<span class="sy0">/</span>..<span class="sy0">/</span>Makefile.<span class="me1">modules</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />If the module has external library dependencies, they should be linked in the module's Makefile as well. Eg, the cachedb_memcached module :
</p>
<div class='sourceblock ' id='sourceblock96'>
  <div class='sourceblocktext'><div class="c">include ..<span class="sy0">/</span>..<span class="sy0">/</span>Makefile.<span class="me1">defs</span><br />
auto_gen<span class="sy0">=</span><br />
NAME<span class="sy0">=</span>cachedb_memcached.<span class="me1">so</span><br />
DEFS<span class="sy0">+=-</span>I$<span class="br0">&#40;</span>LOCALBASE<span class="br0">&#41;</span><span class="sy0">/</span>include<br />
LIBS<span class="sy0">=-</span>L$<span class="br0">&#40;</span>LOCALBASE<span class="br0">&#41;</span><span class="sy0">/</span>lib <span class="sy0">-</span>lmemcached<br />
<br />
include ..<span class="sy0">/</span>..<span class="sy0">/</span>Makefile.<span class="me1">modules</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent important' > 
<p>If our new module depends on external libraries, the module must not be left to compile by default !
</p></div>
<p class='vspace'>This must be done by editing the <strong>Makefile.conf.template</strong> file - where we specify which modules are to not be compiled by default, along with the dependencies they have. <br />We should add a new line to Makefile.conf.template, with the following format :
</p>
<div class='sourceblock ' id='sourceblock97'>
  <div class='sourceblocktext'><div class="c">modulename<span class="sy0">=</span> Module Description <span class="sy0">|</span> module dependency</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Also, we should modify <strong>Makefile.conf.template</strong> to add our new module's name to the <strong>exclude_modules</strong> list of modules that will not compile by default.
</p>
<div class='vspace'></div><h5><a name='toc35' id='toc35'></a>16.3&nbsp; Initializing the module</h5>
<p>In the context of initializing our new module, there are two types of functions that will help us :
</p>
<div class='vspace'></div><h6>mod_init</h6>
<p>This function must be specified in the <strong>init_f</strong> member of our module_exports exports structure. <br />It is ran from within a single process' context ( the attendant ), after the full OpenSIPS config has been parsed ( our own module parameters included ), and all the helper APIs are initialized at this point ( shared memory, locking, timer processes, etc ). <br />The purpose of the function is to check the integrity of how the module was configured from the OpenSIPS script, to initialize needed structures, etc. Also, some critical resources ( like new timer processes, see above section ) can ONLY be initialized from the mod_init() function of our new modules. <br />
Prototype of the function is
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock98'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* MUST return 0 in case of success, anything else in case of error */</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>init_function<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent tip' > 
<p>Since this function is called from the context of only one process, after OpenSIPS forks, each OpenSIPS process will receive a copy of what the attendat process had. <br />Due to this, do NOT use the mod_init function to initialize structures / connections that should have different instances for each OpenSIPS process.
</p></div>
<div class='vspace'></div><h6>child_init</h6>
<p>This function must be specified in the <strong>init_child_f</strong> member of our module_exports exports structure. <br />It is ran from within the context of ALL OpenSIPS processes, right after the new processes has been forked. <br />The purpose of the function is to create various connectors ( db, cachedb, etc ) which should be different for each created OpenSIPS process and to initialize various other variables depending on the OpenSIPS process context we are currently in. <br />
Prototype of the function is
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock99'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* MUST return 0 in case of success, anything else in case of error */</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>child_init_function<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">int</span> rank<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The function will receive an integer parameter, indicating the type of OpenSIPS process that is currently running our function.
Below are all the available options :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock100'>
  <div class='sourceblocktext'><div class="c"><span class="co2">#define PROC_MAIN &nbsp; &nbsp; &nbsp;0 &nbsp;/* Main opensips process */</span><br />
<span class="co2">#define PROC_TIMER &nbsp; &nbsp;-1 &nbsp;/* Timer attendant process */</span><br />
<span class="co2">#define PROC_MODULE &nbsp; -2 &nbsp;/* Extra process requested by modules */</span><br />
<span class="co2">#define PROC_TCP_MAIN -4 &nbsp;/* TCP main process */</span><br />
<span class="co2">#define PROC_BIN &nbsp; &nbsp; &nbsp;-8 &nbsp;/* Any binary interface listener */</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />A positive value for our rank parameter denotes that we are currently operating in the context of an OpenSIPS listener ( UDP, TCP or SCTP ).
<br />
</p><div class='round lrindent tip' > 
<p>If we must do time consuming operations ( eg. load many rows from a database ) , we should be doing this inside the child_init() function for a single process ( eg. rank == 1 would be the context of our first UDP listener) , instead of the mod_init() function. 
<br />This will make OpenSIPS startup faster, and also we will be able to process traffic faster ( at least the traffic that does not explicitly depend on having our module's internal data fully populated ).
</p></div>
<div class='vspace'></div><h5><a name='toc36' id='toc36'></a>16.4&nbsp; Destroying the module</h5>
<p>This function must be specified in the <strong>destroy_function</strong> member of our module_exports exports structure. <br />It is ran from within a single process' context ( the attendant ), when OpenSIPS is about to shutdown. <br />The purpose of the function is to cleanup various resources that OpenSIPS has been using ( shared memory, DB connections, etc ). Also, the <strong>destroy_function</strong> is a good time to save whatever state that the module was keeping into a persistent storage, so that they can be loaded afterwards, when OpenSIPS starts. ( eg. the dialog module saves all the dialog states in the database in the destroy function ). <br />Prototype of the function is
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock101'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>destroy_function<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc37' id='toc37'></a>16.5&nbsp; Adding module Parameters</h5>
<p>Adding new module parameters is done by populating the <strong>params</strong> member in our module's <strong>exports</strong> structure. At OpenSIPS startup, OpenSIPS will parse the provided script and set our internal variables accordingly to what the OpenSIPS script writer has configured.
The parameter definition ( param_export_t ) is the following :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock102'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">struct</span> param_export_ <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span><span class="sy0">*</span> name<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/*!&lt; null terminated param. name */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; modparam_t type<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/*!&lt; param. type */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">void</span><span class="sy0">*</span> param_pointer<span class="sy0">;</span> &nbsp; &nbsp;<span class="coMULTI">/*!&lt; pointer to the param. memory location */</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The OpenSIPS modules can export both string and integer parameters. <br />Find below some examples for each of them. Note how the param_export_t structure does not receive any length parameters as to indicate how many parameters the module exports - rather, the structure must end with a row full of 0,
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock103'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">int</span> enable_stats <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span><br />
<span class="kw4">static</span> str db_url <span class="sy0">=</span> <span class="br0">&#123;</span>NULL<span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#125;</span><span class="sy0">;</span><br />
<br />
<span class="kw4">static</span> param_export_t mod_params<span class="br0">&#91;</span><span class="br0">&#93;</span><span class="sy0">=</span><span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span> <span class="st0">&quot;enable_stats&quot;</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;INT_PARAM<span class="sy0">,</span> <span class="sy0">&amp;</span>enable_stats &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span> <span class="st0">&quot;db_url&quot;</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STR_PARAM<span class="sy0">,</span> <span class="sy0">&amp;</span>db_url.<span class="me1">s</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span> <span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span> <span class="br0">&#125;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Example of setting these parameters from the OpenSIPS script, for our <strong>ournewmod</strong> module.
</p>
<div class='sourceblock ' id='sourceblock104'>
  <div class='sourceblocktext'><div class="c">loadmodule <span class="st0">&quot;ournewmod.so&quot;</span><br />
<br />
modparam<span class="br0">&#40;</span><span class="st0">&quot;ournewmod&quot;</span><span class="sy0">,</span><span class="st0">&quot;enable_stats&quot;</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#41;</span><br />
modparam<span class="br0">&#40;</span><span class="st0">&quot;ournewmod&quot;</span><span class="sy0">,</span><span class="st0">&quot;db_url&quot;</span><span class="sy0">,</span><span class="st0">&quot;mysql://vlad:mypw@localhost/opensips&quot;</span><span class="br0">&#41;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Also, OpenSIPS supports triggering a module's internal function when the script writer set a particular parameter. This can prove useful if the provided parameter needs to be converted to a form that the module knows how to process, or simply if one parameter should be able to be set multiple times. <br />Find an example of such parameters below, where an NoSQL URL can be set multiple times in order to initialize as many back-end connections :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock105'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">static</span> param_export_t params<span class="br0">&#91;</span><span class="br0">&#93;</span><span class="sy0">=</span><span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span> <span class="st0">&quot;cachedb_url&quot;</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STR_PARAM<span class="sy0">|</span>USE_FUNC_PARAM<span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="sy0">&amp;</span>set_connection<span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#125;</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span><br />
<br />
<span class="kw4">int</span> set_connection<span class="br0">&#40;</span><span class="kw4">unsigned</span> <span class="kw4">int</span> type<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>val<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; LM_INFO<span class="br0">&#40;</span><span class="st0">&quot;Our parameter has been set : value is %s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="kw4">char</span> <span class="sy0">*</span><span class="br0">&#41;</span>val<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* continue processing, eg : add our new parameter to a list to be further processed */</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h5><a name='toc38' id='toc38'></a>16.6&nbsp; Adding module Functions</h5>
<p>Adding new module parameters is done by populating the <strong>cmds</strong> member in our module's <strong>exports</strong> structure. <br />The exported functions structure is the following :
</p>
<div class='sourceblock ' id='sourceblock106'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">struct</span> cmd_export_ <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span><span class="sy0">*</span> name<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* null terminated command name */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; cmd_function <span class="kw2">function</span><span class="sy0">;</span> &nbsp;<span class="coMULTI">/* pointer to the corresponding function */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> param_no<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* number of parameters used by the function */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; fixup_function fixup<span class="sy0">;</span> &nbsp; <span class="coMULTI">/* pointer to the function called to &quot;fix&quot; the<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;parameters */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; free_fixup_function<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_fixup<span class="sy0">;</span> <span class="coMULTI">/* pointer to the function called to free the<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;fixed&quot; parameters */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> flags<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* Function flags */</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Very similar to the params member in the exports structure, the cmds member MUST be NULL terminated. <br />At startup, OpenSIPS tries to locate each function called in the script either in the core functions, or in the list of functions exported by all list modules.
<br />
</p><div class='round lrindent tip' > 
<p>In order to overload a particular function, you can simply list it twice with the same name in the cmds structure, but change the param_no field.
</p></div>
<p class='vspace'>A script function exported by a module has the following definition :
</p>
<div class='sourceblock ' id='sourceblock107'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">typedef</span> &nbsp;<span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>cmd_function<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*,</span> <span class="kw4">char</span><span class="sy0">*,</span> <span class="kw4">char</span><span class="sy0">*,</span> <span class="kw4">char</span><span class="sy0">*,</span> <span class="kw4">char</span><span class="sy0">*,</span> <span class="kw4">char</span><span class="sy0">*,</span> <span class="kw4">char</span><span class="sy0">*</span><span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />As can be seen, all the OpenSIPS module functions receive string parameters ONLY, and a function can have a maximum of 6 parameters. The SIP message that is currently being processed is also transmitted as the first parameter, although this is transparent to the script writer ( he just provides the parameters idx 1 to 5 )
<br />
</p><div class='round lrindent important' > 
<p>The flags member in the cmd_export_ structure dictates where within the OpenSIPS script can that particular function be called.
</p></div>
<p class='vspace'>Current options here are :
</p>
<div class='sourceblock ' id='sourceblock108'>
  <div class='sourceblocktext'><div class="c"><span class="co2">#define REQUEST_ROUTE 1 &nbsp; /*!&lt; Request route block */</span><br />
<span class="co2">#define FAILURE_ROUTE 2 &nbsp; /*!&lt; Negative-reply route block */</span><br />
<span class="co2">#define ONREPLY_ROUTE 4 &nbsp; /*!&lt; Received-reply route block */</span><br />
<span class="co2">#define BRANCH_ROUTE &nbsp;8 &nbsp; /*!&lt; Sending-branch route block */</span><br />
<span class="co2">#define ERROR_ROUTE &nbsp;16 &nbsp; /*!&lt; Error-handling route block */</span><br />
<span class="co2">#define LOCAL_ROUTE &nbsp;32 &nbsp; /*!&lt; Local-requests route block */</span><br />
<span class="co2">#define STARTUP_ROUTE 64 &nbsp;/*!&lt; Startup route block */</span><br />
<span class="co2">#define TIMER_ROUTE &nbsp;128 &nbsp;/*!&lt; Timer route block */</span><br />
<span class="co2">#define EVENT_ROUTE &nbsp;256 &nbsp;/*!&lt; Event route block */</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Allowing multiple types of routes by provided a bitmask of the above values is also supported.
<br />A very important concept to grasp here is the <strong>fixup_function</strong>. This function is called just once, when the script is initially parsed, and it serves as an optimization, where the provided parameters are further parsed so that we can speed up the runtime function. <br />Examples for the use cases of the fixup function, just to provide a few :
</p><ul><li>since all our module parameters are strings, sometimes our module might need an integer parameter to be passed in that string. The fixup function can be used to convert that string to integer only once
</li><li>if we accept it, our functions can accept pseudo-variables into the provided parameters. In this case, the fixup can be used to lookup the pvar's spec, and then at runtime we will be left just with evaluating that specific pvar in the context of the current SIP message
</li></ul><p><br />Further on we will follow the implementation of <strong>lb_is_destination</strong> from the load_balancer module, to fully grasp the concept. The function definition is the following :
</p>
<div class='sourceblock ' id='sourceblock109'>
  <div class='sourceblocktext'><div class="c">&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;lb_is_destination&quot;</span><span class="sy0">,</span><span class="br0">&#40;</span>cmd_function<span class="br0">&#41;</span>w_lb_is_dst4<span class="sy0">,</span> &nbsp; &nbsp; <span class="nu0">4</span><span class="sy0">,</span> &nbsp; &nbsp;fixup_is_dst<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="nu0">0</span><span class="sy0">,</span> REQUEST_ROUTE<span class="sy0">|</span>FAILURE_ROUTE<span class="sy0">|</span>ONREPLY_ROUTE<span class="sy0">|</span>BRANCH_ROUTE<span class="sy0">|</span>LOCAL_ROUTE<span class="br0">&#125;</span><span class="sy0">,</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />As noted, the function receives 4 parameters. The desired usage case for <strong>lb_is_destination(ip,port,group,active)</strong> is the following :
</p><ul><li>ip - string or pvar with the IP to check
</li><li>port - string or pvar with the Port to check - if empty, we skip any port check
</li><li>group - integer or pvar containing integer with the load_balancer group to check
</li><li>active - integer. if 1, we accept just active destinations for our check
</li></ul><p><br />Knowing these, the fixup_is_dst is the following :
</p>
<div class='sourceblock ' id='sourceblock110'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">static</span> <span class="kw4">int</span> fixup_is_dst<span class="br0">&#40;</span><span class="kw4">void</span><span class="sy0">**</span> param<span class="sy0">,</span> <span class="kw4">int</span> param_no<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>param_no<span class="sy0">==</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* the ip to test */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> fixup_pvar<span class="br0">&#40;</span>param<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>param_no<span class="sy0">==</span><span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* the port to test */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">*</span>param<span class="sy0">==</span>NULL<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">*</span><span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="sy0">*</span><span class="br0">&#41;</span><span class="sy0">*</span>param<span class="br0">&#41;</span><span class="sy0">==</span><span class="nu0">0</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pkg_free<span class="br0">&#40;</span><span class="sy0">*</span>param<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sy0">*</span>param <span class="sy0">=</span> NULL<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> fixup_pvar<span class="br0">&#40;</span>param<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>param_no<span class="sy0">==</span><span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* the group to check in */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> fixup_igp<span class="br0">&#40;</span>param<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>param_no<span class="sy0">==</span><span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* &nbsp;active only check ? */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> fixup_uint<span class="br0">&#40;</span>param<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_CRIT<span class="br0">&#40;</span><span class="st0">&quot;bug - too many params (%d) in lb_is_dst()<span class="es1">\n</span>&quot;</span><span class="sy0">,</span>param_no<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The fixup function will get called for each parameter provided, with the param_no parameter representing the index of the parameter we are parsing ( starting with 1, since the first parameter is the actual SIP msg ) <br /><strong>mod_fix.h</strong> exports many helper functions that can be used for fixups. See the file for a full list of currently implemented fixups.
<br />The above fixup functions will replace the parameter that you will receive in the main function with their respective output. Thus, in the main function you will not receive any more the plain text parameters that were provided by the script writer, but rather you'll receive the pvar's spec after it was parsed, or directly the integer value supplied by the script writer. Here is how the <strong>w_lb_is_dst4</strong> handles the provided parameters after fixup :
</p>
<div class='sourceblock ' id='sourceblock111'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">static</span> <span class="kw4">int</span> w_lb_is_dst4<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg <span class="sy0">*</span>msg<span class="sy0">,</span><span class="kw4">char</span> <span class="sy0">*</span>ip<span class="sy0">,</span><span class="kw4">char</span> <span class="sy0">*</span>port<span class="sy0">,</span><span class="kw4">char</span> <span class="sy0">*</span>grp<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>active<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> ret<span class="sy0">,</span> group<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>fixup_get_ivalue<span class="br0">&#40;</span>msg<span class="sy0">,</span> <span class="br0">&#40;</span>gparam_p<span class="br0">&#41;</span>grp<span class="sy0">,</span> <span class="sy0">&amp;</span>group<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Invalid lb group pseudo variable!<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; ret <span class="sy0">=</span> lb_is_dst<span class="br0">&#40;</span><span class="sy0">*</span>curr_data<span class="sy0">,</span> msg<span class="sy0">,</span> <span class="br0">&#40;</span>pv_spec_t<span class="sy0">*</span><span class="br0">&#41;</span>ip<span class="sy0">,</span> <span class="br0">&#40;</span>pv_spec_t<span class="sy0">*</span><span class="br0">&#41;</span>port<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; group<span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">long</span><span class="br0">&#41;</span>active<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />As we can see, the input char* parameters are casted to their according valus after fixup. <br />Again, <strong>mod_fix.h</strong> provides varius functions for accessing the results of the fixup.In our example, <strong>fixup_get_ivalue</strong> is used to get the provided integer value ( either directly from the plaintext provided integer, or it will extract the integer value from the spec that was parsed at fixup ). Also, note how the active parameter is cast directly to long, since we're accepting only plain-text integers for that parameter, and it has been already converted for us at fixup time.
</p>
<div class='vspace'></div><div class='round lrindent important' > 
<p>The return code of the script exported functions from the module are very important. <br />A strictly positive return code will mean success, while a stricly negative return code will signal a failure <br />Returning 0 in a function exporting to the script will STOP the script execution after the function ends. Use a 0 return code with caution and only when absolutely necessary.
</p></div>
<div class='vspace'></div><h5><a name='toc39' id='toc39'></a>16.7&nbsp; Adding module MI Functions</h5>
<p>Adding new module MI functions is done by populating the <strong>mi_cmds</strong> member in our module's exports structure.
<br />For the full description of the used structures and functions, please see the generic <a class='urllink' href="Development-Manual.htm#toc26" tppabs="http://www.opensips.org/Documentation/Development-Manual#toc26" rel='nofollow'>Management Interface API</a> section. <br />
</p><div class='round lrindent tip' > 
<p>The MI functions in the <strong>mi_cmds</strong> member of the exports structure will be automatically registered by the module interface.
</p></div>
<div class='vspace'></div><h5><a name='toc40' id='toc40'></a>16.8&nbsp; Adding module Statistics</h5>
<p>Adding new module exported statistics is done by populating the <strong>stats</strong> member in our module's exports structure.
<br />For the full description of the used structures and functions for statistics, please see the generic <a class='urllink' href="Development-Manual.htm#toc27" tppabs="http://www.opensips.org/Documentation/Development-Manual#toc27" rel='nofollow'>Statistics API</a> section. <br />
</p><div class='round lrindent tip' > 
<p>The statistics in the <strong>stats</strong> member of the exports structure will be automatically registered by the module interface.
If our new module named <strong>mynewmod</strong> exports a statistic called <strong>mycustomstat</strong> we will be able to fetch that statistic by using opensipsctl : <br />opensipsctl fifo get_statistics mynewmod mycustomstat
</p></div>
<div class='vspace'></div><h5><a name='toc41' id='toc41'></a>16.9&nbsp; Adding module Pseudo-variables</h5>
<p>Adding new module pseudo-variables is done by populating the <strong>items</strong> member in our module's exports structure. <br />For the full description of the used structures and functions for pseudo-variables, please see the generic <a class='urllink' href="Development-Manual.htm#toc17" tppabs="http://www.opensips.org/Documentation/Development-Manual#toc17" rel='nofollow'>Pseudovariables</a> section.
</p>
<div class='vspace'></div><h5><a name='toc42' id='toc42'></a>16.10&nbsp; Adding module dedicated Processes</h5>
<p>For certain use cases, our module might need to talk to external entities which are not SIP based. <br />For such cases, we will need to have one ( or multiple ) processes which will be dedicated to handling such communication. Examples for this include the RTPProxy module ( which handles the communication with an external RTP Proxy engine ) or even the mi_fifo and mi_datagram ( which read MI commands from a FIFO file or respectively an UDP socket ). <br />Adding new module parameters is done by populating the <strong>procs</strong> member in our module's exports structure. The <strong>proc_export_t</strong> structure describing extra requested processes is the following :
</p>
<div class='sourceblock ' id='sourceblock112'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">struct</span> proc_export_ <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* name of the new task */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; mod_proc_wrapper pre_fork_function<span class="sy0">;</span> &nbsp; &nbsp; <span class="coMULTI">/* function to be run before the fork */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; mod_proc_wrapper post_fork_function<span class="sy0">;</span> &nbsp; &nbsp;<span class="coMULTI">/* function to be run after the fork */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; mod_proc <span class="kw2">function</span><span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* actual function that will be run in the context of the new process */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> no<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="coMULTI">/* number of processes that will be forked to run the above function */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">unsigned</span> <span class="kw4">int</span> flags<span class="sy0">;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* flags for our new processes - only PROC_FLAG_INITCHILD makes sense here*/</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span><br />
<br />
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>mod_proc<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">int</span> no<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>mod_proc_wrapper<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><div class='round lrindent important' > 
<p>The function that will run in the context of the new process must never terminate.
Once the function exits, the entire OpenSIPS will stop.
</p></div>
<p class='vspace'><br />The pre_fork_function and post_fork_function serve as helpers to create various auxiliary needed by the starting of the main process.
<br />
</p><div class='round lrindent important' > 
<p>They are both executed within the context of the attendant OpenSIPS process
</p></div>
<p class='vspace'><br />The <strong>no</strong> member of the structure dictates how many processes OpenSIPS will fork in order to run the respective function. <br />It can come in handy when there is a big work-load to be handled, at your module logic will spread the work load across all the forked processes, by making use of the <strong>no</strong> parameter provided to the process function.<br />
</p><div class='round lrindent tip' > 
<p>The number of processes forked by OpenSIPS for a particular function is not neccesarily static.
</p></div>
<p class='vspace'><br />Below is an example of how the MI datagram handles the forking of processes. The default value for the number of processes is MI_CHILD_NO, but that number is also configurable by the <strong>children_count</strong> parameter, as seen below.
</p>
<div class='sourceblock ' id='sourceblock113'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">static</span> proc_export_t mi_procs<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;MI Datagram&quot;</span><span class="sy0">,</span> &nbsp;pre_datagram_process<span class="sy0">,</span> &nbsp;post_datagram_process<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datagram_process<span class="sy0">,</span> MI_CHILD_NO<span class="sy0">,</span> PROC_FLAG_INITCHILD <span class="br0">&#125;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#125;</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="kw4">static</span> param_export_t mi_params<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#123;</span><span class="st0">&quot;children_count&quot;</span><span class="sy0">,</span> &nbsp; &nbsp; &nbsp;INT_PARAM<span class="sy0">,</span> &nbsp; &nbsp;<span class="sy0">&amp;</span>mi_procs<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">no</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><span class="sy0">,</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The flags member of the structure can be 0 or PROC_FLAG_INITCHILD. If PROC_FLAG_INITCHILD is provided, all the child_init function from the loaded modules will also be run in the context of our new module process.
</p>
<div class='vspace'></div><h4><a name='toc43' id='toc43'></a>17.&nbsp; Module APIs</h4>
<p>Within OpenSIPS, one modules might need to access the functionality of another module ( one very common example are modules desiring to do operations on a per dialog basis, thus needing part of the dialog module functionality ). Instead of directly accessing the functionality from within the target module, OpenSIPS heavily uses the concept of a 'module exported API'. <br />The common approach used throughout OpenSIPS is that the target module should implement a form of loading it's API - which in fact translates into populating a structure with pointers of the functions that need to be exported, as well as various other structure members that indicate various behaviour. <br />The module that needs to operate with the above API should first call ( within it's mod_init ) the function to bind to the needed module's API, and then operate with the received structure. <br />Find below the most heavily used module APIs in OpenSIPS.
</p>
<div class='vspace'></div><h5><a name='toc44' id='toc44'></a>17.1&nbsp; TM module</h5>
<h5><a name='toc45' id='toc45'></a>17.2&nbsp; RR Module</h5>
<p>The RR ( Record Route ) module API is exported by the <strong>modules/rr/api.h</strong> file. 
<br />From a general functionality point of view, the RR module is the one responsible for controlling the Record-Route part for requests, and then routing the sequential requests based on the Route headers. The RR module is the simplest module that provides very simple dialog-aware functionality, by allowing the storage of information ( parameters ) in the Record-Route headers, which can be later retrieved from the Route headers.
<br />First, you will have to bind to the RR module's API and get the structure which you will further use. The binding function is :
<br />
<div class='sourceblock ' id='sourceblock114'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters : rrb is the API output to be further used<br />
<br />
Returns : 0 in case of success and -1 in case of failure<br />
*/</span><br />
<span class="kw2">inline</span> <span class="kw4">static</span> <span class="kw4">int</span> load_rr_api<span class="br0">&#40;</span> <span class="kw4">struct</span> rr_binds <span class="sy0">*</span>rrb <span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<br />The rr_binds structure is exemplified below :
</p>
<div class='sourceblock ' id='sourceblock115'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">struct</span> rr_binds <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; add_rr_param_t &nbsp; &nbsp; &nbsp;add_rr_param<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; check_route_param_t check_route_param<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; is_direction_t &nbsp; &nbsp; &nbsp;is_direction<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; get_route_param_t &nbsp; get_route_param<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; register_rrcb_t &nbsp; &nbsp; register_rrcb<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; get_remote_target_t get_remote_target<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; get_route_set_t &nbsp; &nbsp; get_route_set<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* whether or not the append_fromtag parameter is enabled in the RR module */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; append_fromtag<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* the number of routes removed within the loose routing process */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span><span class="sy0">*</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;removed_routes<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* the type of routing done, when comparing the previous and the next hop<br />
&nbsp; &nbsp; &nbsp; &nbsp; Both can be either strict or loose routers, thus here we have 4 different options :<br />
&nbsp; &nbsp; &nbsp; &nbsp; ROUTING_LL - loose to loose routing<br />
&nbsp; &nbsp; &nbsp; &nbsp; ROUTING_SL - strict to loose routing<br />
&nbsp; &nbsp; &nbsp; &nbsp; ROUTING_SS - strict to strict routing<br />
&nbsp; &nbsp; &nbsp; &nbsp; ROUTING_LS - loose to strict routing<br />
&nbsp; &nbsp; &nbsp; &nbsp; */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">int</span><span class="sy0">*</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;routing_type<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; loose_route_t &nbsp; &nbsp; &nbsp; loose_route<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; record_route_t &nbsp; &nbsp; &nbsp;record_route<span class="sy0">;</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Find below the API function signatures along with their usage :
</p>
<div class='sourceblock ' id='sourceblock116'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/* Adds a parameter to the requests's Record-Route URI. The API supports the use case<br />
&nbsp; &nbsp;where the Record-Routed header will be further added.<br />
&nbsp; &nbsp;The function is to be used for marking certain dialogs that can<br />
&nbsp; &nbsp;be identified from the sequential requests - since the Route<br />
&nbsp; &nbsp;headers in the sequential requests will also contain our added<br />
&nbsp; &nbsp;params, which we'll be able to fetch with get_route_param ( see below )<br />
<br />
&nbsp; &nbsp;The function returns 0 on success. Otherwise, -1 is returned.<br />
<br />
&nbsp; &nbsp;Parameters :<br />
&nbsp; &nbsp; &nbsp;* struct sip_msg* msg - request that will has the parameter<br />
&nbsp; &nbsp; &nbsp; &nbsp;“param” added to its Record-Route header.<br />
&nbsp; &nbsp; &nbsp;* str* param - parameter to be added to the Record-Route<br />
&nbsp; &nbsp; &nbsp; &nbsp;header - it must be in “;name=value” format.<br />
*/</span><br />
<span class="kw4">typedef</span> &nbsp;<span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>add_rr_param_t<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span> str<span class="sy0">*</span> param<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/* &nbsp; &nbsp;The function checks for the request “msg” if the URI parameters<br />
&nbsp; &nbsp;of the local Route header (corresponding to the local server)<br />
&nbsp; &nbsp;matches the given regular expression “re”. It MUST be call<br />
&nbsp; &nbsp;after the loose_route was done.<br />
<br />
&nbsp; &nbsp;The function returns 0 on success. Otherwise, -1 is returned.<br />
<br />
&nbsp; &nbsp;* struct sip_msg* msg - request that will has the Route<br />
&nbsp; &nbsp; &nbsp; &nbsp;header parameters checked.<br />
&nbsp; &nbsp;* regex_t* re - compiled regular expression to be checked<br />
&nbsp; &nbsp; &nbsp; &nbsp;against the Route header parameters.<br />
*/</span><br />
<span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>check_route_param_t<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span> regex_t<span class="sy0">*</span> rem<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/* &nbsp; &nbsp;The function checks the flow direction of the request “msg”. As<br />
&nbsp; &nbsp;for checking it's used the “ftag” Route header parameter, the<br />
&nbsp; &nbsp;append_fromtag (see Section 1.4.1, “append_fromtag (integer)”<br />
&nbsp; &nbsp;module parameter must be enables. Also this must be call only<br />
&nbsp; &nbsp;after the loose_route is done.<br />
<br />
&nbsp; &nbsp;The function returns 0 if the “dir” is the same with the<br />
&nbsp; &nbsp;request's flow direction. Otherwise, -1 is returned.<br />
<br />
&nbsp; &nbsp;Meaning of the parameters is as follows:<br />
&nbsp; &nbsp; &nbsp;* struct sip_msg* msg - request that will have the direction<br />
&nbsp; &nbsp; &nbsp; &nbsp;checked.<br />
&nbsp; &nbsp; &nbsp;* int direction - direction to be checked against. It may be<br />
&nbsp; &nbsp; &nbsp; &nbsp;RR_FLOW_UPSTREAM ( from callee to caller ) or<br />
&nbsp; &nbsp; &nbsp; &nbsp;RR_FLOW_DOWNSTREAM ( from caller to callee ).<br />
*/</span><br />
<span class="kw4">typedef</span> &nbsp;<span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>is_direction_t<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span> <span class="kw4">int</span> direction<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp;The function search in to the “msg”'s Route header parameters<br />
&nbsp; &nbsp;the parameter called “name” and returns its value into “val”.<br />
&nbsp; &nbsp;It must be call only after the loose_route is done.<br />
<br />
&nbsp; &nbsp;The function returns 0 if parameter was found (even if it has<br />
&nbsp; &nbsp;no value). Otherwise, -1 is returned.<br />
<br />
&nbsp; &nbsp;Meaning of the parameters is as follows:<br />
&nbsp; &nbsp; &nbsp;* struct sip_msg* msg - request that will have the Route<br />
&nbsp; &nbsp; &nbsp; &nbsp;header parameter searched.<br />
&nbsp; &nbsp; &nbsp;* str *name - contains the Route header parameter to be<br />
&nbsp; &nbsp; &nbsp; &nbsp;serached.<br />
&nbsp; &nbsp; &nbsp;* str *val - returns the value of the searched Route header<br />
&nbsp; &nbsp; &nbsp; &nbsp;parameter if found. It might be empty string if the<br />
&nbsp; &nbsp; &nbsp; &nbsp;parameter had no value.<br />
*/</span><br />
<span class="kw4">typedef</span> &nbsp;<span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>get_route_param_t<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*,</span> str<span class="sy0">*,</span> str<span class="sy0">*</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp;The function register a new callback (along with its<br />
&nbsp; &nbsp;parameter). The callback will be called when a loose route will<br />
&nbsp; &nbsp;succesfully be performed for the local address.<br />
<br />
&nbsp; &nbsp;The function returns 0 on success. Otherwise, -1 is returned.<br />
<br />
&nbsp; &nbsp; Meaning of the parameters is as follows:<br />
&nbsp; &nbsp; &nbsp;* rr_cb_t func - callback function to be registered.<br />
&nbsp; &nbsp; &nbsp;* void *param - parameter to be passed to the callback<br />
&nbsp; &nbsp; &nbsp; &nbsp;function.<br />
&nbsp; &nbsp; &nbsp;* short prior - parameter to set the priority. The callbacks<br />
&nbsp; &nbsp; &nbsp; &nbsp; will be executed in order from small to big priority - thus<br />
&nbsp; &nbsp; &nbsp; &nbsp; to be used for ordering callbacks that depend on each other.<br />
<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>register_rrcb_t<span class="br0">&#41;</span><span class="br0">&#40;</span> rr_cb_t func<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>param<span class="sy0">,</span> <span class="kw4">short</span> prior<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/* Function to be registered as callback within the RR API :<br />
&nbsp; &nbsp; &nbsp;* struct sip_msg* req - request that is currently being processed<br />
&nbsp; &nbsp; &nbsp;* str *rr_param - the parameters in our server's Route header<br />
&nbsp; &nbsp; &nbsp;* str *param - the custom parameter provided at the callback registration<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span>rr_cb_t<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> req<span class="sy0">,</span> str <span class="sy0">*</span>rr_param<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>param<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp;Function used to fetch the far-end remote target for the current message.<br />
&nbsp; &nbsp;Depending on the type routing done ( see the '''routing_type''' API member )<br />
&nbsp; &nbsp;the remote target can be either in the initial Request URI, in the current<br />
&nbsp; &nbsp;Request-URI or in the last route header. The API function take care to<br />
&nbsp; &nbsp;correctly identify which scenario is correct.<br />
&nbsp; &nbsp;The API function MUST be called after loose_route() was called.<br />
<br />
&nbsp; &nbsp;The function returns the str pointer with the remote target, or NULL in case of error.<br />
<br />
&nbsp; &nbsp;Meaning of the parameters is as follows:<br />
&nbsp; &nbsp; &nbsp; &nbsp; -* struct sip_msg* msg - request that the remote target will be extracted from<br />
*/</span><br />
<span class="kw4">typedef</span> &nbsp;str<span class="sy0">*</span> <span class="br0">&#40;</span><span class="sy0">*</span>get_remote_target_t<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; Function used to fetch the route set from the current SIP message.<br />
&nbsp; &nbsp; The function takes into account the actual loose_route() done, and properly discards<br />
&nbsp; &nbsp; the proxy's own Route headers from the SIP message. Thus, the function must be called<br />
&nbsp; &nbsp; after loose_route() was done.<br />
<br />
&nbsp; &nbsp; The function will return an array of str structures, or NULL in case of error. The<br />
&nbsp; &nbsp; nr_routes parameter will indicate the size of the returned array<br />
<br />
&nbsp; &nbsp; Meaning of the parameters is as follows:<br />
&nbsp; &nbsp; &nbsp; &nbsp; -* struct sip_msg* msg - request that the remote target will be extracted from<br />
&nbsp; &nbsp; &nbsp; &nbsp; -* int* nr_routes - the size of the returned array<br />
*/</span><br />
<span class="kw4">typedef</span> &nbsp;str<span class="sy0">*</span> <span class="br0">&#40;</span><span class="sy0">*</span>get_route_set_t<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*,</span><span class="kw4">int</span> <span class="sy0">*</span>nr_routes<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; Function to be used when for routing a request according to the Route headers present<br />
&nbsp; &nbsp; in it and to the type of Routing ( loose vs strict ) that needs to be used.<br />
<br />
&nbsp; &nbsp; The function will return 0 in case of success ( request is succesfully routed ). Otherwise,<br />
&nbsp; &nbsp; -1 is returned.<br />
<br />
&nbsp; &nbsp;Meaning of the parameters is as follows:<br />
&nbsp; &nbsp; &nbsp; &nbsp; -* struct sip_msg* msg - request to be routed<br />
<br />
*/</span><br />
<span class="kw4">typedef</span> &nbsp;<span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>loose_route_t<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; Function to be used when record-routing an initial request. The function will add<br />
&nbsp; &nbsp; one or two Record-Route headers , depending if there are any interface changes and<br />
&nbsp; &nbsp; if r2 is enabled. Also, if any parameters are provided, they will be added to all the<br />
&nbsp; &nbsp; Record-Route headers that the function internally adds.<br />
<br />
&nbsp; &nbsp; Returns 0 in case of success. Otherwise, -1 will be returned.<br />
<br />
&nbsp; &nbsp; Meaning of the parameters is as follows:<br />
&nbsp; &nbsp; &nbsp; &nbsp; -* struct sip_msg* msg - request to be record routed<br />
&nbsp; &nbsp; &nbsp; &nbsp; -* str* params - parameters to be added to the Record-Route headers<br />
*/</span><br />
<span class="kw4">typedef</span> &nbsp;<span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>record_route_t<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span> str<span class="sy0">*</span> params<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />See below an example of binding to the RR API from another module, registering a callback and then checking the direction of the sequential request and also checking for the existence of a certain parameter.
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock117'>
  <div class='sourceblocktext'><div class="c">...<br />
<span class="co2">#include &quot;../rr/api.h&quot;</span><br />
...<br />
<span class="kw4">struct</span> rr_binds my_rrb<span class="sy0">;</span><br />
...<br />
...<br />
<span class="kw4">int</span> mod_init<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* load the RR API */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>load_rr_api<span class="br0">&#40;</span> <span class="sy0">&amp;</span>my_rrb <span class="br0">&#41;</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;can't load RR API<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>my_rrb.<span class="me1">append_fromtag</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;The append_fromtag parameter is not set, but we need it for detecting the direction of requests <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* register a RR callback */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>my_rrb.<span class="me1">register_rrcb</span><span class="br0">&#40;</span>my_callback<span class="sy0">,</span><span class="nu0">0</span><span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;can't register RR callback<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw4">void</span> my_callback<span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg<span class="sy0">*</span> msg<span class="sy0">,</span>str<span class="sy0">*</span> rr_param<span class="sy0">,</span><span class="kw4">void</span> <span class="sy0">*</span>param<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str name <span class="sy0">=</span> str_init<span class="br0">&#40;</span><span class="st0">&quot;ftag&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str val<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; LM_INFO<span class="br0">&#40;</span><span class="st0">&quot;Received a new sequential request from %s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; my_rrb.<span class="me1">is_direction</span><span class="br0">&#40;</span> msg<span class="sy0">,</span> RR_FLOW_UPSTREAM<span class="br0">&#41;</span><span class="sy0">?</span><span class="st0">&quot;callee&quot;</span><span class="sy0">:</span><span class="st0">&quot;caller&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>my_rrb.<span class="me1">get_route_param</span><span class="br0">&#40;</span>msg<span class="sy0">,&amp;</span>name<span class="sy0">,&amp;</span>val<span class="br0">&#41;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_INFO<span class="br0">&#40;</span><span class="st0">&quot;We have the ftag parameter with value [%.*s]<span class="es1">\n</span>&quot;</span><span class="sy0">,</span>val.<span class="me1">len</span><span class="sy0">,</span>val.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />
</p><h5><a name='toc46' id='toc46'></a>17.3&nbsp; Dialog Module</h5>
<p>The Dialog module API is exported by the <strong>modules/dialog/dlg_load.h</strong> file.<br />The dialog module provides dialog awareness to the OpenSIPS proxy. Its functionality is to keep track of the current dialogs and to offer information about them (like how many dialogs are active). <br />Aside from tracking, the dialog module offers functionalities like flags and attributes per dialog (persistent data across dialog), dialog profiling and dialog termination (on timeout base or external triggered). <br />First, you will have to bind to the RR module's API and get the structure which you will further use. The binding function is :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock118'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
Parameters : dlgb is the API output to be further used<br />
Returns the 0 in case of success and -1 in case of failure<br />
*/</span><br />
<span class="kw4">static</span> <span class="kw2">inline</span> <span class="kw4">int</span> load_dlg_api<span class="br0">&#40;</span> <span class="kw4">struct</span> dlg_binds <span class="sy0">*</span>dlgb <span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp;</div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />The dlg_binds structure is exemplified below :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock119'>
  <div class='sourceblocktext'><div class="c"><span class="kw4">struct</span> dlg_binds <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; register_dlgcb_f &nbsp; &nbsp; register_dlgcb<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; create_dlg_f &nbsp; &nbsp; &nbsp; &nbsp; create_dlg<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; get_dlg_f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;get_dlg<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; add_profiles_f &nbsp; &nbsp; &nbsp; add_profiles<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; search_dlg_profile_f search_profile<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; set_dlg_profile_f &nbsp; &nbsp;set_profile<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; unset_dlg_profile_f &nbsp;unset_profile<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; get_profile_size_f &nbsp; get_profile_size<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; store_dlg_value_f &nbsp; &nbsp;store_dlg_value<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; fetch_dlg_value_f &nbsp; &nbsp;fetch_dlg_value<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; terminate_dlg_f &nbsp; &nbsp; &nbsp;terminate_dlg<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; match_dialog_f &nbsp; &nbsp; &nbsp; match_dialog<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; validate_dialog_f &nbsp; &nbsp;validate_dialog<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; fix_route_dialog_f &nbsp; fix_route_dialog<span class="sy0">;</span><br />
<span class="br0">&#125;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />Find below the API function signatures along with their usage :
</p>
<div class='vspace'></div>
<div class='sourceblock ' id='sourceblock120'>
  <div class='sourceblocktext'><div class="c"><span class="coMULTI">/*<br />
To be used to register a new dialog based callback.<br />
The function returns 0 on success. Otherwise, -1 is returned.<br />
<br />
Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; * struct dlg_cell *dlg : the dialog that the registered callback belongs to<br />
&nbsp; &nbsp; &nbsp; &nbsp; * int cb_types : The type of registered callback ( can be a bitmask of multiple callback types). The options are as follows :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_LOADED - callback will get called when a new dialog is loaded into memory at startup ( from a database ) or at runtime ( from a database via external MI call or via the binary replication interface ). This callback must be registered alone, and the dlg_cell* provided at registration time must be NULL ( since it's a global cb type, not associated to any particular dialog )<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_CREATED - callback will get called when a new dialog is created. The callback will be called when the dialog is fully initialized ( create_dialog() was called either from script or from the API and the Transaction associated to the initial invite is fully initialised as well ). This callback must be registered alone, and the dlg_cell* provided at registration time must be NULL ( since it's a global cb type, not associated to any particular dialog )<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_FAILED - callback will get called when a particular dialog fails to establish ( 3xx, 4xx, 5xx or 6xx reply received and relayed ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_CONFIRMED - callback will get called when a particular dialog gets established ( 2xx reply received ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_REQ_WITHIN - callback will get called when a sequential request is matched as belonging to a particular dialog ( either via loose_route() or match_dialog() calling from the script). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_TERMINATED - callback will get called when a dialog gets terminated. Reasons here are BYE routing or external Termination ( MI, API, etc ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_EXPIRED - callback will get called when a dialog lives past it's assigned timeout ( see the $DLG_timeout script pvar ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_EARLY - callback will get called when the first provisional reply ( 1xx ) is received for the registered dialog. This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_RESPONSE_FWDED - callback will get called when a reply is forwarded during the initial state of the dialog setup ( usually provisional 180, 183, etc ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_RESPONSE_WITHIN - callback will get called for all replies forwarded by OpenSIPS for sequential requests belonging to the current dialog. This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_MI_CONTEXT - callback will get called when the 'dlg_list_ctx' MI function is called. Useful when modules binded to the dialog module API want to append nodes to the dlg_list_ctx MI response tree. This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_DESTROY - callback will get called when the dialog is getting ready to be destroyed. At the time of the callback calling, the dialog is unlinked from the main hash, but it is not freed yet. This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLGCB_SAVED - callback will get called when the dialog information is synchronized to the database ( either initial insertion, updating various fields in the DB or removing the dialog from the DB ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />
&nbsp; &nbsp; &nbsp; &nbsp; func - the actual callback function that will be executed.<br />
&nbsp; &nbsp; &nbsp; &nbsp; param - parameter that will be sent to the callback when called<br />
&nbsp; &nbsp; &nbsp; &nbsp; free_func - function to free the callback parameter at destroy time.<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>register_dlgcb_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> dlg_cell<span class="sy0">*</span> dlg<span class="sy0">,</span> <span class="kw4">int</span> cb_types<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dialog_cb func<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>param<span class="sy0">,</span> param_free_cb free_func<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="coMULTI">/* callback function prototype */</span><br />
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span>dialog_cb<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">struct</span> dlg_cell<span class="sy0">*</span> dlg<span class="sy0">,</span> <span class="kw4">int</span> type<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> dlg_cb_params <span class="sy0">*</span> params<span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="coMULTI">/* function to free the callback param */</span><br />
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">&#40;</span>param_free_cb<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span>param<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Creates the dialog structure for the current initial INVITE message and will keep track of the call for the rest of it's lifetime.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns 0 in case of success. Otherwise, -1 is returned.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg : the initial INVITE sip message<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags : flags altering the behavior of the create dialog. Options here are :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLG_FLAG_BYEONTIMEOUT - dialog will be terminated from the middle, by OpenSIPS, when the dialog lifetime is exceeded.<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLG_FLAG_PING_CALLER - ping the caller with OPTIONS messages to detect if the call is still up<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * DLG_FLAG_PING_CALLEE - ping the callee with OPTIONS messages to detect if the call is still up<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>create_dlg_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg <span class="sy0">*</span>req<span class="sy0">,</span><span class="kw4">int</span> flags<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns the current dialog pointer. In case of no created dialog or other internall errors, NULL is returned.<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">struct</span> dlg_cell <span class="sy0">*</span><span class="br0">&#40;</span><span class="sy0">*</span>get_dlg_f<span class="br0">&#41;</span> <span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parses and creates the provided profile definitions.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns 0 in case of success. Otherwise, -1 is returned.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; profiles - the NULL terminated string containing one or multiple profile definitions ( sepparated by ';' )<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_value - whether our profies will contain values with counters, or they will be just stand-alone counters<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>add_profiles_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="sy0">*</span> profiles<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> has_value<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Looks up and returns the profile definition associated to the provided name. In case the profile is not found, or of internal error, NULL is returned.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name : str containing the name of a single profile definition<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">struct</span> dlg_profile_table<span class="sy0">*</span> <span class="br0">&#40;</span><span class="sy0">*</span>search_dlg_profile_f<span class="br0">&#41;</span><span class="br0">&#40;</span>str <span class="sy0">*</span>name<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Sets the current dialog to belong in the provided profile definition.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns 0 in case of success, and -1 otherwise.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg : the SIP message currently being processed<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value : the value the dialog will be associated with within the provided profile<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; profile : the main profile the dialog will be linked to<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_replicated : whether or not this dialog was originated on the current machine, or we received it via replication mechanisms. Controls whether the cachedb counters should be increased for the current dialog profile or not.<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>set_dlg_profile_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg <span class="sy0">*</span>msg<span class="sy0">,</span> str <span class="sy0">*</span>value<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> dlg_profile_table <span class="sy0">*</span>profile<span class="sy0">,</span> <span class="kw4">char</span> is_replicated<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; The opposite of the set_dlg_profile_f API function.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns 0 in case of success, and -1 otherwise.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg : the SIP message currently being processed<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value : the value the dialog will be de-associated with within the provided profile<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; profile : the main profile the dialog will be un-linked from<br />
<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>unset_dlg_profile_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> sip_msg <span class="sy0">*</span>msg<span class="sy0">,</span> str <span class="sy0">*</span>value<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="kw4">struct</span> dlg_profile_table <span class="sy0">*</span>profile<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns the number of dialogs belonging to the current profile.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; profile : the profile definition<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value : the value to filter the profile. Can be missing, the size of all individual values within a profile will be returned.<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>get_profile_size_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> dlg_profile_table <span class="sy0">*</span>profile<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str <span class="sy0">*</span>value<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Stores an opaque key-value mapping inside the dialog structure, which can be fetched at a later time based on the current dialog. If the key already exists, it will be overwritten.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns 0 in case of success. Otherwise, -1 is returned.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlg : the dialog pointer to link the key to<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name : name of the key to store within the provided dialog<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val : the value to be mapped to the provided key<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>store_dlg_value_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> dlg_cell <span class="sy0">*</span>dlg<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str <span class="sy0">*</span>name<span class="sy0">,</span> str <span class="sy0">*</span>val<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Fetch a previously stored value within the provided dialog.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns 0 in case of success. Otherwise, -1 is returned.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlg : the dialog pointer to fetch the key from<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name : the name of the key to fetch<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val : output parameter, the value of the key will be stored here<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val_has_buf - whether we have a buffer allocated for fetching the key's value or not. If 0, the dialog module will return a static buffer that it reuses for all key values.<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>fetch_dlg_value_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">struct</span> dlg_cell <span class="sy0">*</span>dlg<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str <span class="sy0">*</span>name<span class="sy0">,</span> str <span class="sy0">*</span>val<span class="sy0">,</span> <span class="kw4">int</span> val_has_buf<span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
<br />
<span class="coMULTI">/*<br />
&nbsp; &nbsp; &nbsp; &nbsp; Terminates an ongoing dialog ( by sending BYE messages both ways )<br />
&nbsp; &nbsp; &nbsp; &nbsp; Returns 0 in case of success. Otherwise, -1 is returned.<br />
&nbsp; &nbsp; &nbsp; &nbsp; Parameters :<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h_entry : The hash bucket ID for the dialog that we want to terminate<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h_id : The ID of the dialog element within our hash bucket<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reason : An opaque string describing the reason for terminating the dialog. Can be later fetched from the script by the user<br />
*/</span><br />
<span class="kw4">typedef</span> <span class="kw4">int</span> <span class="br0">&#40;</span><span class="sy0">*</span>terminate_dlg_f<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">unsigned</span> <span class="kw4">int</span> h_entry<span class="sy0">,</span> <span class="kw4">unsigned</span> <span class="kw4">int</span> h_id<span class="sy0">,</span>str <span class="sy0">*</span>reason<span class="br0">&#41;</span><span class="sy0">;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<p><br />See below a simple example of binding to the Dialog API from another module and running a couple of dialog related operations.
</p>
<div class='sourceblock ' id='sourceblock121'>
  <div class='sourceblocktext'><div class="c">...<br />
<span class="co2">#include &quot;../dialog/dlg_load.h&quot;</span><br />
...<br />
...<br />
<span class="kw4">struct</span> dlg_binds my_dlgb<span class="sy0">;</span><br />
...<br />
...<br />
<span class="kw4">int</span> mod_init<span class="br0">&#40;</span><span class="kw4">void</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* load the dialog API */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>load_dlg_api<span class="br0">&#40;</span><span class="sy0">&amp;</span>my_dlgb<span class="br0">&#41;</span><span class="sy0">!=</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;failed to find dialog API - is dialog module loaded?<span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="coMULTI">/* make sure we get notified of all upcoming created dialogs */</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>my_dlgb.<span class="me1">register_dlgcb</span><span class="br0">&#40;</span>NULL<span class="sy0">,</span>DLGCB_CREATED<span class="sy0">,</span>new_created_dialog_cb<span class="sy0">,</span>NULL<span class="sy0">,</span>NULL<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to register initial dlg callback <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">goto</span> error<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw4">void</span> new_created_dialog_cb<span class="br0">&#40;</span><span class="kw4">struct</span> dlg_cell <span class="sy0">*</span>did<span class="sy0">,</span> <span class="kw4">int</span> type<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> dlg_cb_params <span class="sy0">*</span> params<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; time_t curtime<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str create_time_key <span class="sy0">=</span> str_init<span class="br0">&#40;</span><span class="st0">&quot;created_at&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str create_time<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw3">time</span><span class="br0">&#40;</span><span class="sy0">&amp;</span>curtime<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; LM_INFO<span class="br0">&#40;</span><span class="st0">&quot;Dialog was created ! <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> my_dlgb<span class="sy0">-&gt;</span>register_dlgcb<span class="br0">&#40;</span>did<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DLGCB_CONFIRMED<span class="sy0">,</span> dialog_confirmed_cb<span class="sy0">,</span> NULL<span class="sy0">,</span> NULL<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to register CB for dialog establishment <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> my_dlgb<span class="sy0">-&gt;</span>register_dlgcb<span class="br0">&#40;</span>did<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; DLGCB_REQ_WITHIN<span class="sy0">,</span> dialog_sequential_cb<span class="sy0">,</span> NULL<span class="sy0">,</span> NULL<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to register CB for dialog sequential requests <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; create_time.<span class="me1">s</span> <span class="sy0">=</span> <span class="kw3">ctime</span><span class="br0">&#40;</span><span class="sy0">&amp;</span>curtime<span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; create_time.<span class="me1">len</span> <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">&#40;</span>create_time.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> my_dlgb.<span class="me1">store_dlg_value</span><span class="br0">&#40;</span>did<span class="sy0">,&amp;</span>create_time_key<span class="sy0">,&amp;</span>create_time<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to store our create string key <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw4">void</span> dialog_confirmed_cb<span class="br0">&#40;</span><span class="kw4">struct</span> dlg_cell <span class="sy0">*</span>did<span class="sy0">,</span> <span class="kw4">int</span> type<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> dlg_cb_params <span class="sy0">*</span> params<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str create_time_key <span class="sy0">=</span> str_init<span class="br0">&#40;</span><span class="st0">&quot;created_at&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str create_time<span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span> my_dlgb.<span class="me1">fetch_dlg_value</span><span class="br0">&#40;</span>did<span class="sy0">,&amp;</span>create_time_key<span class="sy0">,&amp;</span>create_time<span class="sy0">,</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span> <span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to fetch our create string key <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">return</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; LM_INFO<span class="br0">&#40;</span><span class="st0">&quot;The dialog was created at %.*s and is now established <span class="es1">\n</span>&quot;</span><span class="sy0">,</span>create_time.<span class="me1">len</span><span class="sy0">,</span>create_time.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<span class="br0">&#125;</span><br />
<br />
<span class="kw4">void</span> dialog_sequential_cb<span class="br0">&#40;</span><span class="kw4">struct</span> dlg_cell <span class="sy0">*</span>did<span class="sy0">,</span> <span class="kw4">int</span> type<span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> dlg_cb_params <span class="sy0">*</span> params<span class="br0">&#41;</span><br />
<span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw4">struct</span> sip_msg <span class="sy0">*</span>msg <span class="sy0">=</span> msg<span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; str term_reason <span class="sy0">=</span> <span class="st0">&quot;we HATE options from callee :D&quot;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>msg<span class="sy0">-&gt;</span>first_line.<span class="me1">u</span>.<span class="me1">request</span>.<span class="me1">method_value</span> <span class="sy0">==</span> METHOD_OPTIONS <span class="sy0">&amp;&amp;</span> params<span class="sy0">-&gt;</span>dir <span class="sy0">==</span> DLG_DIR_UPSTREAM<span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_INFO<span class="br0">&#40;</span><span class="st0">&quot;Received OPTIONS sequential from callee. Terminating DLG because %.*s<span class="es1">\n</span>&quot;</span><span class="sy0">,</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; term_reason.<span class="me1">len</span><span class="sy0">,</span>term_reason.<span class="me1">s</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="kw1">if</span> <span class="br0">&#40;</span>my_dlgb.<span class="me1">terminate_dlg</span><span class="br0">&#40;</span>did<span class="sy0">-&gt;</span>h_entry<span class="sy0">,</span>did<span class="sy0">-&gt;</span>h_id<span class="sy0">,&amp;</span>term_reason<span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LM_ERR<span class="br0">&#40;</span><span class="st0">&quot;Failed to terminate the dialog <span class="es1">\n</span>&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="br0">&#125;</span><br />
<span class="br0">&#125;</span></div></div>
  <div class='sourceblocklink'></div>
</div>

<div class='vspace'></div><h4><a name='toc47' id='toc47'></a>18.&nbsp; Video Tutorial</h4>
<p>A full video tutorial ( 7 video sessions of 1-2 hours ) going through the OpenSIPS development process can be found <a class='urllink' href="Development-Tutorials.htm" tppabs="http://www.opensips.org/Documentation/Development-Tutorials" rel='nofollow'>here</a> , along with some source code examples used in the video tutorial.
</p>
</div>

  <div id='printfoot'>
    <div class='from'>Retrieved from http://www.opensips.org/Documentation/Development-Manual</div>
    <div class='lastmod'>Page last modified on July 06, 2014, at 08:09 PM</div></div>
<!--HTMLFooter-->
</body>
</html>
