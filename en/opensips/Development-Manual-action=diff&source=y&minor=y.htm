<!DOCTYPE html 
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <title>openSIPS | Documentation / Development-Manual | History</title>
  <meta http-equiv='Content-Style-Type' content='text/css' />
  <link rel='stylesheet' href="opensips.css" tppabs="http://www.opensips.org/pub/skins/opensips/opensips.css" type='text/css' />
  <!--HTMLHeader--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
span.anchor {
	float: left;
	font-size: 10px;
	margin-left: -10px;
	width: 10px;
    position:relative; top:-0.1em;
	text-align: center;
}
span.anchor a { text-decoration: none; }
span.anchor a:hover { text-decoration: underline; }
ol.toc { text-indent:-20px; list-style: none; }
ol.toc ol.toc { text-indent:-40px; }
div.tocfloat { font-size: smaller; margin-bottom: 10px;
    border-top: 1px dotted #555555; border-bottom: 1px dotted #555555;
    padding-top: 5px; padding-bottom: 5px; 
    width: 38%; float: right; margin-left: 10px; clear: right;
    margin-right:-13px; padding-right: 13px; padding-left: 13px;
    background-color: #eeeeee; }
div.toc { font-size: smaller; 
    padding: 4px; border: 1px dotted #cccccc;
    background: #f7f7f7;
    margin-bottom: 10px; }
  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
  .editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  .diffbox { width:570px; border-left:1px #999999 solid; margin-top:1.33em; }
  .diffauthor { font-weight:bold; }
  .diffchangesum { font-weight:bold; }
  .difftime { font-family:verdana,sans-serif; font-size:66%; 
    background-color:#dddddd; }
  .difftype { clear:both; font-family:verdana,sans-serif; 
    font-size:66%; font-weight:bold; }
  .diffadd { border-left:5px #99ff99 solid; padding-left:5px; }
  .diffdel { border-left:5px #ffff99 solid; padding-left:5px; }
  .diffrestore { clear:both; font-family:verdana,sans-serif; 
    font-size:66%; margin:1.5em 0px; }
  .diffmarkup { font-family:monospace; }  
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style><script type="text/javascript">
function toggle(obj) {
    var elstyle = document.getElementById(obj).style;
    var text    = document.getElementById(obj + "tog");
    if (elstyle.display == 'none') {
        elstyle.display = 'block';
        text.innerHTML = "hide";
    } else {
        elstyle.display = 'none';
        text.innerHTML = "show";
    }
}
</script>
  <link href="commentboxplus.css" tppabs="http://www.opensips.org/pub/commentboxplus/commentboxplus.css" rel='stylesheet' type='text/css' />
  <link rel='stylesheet' href="wsplus.css" tppabs="http://www.opensips.org/pub/wsplus/wsplus.css" 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url("csshover.htc")/*tpa=http://www.opensips.org/pub/wsplus/csshover.htc*/; }
    .rollover * { visibility: visible; }
  </style><![endif]-->
  <meta name='robots' content='noindex,nofollow' />

  <link rel="icon" type="image/png" href="http://opensips.org/favicon.png">
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','analytics.js'/*tpa=http://www.google-analytics.com/analytics.js*/,'ga');

  ga('create', 'UA-47615177-1', 'http://www.opensips.org/Documentation/opensips.org');
  ga('send', 'pageview');

	function resizeIframe(obj) {
	    obj.style.height = obj.contentWindow.document.body.scrollHeight + 'px';
		  }

  </script>

</head>
<body>
<div id="main">
<!--PageHeaderFmt-->
  <div id='wikilogo'>
  <img class="motto" src="motto.jpg" tppabs="http://www.opensips.org/pub/skins/opensips/images/motto.jpg" width="328" height="40" alt="The new breed of communication engine.">
  <a href="javascript:if(confirm(%27http://www.opensips.org/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/%27" tppabs="http://www.opensips.org/"><img class="logo" src="logo2.jpg" tppabs="http://www.opensips.org/pub/skins/opensips/images/logo2.jpg"
    alt='openSIPS' border='0' /></a>
 </div>
 <div id='wikihead'>
 <table border=0>
  <tr valign=top><td width=250>
   
  </td></tr>
  <tr><td width=250>
   <form action="http://www.opensips.org/">
   
    <input type='hidden' name='n' value='Documentation.Development-Manual' />
    <input type='hidden' name='action' value='search' />

    <input type='text' name='q' id='formsubmit' value='' class='inputbox searchbox' />
	<input type='submit' id='formbutton' class='inputbutton searchbutton' value=' ' /></form>
  </td></tr>
  </table>
 </div>

<!--/PageHeaderFmt-->
<div id="osTopNav" >
	<div id="osTopNavLeft">
	</div>

	<div id="osTopNavRight">
	</div>

	<ul id="osTopNavList">
		<li>
			<a href="javascript:if(confirm(%27http://www.opensips.org/About/About  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/About/About%27" tppabs="http://www.opensips.org/About/About" title="About">About</a>
		</li>
		<li>
			<a href="javascript:if(confirm(%27http://www.opensips.org/Downloads/Downloads  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Downloads/Downloads%27" tppabs="http://www.opensips.org/Downloads/Downloads" title="Download">Downloads</a>
		</li>
		<li>
			<a href="Manuals.htm" tppabs="http://www.opensips.org/Documentation/Manuals" title="Documentation">Documentation</a>
		</li>
		<li>
			<a href="javascript:if(confirm(%27http://www.opensips.org/Community/Foundation-Main  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Community/Foundation-Main%27" tppabs="http://www.opensips.org/Community/Foundation-Main" title="Community">Community</a>
		</li>
		<li>
			<a href="javascript:if(confirm(%27http://www.opensips.org/Development/Development  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Development/Development%27" tppabs="http://www.opensips.org/Development/Development" title="Development">Development</a>
		</li>
		<li>
			<a href="javascript:if(confirm(%27http://www.opensips.org/Support/Contact  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Support/Contact%27" tppabs="http://www.opensips.org/Support/Contact" title="Support">Support</a>
		</li>
	</ul>
</div>
<!--PageMenuFmt-->
<!--/PageMenuFmt-->
  <table width='100%' align="center" cellpadding='0' cellspacing='0' id='wikimid'>
    <tr>
<!--PageLeftFmt-->
      <td valign='top' bgcolor="#E2F8DA" id='wikileft'>
        <p class='sidehead'> <span  style='color: #185662;'> Documentation</span>
</p><ul><li><a class='wikilink' title='Manuals' href="Manuals.htm" tppabs="http://www.opensips.org/Documentation/Manuals">Manuals</a>
</li><li><a class='wikilink' title='Tutorials' href="Tutorials.htm" tppabs="http://www.opensips.org/Documentation/Tutorials">Advanced Tutorials</a>
</li><li><a class='wikilink' title='TipsFAQ' href="TipsFAQ.htm" tppabs="http://www.opensips.org/Documentation/TipsFAQ">Tips &amp; FAQ</a>
</li><li><a class='wikilink' title='Migration' href="Migration.htm" tppabs="http://www.opensips.org/Documentation/Migration">Version Migration</a>
</li><li><a class='wikilink' title='Webinars' href="Webinars.htm" tppabs="http://www.opensips.org/Documentation/Webinars">OpenSIPS Webinars</a>
</li><li><a class='wikilink' title='Troubleshooting' href="Troubleshooting.htm" tppabs="http://www.opensips.org/Documentation/Troubleshooting">Troubleshooting</a>
</li><li><a class='wikilink' title='Tools' href="Tools.htm" tppabs="http://www.opensips.org/Documentation/Tools">OpenSIPS Tools</a>
</li><li><a class='wikilink' title='Development-Tutorials' href="Development-Tutorials.htm" tppabs="http://www.opensips.org/Documentation/Development-Tutorials">Devel Tutorial</a>
</li></ul><div class='vspace'></div>
</td>
<!--/PageLeftFmt-->
      <td id='wikibody' valign='top'>
<!--PageTitleFmt-->
        
<!--PageText-->
<div id='wikitext'>
<h2 class='wikiaction'>Documentation.Development-Manual History</h2>
  <p><a href="Development-Manual-action=diff&source=y&minor=n.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=diff&source=y&minor=n">Hide minor edits</a> - <a href="Development-Manual-action=diff&source=n&minor=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=diff&source=n&minor=y">Show changes to output</a></p>
  <div id='wikidiff'>
      <div class='diffbox'><div class='difftime'>July 06, 2014, at 08:09 PM 
        by <span class='diffauthor' title='213.233.84.73'>213.233.84.73</span> - </div>
        <div class='difftype'>Added lines 2980-3251:</div>
        <div class='diffadd'><div class='diffmarkup'><br />The Dialog module API is exported by the '''modules/dialog/dlg_load.h''' file.\\<br />The dialog module provides dialog awareness to the OpenSIPS proxy. Its functionality is to keep track of the current dialogs and to offer information about them (like how many dialogs are active). \\<br />Aside from tracking, the dialog module offers functionalities like flags and attributes per dialog (persistent data across dialog), dialog profiling and dialog termination (on timeout base or external triggered). \\<br />First, you will have to bind to the RR module's API and get the structure which you will further use. The binding function is :<br /><br />(:source lang=C -link -getcode :)<br />/*<br />Parameters : dlgb is the API output to be further used<br />Returns the 0 in case of success and -1 in case of failure<br />*/<br />static inline int load_dlg_api( struct dlg_binds *dlgb );<br /><br />(:sourceend:)<br />\\<br />The dlg_binds structure is exemplified below :<br /><br />(:source lang=C -link -getcode :)<br />struct dlg_binds {<br />        register_dlgcb_f     register_dlgcb;<br />        create_dlg_f         create_dlg;<br />        get_dlg_f            get_dlg;<br />        add_profiles_f       add_profiles;<br />        search_dlg_profile_f search_profile;<br />        set_dlg_profile_f    set_profile;<br />        unset_dlg_profile_f  unset_profile;<br />        get_profile_size_f   get_profile_size;<br />        store_dlg_value_f    store_dlg_value;<br />        fetch_dlg_value_f    fetch_dlg_value;<br />        terminate_dlg_f      terminate_dlg;<br /><br />        match_dialog_f       match_dialog;<br />        validate_dialog_f    validate_dialog;<br />        fix_route_dialog_f   fix_route_dialog;<br />};<br />(:sourceend:)<br />\\<br />Find below the API function signatures along with their usage :<br /><br />(:source lang=C -link -getcode :)<br />/*<br />To be used to register a new dialog based callback.<br />The function returns 0 on success. Otherwise, -1 is returned.<br /><br />Parameters :<br />        * struct dlg_cell *dlg : the dialog that the registered callback belongs to<br />        * int cb_types : The type of registered callback ( can be a bitmask of multiple callback types). The options are as follows :<br />                        * DLGCB_LOADED - callback will get called when a new dialog is loaded into memory at startup ( from a database ) or at runtime ( from a database via external MI call or via the binary replication interface ). This callback must be registered alone, and the dlg_cell* provided at registration time must be NULL ( since it's a global cb type, not associated to any particular dialog )<br />                        * DLGCB_CREATED - callback will get called when a new dialog is created. The callback will be called when the dialog is fully initialized ( create_dialog() was called either from script or from the API and the Transaction associated to the initial invite is fully initialised as well ). This callback must be registered alone, and the dlg_cell* provided at registration time must be NULL ( since it's a global cb type, not associated to any particular dialog )<br />                        * DLGCB_FAILED - callback will get called when a particular dialog fails to establish ( 3xx, 4xx, 5xx or 6xx reply received and relayed ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_CONFIRMED - callback will get called when a particular dialog gets established ( 2xx reply received ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_REQ_WITHIN - callback will get called when a sequential request is matched as belonging to a particular dialog ( either via loose_route() or match_dialog() calling from the script). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_TERMINATED - callback will get called when a dialog gets terminated. Reasons here are BYE routing or external Termination ( MI, API, etc ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_EXPIRED - callback will get called when a dialog lives past it's assigned timeout ( see the $DLG_timeout script pvar ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_EARLY - callback will get called when the first provisional reply ( 1xx ) is received for the registered dialog. This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_RESPONSE_FWDED - callback will get called when a reply is forwarded during the initial state of the dialog setup ( usually provisional 180, 183, etc ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_RESPONSE_WITHIN - callback will get called for all replies forwarded by OpenSIPS for sequential requests belonging to the current dialog. This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_MI_CONTEXT - callback will get called when the 'dlg_list_ctx' MI function is called. Useful when modules binded to the dialog module API want to append nodes to the dlg_list_ctx MI response tree. This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_DESTROY - callback will get called when the dialog is getting ready to be destroyed. At the time of the callback calling, the dialog is unlinked from the main hash, but it is not freed yet. This is a per dialog callback, so the first dlg parameter MUST be provided.<br />                        * DLGCB_SAVED - callback will get called when the dialog information is synchronized to the database ( either initial insertion, updating various fields in the DB or removing the dialog from the DB ). This is a per dialog callback, so the first dlg parameter MUST be provided.<br />        func - the actual callback function that will be executed.<br />        param - parameter that will be sent to the callback when called<br />        free_func - function to free the callback parameter at destroy time.<br />*/<br />typedef int (*register_dlgcb_f)(struct dlg_cell* dlg, int cb_types,<br />                dialog_cb func, void *param, param_free_cb free_func);<br />/* callback function prototype */<br />typedef void (dialog_cb) (struct dlg_cell* dlg, int type,<br />                struct dlg_cb_params * params);<br />/* function to free the callback param */<br />typedef void (param_free_cb) (void *param);<br /><br /><br />/*<br />        Creates the dialog structure for the current initial INVITE message and will keep track of the call for the rest of it's lifetime.<br />        Returns 0 in case of success. Otherwise, -1 is returned.<br />        Parameters :<br />                msg : the initial INVITE sip message<br />                flags : flags altering the behavior of the create dialog. Options here are :<br />                        * DLG_FLAG_BYEONTIMEOUT - dialog will be terminated from the middle, by OpenSIPS, when the dialog lifetime is exceeded.<br />                        * DLG_FLAG_PING_CALLER - ping the caller with OPTIONS messages to detect if the call is still up<br />                        * DLG_FLAG_PING_CALLEE - ping the callee with OPTIONS messages to detect if the call is still up<br />*/<br />typedef int (*create_dlg_f)(struct sip_msg *req,int flags);<br /><br /><br />/*<br />        Returns the current dialog pointer. In case of no created dialog or other internall errors, NULL is returned.<br />*/<br />typedef struct dlg_cell *(*get_dlg_f) (void);<br /><br /><br />/*<br />        Parses and creates the provided profile definitions.<br />        Returns 0 in case of success. Otherwise, -1 is returned.<br />        Parameters :<br />                profiles - the NULL terminated string containing one or multiple profile definitions ( sepparated by ';' )<br />                has_value - whether our profies will contain values with counters, or they will be just stand-alone counters<br />*/<br />typedef int (*add_profiles_f)(char* profiles, unsigned int has_value);<br /><br /><br />/*<br />        Looks up and returns the profile definition associated to the provided name. In case the profile is not found, or of internal error, NULL is returned.<br />        Parameters :<br />                name : str containing the name of a single profile definition<br />*/<br />typedef struct dlg_profile_table* (*search_dlg_profile_f)(str *name);<br /><br /><br />/*<br />        Sets the current dialog to belong in the provided profile definition.<br />        Returns 0 in case of success, and -1 otherwise.<br />        Parameters :<br />                msg : the SIP message currently being processed<br />                value : the value the dialog will be associated with within the provided profile<br />                profile : the main profile the dialog will be linked to<br />                is_replicated : whether or not this dialog was originated on the current machine, or we received it via replication mechanisms. Controls whether the cachedb counters should be increased for the current dialog profile or not.<br />*/<br />typedef int (*set_dlg_profile_f)(struct sip_msg *msg, str *value,<br />                        struct dlg_profile_table *profile, char is_replicated);<br /><br /><br />/*<br />        The opposite of the set_dlg_profile_f API function.<br />        Returns 0 in case of success, and -1 otherwise.<br />        Parameters :<br />                msg : the SIP message currently being processed<br />                value : the value the dialog will be de-associated with within the provided profile<br />                profile : the main profile the dialog will be un-linked from<br /><br />*/<br />typedef int (*unset_dlg_profile_f)(struct sip_msg *msg, str *value,<br />                         struct dlg_profile_table *profile);<br /><br /><br />/*<br />        Returns the number of dialogs belonging to the current profile.<br />        Parameters :<br />                profile : the profile definition<br />                value : the value to filter the profile. Can be missing, the size of all individual values within a profile will be returned.<br />*/<br />typedef unsigned int (*get_profile_size_f)(struct dlg_profile_table *profile,<br />                                                                                str *value);<br /><br /><br />/*<br />        Stores an opaque key-value mapping inside the dialog structure, which can be fetched at a later time based on the current dialog. If the key already exists, it will be overwritten.<br />        Returns 0 in case of success. Otherwise, -1 is returned.<br />        Parameters :<br />                dlg : the dialog pointer to link the key to<br />                name : name of the key to store within the provided dialog<br />                val : the value to be mapped to the provided key<br />*/<br />typedef int (*store_dlg_value_f)(struct dlg_cell *dlg,<br />                str *name, str *val);<br /><br /><br />/*<br />        Fetch a previously stored value within the provided dialog.<br />        Returns 0 in case of success. Otherwise, -1 is returned.<br />        Parameters :<br />                dlg : the dialog pointer to fetch the key from<br />                name : the name of the key to fetch<br />                val : output parameter, the value of the key will be stored here<br />                val_has_buf - whether we have a buffer allocated for fetching the key's value or not. If 0, the dialog module will return a static buffer that it reuses for all key values.<br />*/<br />typedef int (*fetch_dlg_value_f)(struct dlg_cell *dlg,<br />                str *name, str *val, int val_has_buf);<br /><br /><br />/*<br />        Terminates an ongoing dialog ( by sending BYE messages both ways )<br />        Returns 0 in case of success. Otherwise, -1 is returned.<br />        Parameters :<br />                h_entry : The hash bucket ID for the dialog that we want to terminate<br />                h_id : The ID of the dialog element within our hash bucket<br />                reason : An opaque string describing the reason for terminating the dialog. Can be later fetched from the script by the user<br />*/<br />typedef int (*terminate_dlg_f)(unsigned int h_entry, unsigned int h_id,str *reason);<br />(:sourceend:)<br />\\<br />See below a simple example of binding to the Dialog API from another module and running a couple of dialog related operations.<br />(:source lang=C -link -getcode :)<br />...<br />#include &quot;../dialog/dlg_load.h&quot;<br />...<br />...<br />struct dlg_binds my_dlgb;<br />...<br />...<br />int mod_init(void) {<br />        ...<br />        ...<br />        /* load the dialog API */<br />        if (load_dlg_api(&amp;my_dlgb)!=0) {<br />                LM_ERR(&quot;failed to find dialog API - is dialog module loaded?\n&quot;);<br />                goto error;<br />        }<br /><br />        /* make sure we get notified of all upcoming created dialogs */<br />        if (my_dlgb.register_dlgcb(NULL,DLGCB_CREATED,new_created_dialog_cb,NULL,NULL) != 0 ) {<br />                LM_ERR(&quot;Failed to register initial dlg callback \n&quot;);<br />                goto error;<br />        }<br /><br />        ...<br />        ...<br />}<br /><br />void new_created_dialog_cb(struct dlg_cell *did, int type,<br />                struct dlg_cb_params * params)<br />{<br />        time_t curtime;<br />        str create_time_key = str_init(&quot;created_at&quot;);<br />        str create_time;<br /><br />        time(&amp;curtime);<br />        LM_INFO(&quot;Dialog was created ! \n&quot;);<br /><br />        if ( my_dlgb-&gt;register_dlgcb(did,<br />        DLGCB_CONFIRMED, dialog_confirmed_cb, NULL, NULL) != 0) {<br />                LM_ERR(&quot;Failed to register CB for dialog establishment \n&quot;);<br />                return;<br />        }<br /><br />        if ( my_dlgb-&gt;register_dlgcb(did,<br />        DLGCB_REQ_WITHIN, dialog_sequential_cb, NULL, NULL) != 0) {<br />                LM_ERR(&quot;Failed to register CB for dialog sequential requests \n&quot;);<br />                return;<br />        }<br /><br />        create_time.s = ctime(&amp;curtime);<br />        create_time.len = strlen(create_time.s);<br /><br />        if ( my_dlgb.store_dlg_value(did,&amp;create_time_key,&amp;create_time) != 0) {<br />                LM_ERR(&quot;Failed to store our create string key \n&quot;);<br />                return;<br />        }<br /><br />}<br /><br />void dialog_confirmed_cb(struct dlg_cell *did, int type,<br />                struct dlg_cb_params * params)<br />{<br />        str create_time_key = str_init(&quot;created_at&quot;);<br />        str create_time;<br /><br />        if ( my_dlgb.fetch_dlg_value(did,&amp;create_time_key,&amp;create_time,0) != 0 ) {<br />                LM_ERR(&quot;Failed to fetch our create string key \n&quot;);<br />                return;<br />        }<br /><br />        LM_INFO(&quot;The dialog was created at %.*s and is now established \n&quot;,create_time.len,create_time.s);<br />}<br /><br />void dialog_sequential_cb(struct dlg_cell *did, int type,<br />                struct dlg_cb_params * params)<br />{<br />        struct sip_msg *msg = msg;<br />        str term_reason = &quot;we HATE options from callee :D&quot;;<br /><br />        if (msg-&gt;first_line.u.request.method_value == METHOD_OPTIONS &amp;&amp; params-&gt;dir == DLG_DIR_UPSTREAM) {<br />                LM_INFO(&quot;Received OPTIONS sequential from callee. Terminating DLG because %.*s\n&quot;,<br />                term_reason.len,term_reason.s);<br /><br />                if (my_dlgb.terminate_dlg(did-&gt;h_entry,did-&gt;h_id,&amp;term_reason) != 0) {<br />                        LM_ERR(&quot;Failed to terminate the dialog \n&quot;);<br />                }<br />        }<br />}<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1404670170-1404669294-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1404670170:1404669294:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>July 06, 2014, at 07:54 PM 
        by <span class='diffauthor' title='213.233.84.73'>213.233.84.73</span> - </div>
        <div class='difftype'>Added lines 2932-2977:</div>
        <div class='diffadd'><div class='diffmarkup'><br />(:source lang=C -link -getcode :)<br />...<br />#include &quot;../rr/api.h&quot;<br />...<br />struct rr_binds my_rrb;<br />...<br />...<br />int mod_init(void) {<br />        ...<br />        ...<br />        /* load the RR API */<br />        if (load_rr_api( &amp;my_rrb )!=0) {<br />            LM_ERR(&quot;can't load RR API\n&quot;);<br />            goto error;<br />        }<br /><br />        if (!my_rrb.append_fromtag) {<br />            LM_ERR(&quot;The append_fromtag parameter is not set, but we need it for detecting the direction of requests \n&quot;);<br />            goto error;<br />        }<br />        ...<br />        ...<br />        /* register a RR callback */<br />        if (my_rrb.register_rrcb(my_callback,0,0))!=0) {<br />            LM_ERR(&quot;can't register RR callback\n&quot;);<br />            goto error;<br />        }<br />        ...<br />        ...<br />}<br /><br />void my_callback(struct sip_msg* msg,str* rr_param,void *param)<br />{<br />        str name = str_init(&quot;ftag&quot;);<br />        str val;<br /><br />        LM_INFO(&quot;Received a new sequential request from %s\n&quot;,<br />        my_rrb.is_direction( msg, RR_FLOW_UPSTREAM)?&quot;callee&quot;:&quot;caller&quot;);<br /><br />        if (my_rrb.get_route_param(msg,&amp;name,&amp;val) == 0) {<br />                LM_INFO(&quot;We have the ftag parameter with value [%.*s]\n&quot;,val.len,val.s);<br />        }<br />}<br />(:sourceend:)<br />\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1404669294-1404669159-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1404669294:1404669159:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>July 06, 2014, at 07:52 PM 
        by <span class='diffauthor' title='213.233.84.73'>213.233.84.73</span> - </div>
        <div class='difftype'>Changed lines 2770-2771 from:</div>
        <div class='diffdel'><div class='diffmarkup'><br />(:sourceend:</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* Adds a parameter to the requests's Record-Route URI. The API supports the use case<br />   where the Record-Routed header will be further added.<br />   The function is to be used for marking certain dialogs that can<br />   be identified from the sequential requests - since the Route<br />   headers in the sequential requests will also contain our added<br />   params, which we'll be able to fetch with get_route_param ( see below )<br /><br />   The function returns 0 on success. Otherwise, -1 is returned.<br /><br />   Parameters :<br />     * struct sip_msg* msg - request that will has the parameter<br />       “param” added to its Record-Route header.<br />     * str* param - parameter to be added to the Record-Route<br />       header - it must be in “;name=value” format.<br />*/<br />typedef  int (*add_rr_param_t)(struct sip_msg* msg, str* param);<br /><br /><br />/*    The function checks for the request “msg” if the URI parameters<br />   of the local Route header (corresponding to the local server)<br />   matches the given regular expression “re”. It MUST be call<br />   after the loose_route was done.<br /><br />   The function returns 0 on success. Otherwise, -1 is returned.<br /><br />   * struct sip_msg* msg - request that will has the Route<br />       header parameters checked.<br />   * regex_t* re - compiled regular expression to be checked<br />       against the Route header parameters.<br />*/<br />int (*check_route_param_t)(struct sip_msg* msg, regex_t* rem);<br /><br /><br />/*    The function checks the flow direction of the request “msg”. As<br />   for checking it's used the “ftag” Route header parameter, the<br />   append_fromtag (see Section 1.4.1, “append_fromtag (integer)”<br />   module parameter must be enables. Also this must be call only<br />   after the loose_route is done.<br /><br />   The function returns 0 if the “dir” is the same with the<br />   request's flow direction. Otherwise, -1 is returned.<br /><br />   Meaning of the parameters is as follows:<br />     * struct sip_msg* msg - request that will have the direction<br />       checked.<br />     * int direction - direction to be checked against. It may be<br />       RR_FLOW_UPSTREAM ( from callee to caller ) or<br />       RR_FLOW_DOWNSTREAM ( from caller to callee ).<br />*/<br />typedef  int (*is_direction_t)(struct sip_msg* msg, int direction);<br /><br /><br />/*<br />   The function search in to the “msg”'s Route header parameters<br />   the parameter called “name” and returns its value into “val”.<br />   It must be call only after the loose_route is done.<br /><br />   The function returns 0 if parameter was found (even if it has<br />   no value). Otherwise, -1 is returned.<br /><br />   Meaning of the parameters is as follows:<br />     * struct sip_msg* msg - request that will have the Route<br />       header parameter searched.<br />     * str *name - contains the Route header parameter to be<br />       serached.<br />     * str *val - returns the value of the searched Route header<br />       parameter if found. It might be empty string if the<br />       parameter had no value.<br />*/<br />typedef  int (*get_route_param_t)(struct sip_msg*, str*, str*);<br /><br /><br />/*<br />   The function register a new callback (along with its<br />   parameter). The callback will be called when a loose route will<br />   succesfully be performed for the local address.<br /><br />   The function returns 0 on success. Otherwise, -1 is returned.<br /><br />    Meaning of the parameters is as follows:<br />     * rr_cb_t func - callback function to be registered.<br />     * void *param - parameter to be passed to the callback<br />       function.<br />     * short prior - parameter to set the priority. The callbacks<br />        will be executed in order from small to big priority - thus<br />        to be used for ordering callbacks that depend on each other.<br /><br />*/<br />typedef int (*register_rrcb_t)( rr_cb_t func, void *param, short prior);<br /><br /><br />/* Function to be registered as callback within the RR API :<br />     * struct sip_msg* req - request that is currently being processed<br />     * str *rr_param - the parameters in our server's Route header<br />     * str *param - the custom parameter provided at the callback registration<br />*/<br />typedef void (rr_cb_t) (struct sip_msg* req, str *rr_param, void *param);<br /><br /><br />/*<br />   Function used to fetch the far-end remote target for the current message.<br />   Depending on the type routing done ( see the '''routing_type''' API member )<br />   the remote target can be either in the initial Request URI, in the current<br />   Request-URI or in the last route header. The API function take care to<br />   correctly identify which scenario is correct.<br />   The API function MUST be called after loose_route() was called.<br /><br />   The function returns the str pointer with the remote target, or NULL in case of error.<br /><br />   Meaning of the parameters is as follows:<br />        -* struct sip_msg* msg - request that the remote target will be extracted from<br />*/<br />typedef  str* (*get_remote_target_t)(struct sip_msg* msg);<br /><br /><br />/*<br />    Function used to fetch the route set from the current SIP message.<br />    The function takes into account the actual loose_route() done, and properly discards<br />    the proxy's own Route headers from the SIP message. Thus, the function must be called<br />    after loose_route() was done.<br /><br />    The function will return an array of str structures, or NULL in case of error. The<br />    nr_routes parameter will indicate the size of the returned array<br /><br />    Meaning of the parameters is as follows:<br />        -* struct sip_msg* msg - request that the remote target will be extracted from<br />        -* int* nr_routes - the size of the returned array<br />*/<br />typedef  str* (*get_route_set_t)(struct sip_msg*,int *nr_routes);<br /><br /><br />/*<br />    Function to be used when for routing a request according to the Route headers present<br />    in it and to the type of Routing ( loose vs strict ) that needs to be used.<br /><br />    The function will return 0 in case of success ( request is succesfully routed ). Otherwise,<br />    -1 is returned.<br /><br />   Meaning of the parameters is as follows:<br />        -* struct sip_msg* msg - request to be routed<br /><br />*/<br />typedef  int (*loose_route_t)(struct sip_msg* msg);<br /><br /><br />/*<br />    Function to be used when record-routing an initial request. The function will add<br />    one or two Record-Route headers , depending if there are any interface changes and<br />    if r2 is enabled. Also, if any parameters are provided, they will be added to all the<br />    Record-Route headers that the function internally adds.<br /><br />    Returns 0 in case of success. Otherwise, -1 will be returned.<br /><br />    Meaning of the parameters is as follows:<br />        -* struct sip_msg* msg - request to be record routed<br />        -* str* params - parameters to be added to the Record-Route headers<br />*/<br />typedef  int (*record_route_t)(struct sip_msg* msg, str* params);<br /><br />(:sourceend:)<br />\\<br />See below an example of binding to the RR API from another module, registering a callback and then checking the direction of the sequential request and also checking for the existence of a certain parameter.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1404669159-1404668910-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1404669159:1404668910:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>July 06, 2014, at 07:48 PM 
        by <span class='diffauthor' title='213.233.84.73'>213.233.84.73</span> - </div>
        <div class='difftype'>Changed lines 2730-2771 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters : rrb is the API output to be further used<br /><br />Returns : 0 in case of success and -1 in case of failure<br />*/<br />inline static int load_rr_api( struct rr_binds *rrb );<br />(:sourceend:)<br />\\<br />The rr_binds structure is exemplified below :<br />(:source lang=C -link -getcode :)<br />struct rr_binds {<br />        add_rr_param_t      add_rr_param;<br />        check_route_param_t check_route_param;<br />        is_direction_t      is_direction;<br />        get_route_param_t   get_route_param;<br />        register_rrcb_t     register_rrcb;<br />        get_remote_target_t get_remote_target;<br />        get_route_set_t     get_route_set;<br />        /* whether or not the append_fromtag parameter is enabled in the RR module */<br />        int                 append_fromtag;<br />        /* the number of routes removed within the loose routing process */<br />        int*                removed_routes;<br />        /* the type of routing done, when comparing the previous and the next hop<br />        Both can be either strict or loose routers, thus here we have 4 different options :<br />        ROUTING_LL - loose to loose routing<br />        ROUTING_SL - strict to loose routing<br />        ROUTING_SS - strict to strict routing<br />        ROUTING_LS - loose to strict routing<br />        */<br />        int*                routing_type;<br /><br />        loose_route_t       loose_route;<br />        record_route_t      record_route;<br />};<br />(:sourceend:)<br />\\<br />Find below the API function signatures along with their usage :<br />(:source lang=C -link -getcode :)<br /><br />(:sourceend:</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1404668910-1404668635-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1404668910:1404668635:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>July 06, 2014, at 07:43 PM 
        by <span class='diffauthor' title='213.233.84.73'>213.233.84.73</span> - </div>
        <div class='difftype'>Added lines 2716-2720:</div>
        <div class='diffadd'><div class='diffmarkup'>Within OpenSIPS, one modules might need to access the functionality of another module ( one very common example are modules desiring to do operations on a per dialog basis, thus needing part of the dialog module functionality ). Instead of directly accessing the functionality from within the target module, OpenSIPS heavily uses the concept of a 'module exported API'. \\<br />The common approach used throughout OpenSIPS is that the target module should implement a form of loading it's API - which in fact translates into populating a structure with pointers of the functions that need to be exported, as well as various other structure members that indicate various behaviour. \\<br />The module that needs to operate with the above API should first call ( within it's mod_init ) the function to bind to the needed module's API, and then operate with the received structure. \\<br />Find below the most heavily used module APIs in OpenSIPS.<br /></div></div>
        <div class='difftype'>Added lines 2724-2730:</div>
        <div class='diffadd'><div class='diffmarkup'><br />The RR ( Record Route ) module API is exported by the '''modules/rr/api.h''' file. <br />\\<br />From a general functionality point of view, the RR module is the one responsible for controlling the Record-Route part for requests, and then routing the sequential requests based on the Route headers. The RR module is the simplest module that provides very simple dialog-aware functionality, by allowing the storage of information ( parameters ) in the Record-Route headers, which can be later retrieved from the Route headers.<br />\\<br />First, you will have to bind to the RR module's API and get the structure which you will further use. The binding function is :<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1404668635-1403013859-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1404668635:1403013859:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 17, 2014, at 04:04 PM 
        by <span class='diffauthor' title='89.120.101.121'>89.120.101.121</span> - </div>
        <div class='difftype'>Changed line 1933 from:</div>
        <div class='diffdel'><div class='diffmarkup'>rows = RES_ROWS(res);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>rows = RES_ROWS(db_res);</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1403013859-1402855326-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1403013859:1402855326:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 08:02 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed lines 15-19 from:</div>
        <div class='diffdel'><div class='diffmarkup'>TBD \\<br /><br />TBD \\<br /><br />TBD \\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />The focus of the following document will be on the general architecture of OpenSIPS, as well as presenting all the major components and APIs that OpenSIPS exposes for building new modules / features.<br />\\<br />The tutorial does not aim to teach Linux / C programming. Below are a list of prerequisites :<br />* C programming under Linux<br />* Multi-Process programming under Linux<br />* Basic Networking Concepts<br />* Basic SIP knowledge<br /><br />\\<br />The tutorial is accurate as of OpenSIPS 1.11</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402855326-1402852735-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402855326:1402852735:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 07:18 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Added lines 2185-2262:</div>
        <div class='diffadd'><div class='diffmarkup'><br />For creating and sending a new event, the following methods are to be used :<br />(:source lang=C -link -getcode :)<br />/**<br /> * bin_init - begins the construction of a new binary packet (header part):<br /> *<br /> * +-------------------+------------------------------------------------------+<br /> * |  8-byte HEADER    |                 BODY                max 65535 bytes  |<br /> * +-------------------+------------------------------------------------------+<br /> * | PK_MARKER |  CRC  | LEN | MOD_NAME | CMD | LEN | FIELD | LEN | FIELD |...|<br /> * +-------------------+------------------------------------------------------+<br /> *<br /> * @param: { LEN, MOD_NAME } + CMD<br /> */<br />int bin_init(str *mod_name, int cmd_type)<br /><br />/*<br /> * copies the given string at the 'cpos' position in the buffer<br /> * allows null strings (NULL content or NULL param)<br /> *<br /> * @return: 0 on success<br /> */<br />int bin_push_str(const str *info)<br /><br />/*<br /> * adds a new integer value at the 'cpos' position in the buffer<br /> *<br /> * @return: 0 on success<br /> */<br />int bin_push_int(int info)<br /><br />/**<br /> * bin_send - computes the checksum of the current packet and then<br /> * sends the packet over UDP to the @dest destination<br /> *<br /> * @return: number of bytes sent, or -1 on error<br /> */<br />int bin_send(union sockaddr_union *dest)<br />(:sourceend:)<br />\\<br />On the receiving end, the developer must first register a callback that will be trigger when receiving special types of BIN message, by using the following :<br /><br />(:source lang=C -link -getcode :)<br />/**<br /> * bin_register_cb - registers a module handler for specific packets<br /> * @mod_name: used to classify the incoming packets<br /> * @cb:       the handler function, called once for each matched packet<br /> *<br /> * @return:   0 on success<br /> */<br />int bin_register_cb(char *mod_name, void (*cb)(int))<br />(:sourceend:)<br />\\<br />The callback will only be triggered for the mod_name class of BIN packages, and also the callback will receive the packet type as well, in order to be able to differentiate between multiple types of events ( eg. create, update, delete, etc ).<br />\\<br />Afterwards, you should use the pop methods for extracting the contents of the package :<br />(:source lang=C -link -getcode :)<br />/*<br /> * pops an str from the current position in the buffer<br /> * @info:   pointer to store the result<br /> *<br /> * @return: 0 on success<br /> *<br /> * Note: The pointer returned in @info str is only valid for the duration of<br /> *       the callback. Don't forget to copy the info into a safe buffer!<br /> */<br />int bin_pop_str(str *info)<br /><br />/*<br /> * pops an integer value from the current position in the buffer<br /> * @info:   pointer to store the result<br /> *<br /> * @return: 0 on success<br /> */<br />int bin_pop_int(void *info)<br />(:sourceend:)<br />\\<br />See the main page dedicated to the [[http://www.opensips.org/Documentation/Interface-Binary|Binary Interface]] on how to then configure OpenSIPS listeners for the binary packages.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402852735-1402840606-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402852735:1402840606:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:56 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Added lines 2177-2184:</div>
        <div class='diffadd'><div class='diffmarkup'><br />The '''Binary Internal Interface''' is an OpenSIPS core interface which offers an efficient way for communication between individual OpenSIPS instances.\\<br />This is especially useful in scenarios where realtime data (such as dialogs) cannot be simply stored in a database anymore, because failover would require entire minutes to complete. This issue can be solved with the new internal binary interface by replicating all the events related to the runtime data (creation / updating / deletion) to a backup OpenSIPS instance. \\<br />The BIN interface functionality is exported by the '''bin_interface.h''' file. \\<br />Using the interface has two steps :<br /><br />* creating and sending the new event from the Active OpenSIPS server<br />* receiving and processing the event in the Backup OpenSIPS server</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402840606-1402840019-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402840606:1402840019:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:46 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed lines 2628-2632 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Dialog Module</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Dialog Module<br /><br />!!!! Video Tutorial<br /><br />A full video tutorial ( 7 video sessions of 1-2 hours ) going through the OpenSIPS development process can be found [[http://www.opensips.org/Documentation/Development-Tutorials|here]] , along with some source code examples used in the video tutorial.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402840019-1402839499-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402840019:1402839499:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:38 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed line 2436 from:</div>
        <div class='diffdel'><div class='diffmarkup'>As can be seen, all the OpenSIPS module functions receive string parameters ONLY, and a function can have a maximum of 6 parameters. The SIP message that is currently being processed is also transmitted as the first parameter, although this is transparent to the script writer ( he just provides the parameters idx 1 to 5 )</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>typedef  int (*cmd_function)(struct sip_msg*, char*, char*, char*, char*, char*, char*);</div></div>
        <div class='difftype'>Added lines 2438-2439:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />As can be seen, all the OpenSIPS module functions receive string parameters ONLY, and a function can have a maximum of 6 parameters. The SIP message that is currently being processed is also transmitted as the first parameter, although this is transparent to the script writer ( he just provides the parameters idx 1 to 5 )</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402839499-1402839295-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402839499:1402839295:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:34 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed lines 2538-2539 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For the full description of the used structures and functions, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc27 | Management Interface API]] section. \\<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For the full description of the used structures and functions, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc26 | Management Interface API]] section. \\<br /></div></div>
        <div class='difftype'>Changed line 2548 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For the full description of the used structures and functions for statistics, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc26|Statistics API]] section. \\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For the full description of the used structures and functions for statistics, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc27|Statistics API]] section. \\</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402839295:1402839250:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402839295:1402839250:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402839295:1402839250:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:34 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Added lines 1537-1545:</div>
        <div class='diffadd'><div class='diffmarkup'>&gt;&gt;&lt;&lt;<br /><br />\\<br /><br />&gt;&gt;tip&lt;&lt;<br />For fetching the '''mynewstat''' statistic exported by the '''mynewmod''' module, one can use the '''opensipsctl''' like this : \\<br />opensipsctl fifo get_statistics mynewmod mynewstat \\<br />For fetching all the statistics exported by the '''mynewmod''' module, you can use \\<br />opensipsctl fifo get_statistics mynewmod:</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402839250-1402839103-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402839250:1402839103:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:31 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed lines 1233-1235 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!! Statistics API<br /><br />OpenSIPS exposes a statistics API that can be used both from the core or the modules. The statistics are essentially counters that will be internally incremented/decremented by OpenSIPS and that can be fetched by the outside world ( via the MI interface ) for understanding the OpenSIPS load / health status / etc.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Management Interface API<br /><br />The Management Interface is the abstract layer that is commonly used to control and monitor OpenSIPS. The MI Interface supports multiple actual back-ends ( eg. FIFO, Datagram, XMLRPC, HTTP GET JSON, etc ) - due to the modularity of the interface and also due to the clear separation between the  logic and the transport layer, the developer just defines the functions to be externally called, and then it is up to the OpenSIPS script writer to chose what transport he will actually use for controlling OpenSIPS.</div></div>
        <div class='difftype'>Changed lines 1237-1239 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The advantages of using the OpenSIPS Statistics API instead of regular counters is :<br />* easily fetched from the MI Interface<br />* on supported architectures, the statistics do not use an explicit lock ( the consistency is ensured by employing assembly code ), thus you will get better performance</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The MI interface heavily uses trees :<br />* the Interface will provide as input a tree with the parameters provided by the user<br />* an MI function has to also return a tree, which will then be converted by the transport module to it's specific representation</div></div>
        <div class='difftype'>Changed lines 1241-1242 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The most important structures used for extending statistics are exported by '''statistics.h''' :<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Further on we will focus on the core MI functions, with a specific focus on the '''debug''' function. Note that modules can ( an commonly ) also export MI functions - see the Modules Development MI functions topic for more information on that.<br />\\<br />The structures commonly used for exporting MI functions are found in '''mi/mi.h''' :<br /></div></div>
        <div class='difftype'>Changed lines 1246-1251 from:</div>
        <div class='diffdel'><div class='diffmarkup'>typedef struct stat_export_ {<br />        char* name;                /* null terminated statistic name */<br />        unsigned short flags;      /* flags */<br />        stat_var** stat_pointer;   /* pointer to the variable's mem location *<br />                                    * NOTE - it's in shm mem */<br />} stat_export_t;</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>typedef struct mi_export_ {<br />        /* the name of the function ( users will call this from their transport of choice */<br />        char *name;<br />        /* short description of the usage of this function */<br />        char *help;<br />        /* actual function that will get called */<br />        mi_cmd_f *cmd;<br />        /* flags for this function. Currently options are :<br />             - MI_ASYNC_RPL_FLAG - the function has an asynchronous behaviour ( eg: MI functions that send SIP messages and wait for their reply )<br />             - MI_NO_INPUT_FLAG - the function does not receive any parameters <br />        */<br />        unsigned int flags;<br />        /* parameter that will be passed when the cmd function gets called */<br />        void *param;<br />        /* the initialization function to be called by OpenSIPS ( one time ) */<br />        mi_child_init_f *init_f;<br />}mi_export_t;<br /><br />/* Example of core MI exported function */<br />static mi_export_t mi_core_cmds[] = {<br />        { &quot;uptime&quot;, &quot;prints various time information about OpenSIPS - &quot;<br />                &quot;when it started to run, for how long it runs&quot;,<br />                mi_uptime,     MI_NO_INPUT_FLAG,  0,  init_mi_uptime },<br />        { &quot;version&quot;, &quot;prints the version string of a runningOpenSIPS&quot;,<br />                mi_version,    MI_NO_INPUT_FLAG,  0,  0 },<br />        { &quot;pwd&quot;, &quot;prints the working directory of OpenSIPS&quot;,<br />                mi_pwd,        MI_NO_INPUT_FLAG,  0,  0 },<br />...<br />...<br />...<br />/* For exporting the populated array of MI functions<br />Parameters :<br />      mod_name : the name of the module exporting these functions<br />      mis : the array of exported MI functions<br />Returns :<br />      0 on success, negative in case of error<br />*/<br />int register_mi_mod( char *mod_name, mi_export_t *mis);<br /><br />/* Example of usage */<br />if (register_mi_mod( &quot;core&quot;, mi_core_cmds)&lt;0) {<br />      LM_ERR(&quot;unable to register core MI cmds\n&quot;);<br />      return -1;  <br />}</div></div>
        <div class='difftype'>Changed lines 1292-1293 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For example, the core stats exported by OpenSIPS are defined in the following array :<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The structures commonly used for implementing MI functions are also found in '''mi/mi.h''' :</div></div>
        <div class='difftype'>Changed lines 1294-1332 from:</div>
        <div class='diffdel'><div class='diffmarkup'>stat_var* rcv_reqs;<br />stat_var* rcv_rpls;<br />stat_var* fwd_reqs;<br />stat_var* fwd_rpls;<br />stat_var* drp_reqs;<br />stat_var* drp_rpls;<br />stat_var* err_reqs;<br />stat_var* err_rpls;<br />stat_var* bad_URIs;<br />stat_var* unsupported_methods;<br />stat_var* bad_msg_hdr;<br /><br />stat_export_t core_stats[] = {<br />        {&quot;rcv_requests&quot; ,         0,  &amp;rcv_reqs              },<br />        {&quot;rcv_replies&quot; ,          0,  &amp;rcv_rpls              },<br />        {&quot;fwd_requests&quot; ,         0,  &amp;fwd_reqs              },<br />        {&quot;fwd_replies&quot; ,          0,  &amp;fwd_rpls              },<br />        {&quot;drop_requests&quot; ,        0,  &amp;drp_reqs              },<br />        {&quot;drop_replies&quot; ,         0,  &amp;drp_rpls              },<br />        {&quot;err_requests&quot; ,         0,  &amp;err_reqs              },<br />        {&quot;err_replies&quot; ,          0,  &amp;err_rpls              },<br />        {&quot;bad_URIs_rcvd&quot;,         0,  &amp;bad_URIs              },<br />        {&quot;unsupported_methods&quot;,   0,  &amp;unsupported_methods   },<br />        {&quot;bad_msg_hdr&quot;,           0,  &amp;bad_msg_hdr           },<br />        {&quot;timestamp&quot;,  STAT_IS_FUNC, (stat_var**)get_ticks   },<br />        {0,0,0}<br />};<br />(:sourceend:)<br />\\<br /><br />&gt;&gt;tip&lt;&lt;<br />As note from the above structure, statistics can either be a simple counter ( eg. rcv_requests ), but it can also be a function. Statistics function might come in handy when the developer needs to do extra processing on the raw counters before providing the final output.<br />&gt;&gt;&lt;&lt;<br /><br />\\<br />After defining your array of statistics that you want to export, one should use the following for exporting the stats to be accessible by all<br /><br />(:source lang=C -link -getcode :)<br />/* </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*</div></div>
        <div class='difftype'>Changed lines 1296-1297 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      module - a string describing the module the current statistics belong to. Will be used when fetching the statistics via MI<br />      stats - the statistics to be registered</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      input : the tree that contains the command paramenters<br />      param : the parameter provided at function registration</div></div>
        <div class='difftype'>Changed line 1299 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      0 in case of success, negative in case of error</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      A mi_root tree containing the function reply</div></div>
        <div class='difftype'>Changed lines 1301-1329 from:</div>
        <div class='diffdel'><div class='diffmarkup'>int register_module_stats(char *module, stat_export_t *stats;</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>typedef struct mi_root* (mi_cmd_f)(struct mi_root *input, void *param);<br /><br />/* below are the used structures for representing the tree root and the tree nodes */<br />struct mi_root {<br />      /* int code - similar to SIP or HTTP code */<br />      unsigned int       code;<br />      /* string reason for code - similar to SIP or HTTP reason */<br />      str                reason;<br />      /* handler in case of asynchronous MI commands */ <br />      struct mi_handler  *async_hdl;<br />      /* the actual root node in our tree */<br />      struct mi_node     node; <br />};<br /><br />struct mi_node {<br />      str value;<br />      str name;<br />      unsigned int flags;<br />      struct mi_node *kids;<br />      struct mi_node *next;<br />      struct mi_node *last; <br />      struct mi_attr *attributes;<br />};      <br />                <br />struct mi_attr{<br />        str name;<br />        str value;<br />        struct mi_attr *next;<br />};</div></div>
        <div class='difftype'>Changed line 1332 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Note that '''register_module_stats''' will export the statistics, and also allocate them in SHM memory, for them to be accessible by all OpenSIPS processes.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>As can be noted from the above tree definition, a node has a name and a value associated to it,it can have one or multiple children ( stored in kids pointer ), and also it can have a list of key-value attributes associated to it.</div></div>
        <div class='difftype'>Changed lines 1334-1341 from:</div>
        <div class='diffdel'><div class='diffmarkup'><br />&gt;&gt;important&lt;&lt;<br />Important to note here that all the above statistics related functions MUST be called in the context of the attendant process before forking is done.<br />&gt;&gt;&lt;&lt;<br /><br />\\<br />At runtime, the developer has access to the following functions for operating on statistics :<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For building the output MI tree, '''mi/tree.h''' and '''mi/attr.h''' expose the following functions :</div></div>
        <div class='difftype'>Changed line 1336 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/* </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* Use for creating a new output reply tree</div></div>
        <div class='difftype'>Changed lines 1338-1343 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      var : the statistics to be updated<br />      n : the value ( if positive -&gt; stat will be increment. negative -&gt; stat will be decremented )<br />*/<br />void update_stat(stat_var* var, int n);<br /><br />/* </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      code : success code for this tree ( &gt;=200&lt;300 for success, anything else for errors )<br />      reason : string reasons representation for the code<br />      reason_len : length of the reason parameter<br />Returns :<br />      A new mi_root tree, or NULL in case of error. Note that this function will allocate the node in PKG and it typically has to be returned - the freeing will be done in the MI core, after the output tree is written by the transport module */<br />struct mi_root *init_mi_tree(unsigned int code, char *reason, int reason_len);<br /><br />/* Adding a new child node to our tree - typically first called to mi_root-&gt;node.kids</div></div>
        <div class='difftype'>Changed lines 1347-1354 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      var : the statistics to be reseted</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      parent : the parent node for our newly added node<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this node needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current node needs to be duplicated in PKG<br />      name : the name of the current node<br />      name_len : length of the node's name<br />      value : the value of the current node<br />      value_len : length of the node's value</div></div>
        <div class='difftype'>Changed lines 1356-1358 from:</div>
        <div class='diffdel'><div class='diffmarkup'>void reset_stat(stat_var* var);<br /><br />/*</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>struct mi_node *add_mi_node_child(struct mi_node *parent, int flags,<br />        char *name, int name_len, char *value, int value_len);<br />/* Adding a new sibling node to one of our nodes</div></div>
        <div class='difftype'>Changed lines 1360-1362 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      var : the statistics to be fetched<br />Returns :<br />      statistic value</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      brother : the brother node for our newly added node<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this node needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current node needs to be duplicated in PKG<br />      name : the name of the current node<br />      name_len : length of the node's name<br />      value : the value of the current node<br />      value_len : length of the node's value</div></div>
        <div class='difftype'>Changed lines 1369-1382 from:</div>
        <div class='diffdel'><div class='diffmarkup'>unsigned long get_stat_val(stat_var* var)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>struct mi_node *add_mi_node_sibling(struct mi_node *brother, int flags,<br />        char *name, int name_len, char *value, int value_len);<br />/* Adding a new attribute to one of our nodes<br />      node : the node we will be adding the key-value attribute to<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this attribute needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current attribute needs to be duplicated in PKG<br />      name : the name of the current attribute<br />      name_len : length of the node's attribute name<br />      value : the value of the current value<br />      value_len : length of the node's attribute value<br />*/<br />struct mi_attr *add_mi_attr(struct mi_node *node, int flags,                                      <br />        char *name, int name_len, char *value, int value_len)</div></div>
        <div class='difftype'>Deleted lines 1383-1390:</div>
        <div class='diffdel'><div class='diffmarkup'><br />&gt;&gt;important&lt;&lt;<br />All statistics related code should be guarded by '''#ifdef STATISTICS''' , since the statistics are not a mandatory part of the OpenSIPS core ( they can be disabled from within menuconfig ).<br />&gt;&gt;&lt;&lt;<br /><br />!!!! Management Interface API<br /><br />The Management Interface is the abstract layer that is commonly used to control and monitor OpenSIPS. The MI Interface supports multiple actual back-ends ( eg. FIFO, Datagram, XMLRPC, HTTP GET JSON, etc ) - due to the modularity of the interface and also due to the clear separation between the  logic and the transport layer, the developer just defines the functions to be externally called, and then it is up to the OpenSIPS script writer to chose what transport he will actually use for controlling OpenSIPS.</div></div>
        <div class='difftype'>Changed lines 1385-1392 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The MI interface heavily uses trees :<br />* the Interface will provide as input a tree with the parameters provided by the user<br />* an MI function has to also return a tree, which will then be converted by the transport module to it's specific representation<br />\\<br />Further on we will focus on the core MI functions, with a specific focus on the '''debug''' function. Note that modules can ( an commonly ) also export MI functions - see the Modules Development MI functions topic for more information on that.<br />\\<br />The structures commonly used for exporting MI functions are found in '''mi/mi.h''' :<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Further on, we will follow the implementation of the '''debug''' MI function. If called with no parameters, the function will return the current debug level in OpenSIPS. If called with one integer parameter, then the function will set the current debug level to the provided parameter.<br /></div></div>
        <div class='difftype'>Changed lines 1388-1430 from:</div>
        <div class='diffdel'><div class='diffmarkup'>typedef struct mi_export_ {<br />        /* the name of the function ( users will call this from their transport of choice */<br />        char *name;<br />        /* short description of the usage of this function */<br />        char *help;<br />        /* actual function that will get called */<br />        mi_cmd_f *cmd;<br />        /* flags for this function. Currently options are :<br />             - MI_ASYNC_RPL_FLAG - the function has an asynchronous behaviour ( eg: MI functions that send SIP messages and wait for their reply )<br />             - MI_NO_INPUT_FLAG - the function does not receive any parameters <br />        */<br />        unsigned int flags;<br />        /* parameter that will be passed when the cmd function gets called */<br />        void *param;<br />        /* the initialization function to be called by OpenSIPS ( one time ) */<br />        mi_child_init_f *init_f;<br />}mi_export_t;<br /><br />/* Example of core MI exported function */<br />static mi_export_t mi_core_cmds[] = {<br />        { &quot;uptime&quot;, &quot;prints various time information about OpenSIPS - &quot;<br />                &quot;when it started to run, for how long it runs&quot;,<br />                mi_uptime,     MI_NO_INPUT_FLAG,  0,  init_mi_uptime },<br />        { &quot;version&quot;, &quot;prints the version string of a runningOpenSIPS&quot;,<br />                mi_version,    MI_NO_INPUT_FLAG,  0,  0 },<br />        { &quot;pwd&quot;, &quot;prints the working directory of OpenSIPS&quot;,<br />                mi_pwd,        MI_NO_INPUT_FLAG,  0,  0 },<br />...<br />...<br />...<br />/* For exporting the populated array of MI functions<br />Parameters :<br />      mod_name : the name of the module exporting these functions<br />      mis : the array of exported MI functions<br />Returns :<br />      0 on success, negative in case of error<br />*/<br />int register_mi_mod( char *mod_name, mi_export_t *mis);<br /><br />/* Example of usage */<br />if (register_mi_mod( &quot;core&quot;, mi_core_cmds)&lt;0) {<br />      LM_ERR(&quot;unable to register core MI cmds\n&quot;);<br />      return -1;  </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>struct mi_root *mi_debug(struct mi_root *cmd, void *param)<br />{<br />      struct mi_root *rpl_tree;<br />      struct mi_node *node;<br />      char *p;<br />      int len;<br />      int new_debug;<br /><br />      /* check the kids member of our root node - <br />      if the input root node has kids, our command was called with parameters */<br />      node = cmd-&gt;node.kids;<br />      if (node!=NULL) {<br />            /* take the node's value and convert it to int, to make sure the parameter is valid */<br />            if (str2sint( &amp;node-&gt;value, &amp;new_debug) &lt; 0)<br />                  /* if failed to convert to int, still return a RPL tree with an &gt;=400 code and reason */<br />                  return init_mi_tree( 400, MI_SSTR(MI_BAD_PARM));<br />      } else<br />            new_debug = *debug;<br /><br />      /* all is good so far, initialize a new output ROOT tree which has a 200 OK code &amp; reason */<br />      rpl_tree = init_mi_tree( 200, MI_SSTR(MI_OK));<br />      if (rpl_tree==0)<br />              return 0;<br /><br />      p = sint2str((long)new_debug, &amp;len);<br />      /* add a new node to our output tree, which the current debug level */<br />      node = add_mi_node_child( &amp;rpl_tree-&gt;node, MI_DUP_VALUE,<br />             MI_SSTR(&quot;DEBUG&quot;),p, len);<br />      if (node==0) {<br />              free_mi_tree(rpl_tree);<br />              return 0;<br />      }<br /><br />      /* if all was successful, overwrite the actual debug level, and return our tree */<br />      *debug = new_debug;<br />      return rpl_tree;</div></div>
        <div class='difftype'>Changed lines 1427-1441 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The structures commonly used for implementing MI functions are also found in '''mi/mi.h''' :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;tip&lt;&lt;<br />For more generic information on the MI Interface as well as some examples used for running MI commands with the '''opensipsctl''' utility, see the [[http://www.opensips.org/Documentation/Interface-MI|MI Interface]] documentation page.<br />&gt;&gt;&lt;&lt;<br /><br />!!!! Statistics API<br /><br />OpenSIPS exposes a statistics API that can be used both from the core or the modules. The statistics are essentially counters that will be internally incremented/decremented by OpenSIPS and that can be fetched by the outside world ( via the MI interface ) for understanding the OpenSIPS load / health status / etc.<br />\\<br />The advantages of using the OpenSIPS Statistics API instead of regular counters is :<br />* easily fetched from the MI Interface<br />* on supported architectures, the statistics do not use an explicit lock ( the consistency is ensured by employing assembly code ), thus you will get better performance<br />\\<br />The most important structures used for extending statistics are exported by '''statistics.h''' :<br /></div></div>
        <div class='difftype'>Changed lines 1443-1478 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      input : the tree that contains the command paramenters<br />      param : the parameter provided at function registration<br />Returns :<br />      A mi_root tree containing the function reply<br />*/<br />typedef struct mi_root* (mi_cmd_f)(struct mi_root *input, void *param);<br /><br />/* below are the used structures for representing the tree root and the tree nodes */<br />struct mi_root {<br />      /* int code - similar to SIP or HTTP code */<br />      unsigned int       code;<br />      /* string reason for code - similar to SIP or HTTP reason */<br />      str                reason;<br />      /* handler in case of asynchronous MI commands */ <br />      struct mi_handler  *async_hdl;<br />      /* the actual root node in our tree */<br />      struct mi_node     node; <br />};<br /><br />struct mi_node {<br />      str value;<br />      str name;<br />      unsigned int flags;<br />      struct mi_node *kids;<br />      struct mi_node *next;<br />      struct mi_node *last; <br />      struct mi_attr *attributes;<br />};      <br />                <br />struct mi_attr{<br />        str name;<br />        str value;<br />        struct mi_attr *next;<br />};</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>typedef struct stat_export_ {<br />        char* name;                /* null terminated statistic name */<br />        unsigned short flags;      /* flags */<br />        stat_var** stat_pointer;   /* pointer to the variable's mem location *<br />                                    * NOTE - it's in shm mem */<br />} stat_export_t;</div></div>
        <div class='difftype'>Changed lines 1451-1453 from:</div>
        <div class='diffdel'><div class='diffmarkup'>As can be noted from the above tree definition, a node has a name and a value associated to it,it can have one or multiple children ( stored in kids pointer ), and also it can have a list of key-value attributes associated to it.<br />\\<br />For building the output MI tree, '''mi/tree.h''' and '''mi/attr.h''' expose the following functions :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For example, the core stats exported by OpenSIPS are defined in the following array :<br /></div></div>
        <div class='difftype'>Changed lines 1454-1492 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/* Use for creating a new output reply tree</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>stat_var* rcv_reqs;<br />stat_var* rcv_rpls;<br />stat_var* fwd_reqs;<br />stat_var* fwd_rpls;<br />stat_var* drp_reqs;<br />stat_var* drp_rpls;<br />stat_var* err_reqs;<br />stat_var* err_rpls;<br />stat_var* bad_URIs;<br />stat_var* unsupported_methods;<br />stat_var* bad_msg_hdr;<br /><br />stat_export_t core_stats[] = {<br />        {&quot;rcv_requests&quot; ,         0,  &amp;rcv_reqs              },<br />        {&quot;rcv_replies&quot; ,          0,  &amp;rcv_rpls              },<br />        {&quot;fwd_requests&quot; ,         0,  &amp;fwd_reqs              },<br />        {&quot;fwd_replies&quot; ,          0,  &amp;fwd_rpls              },<br />        {&quot;drop_requests&quot; ,        0,  &amp;drp_reqs              },<br />        {&quot;drop_replies&quot; ,         0,  &amp;drp_rpls              },<br />        {&quot;err_requests&quot; ,         0,  &amp;err_reqs              },<br />        {&quot;err_replies&quot; ,          0,  &amp;err_rpls              },<br />        {&quot;bad_URIs_rcvd&quot;,         0,  &amp;bad_URIs              },<br />        {&quot;unsupported_methods&quot;,   0,  &amp;unsupported_methods   },<br />        {&quot;bad_msg_hdr&quot;,           0,  &amp;bad_msg_hdr           },<br />        {&quot;timestamp&quot;,  STAT_IS_FUNC, (stat_var**)get_ticks   },<br />        {0,0,0}<br />};<br />(:sourceend:)<br />\\<br /><br />&gt;&gt;tip&lt;&lt;<br />As note from the above structure, statistics can either be a simple counter ( eg. rcv_requests ), but it can also be a function. Statistics function might come in handy when the developer needs to do extra processing on the raw counters before providing the final output.<br />&gt;&gt;&lt;&lt;<br /><br />\\<br />After defining your array of statistics that you want to export, one should use the following for exporting the stats to be accessible by all<br /><br />(:source lang=C -link -getcode :)<br />/* </div></div>
        <div class='difftype'>Changed lines 1494-1496 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      code : success code for this tree ( &gt;=200&lt;300 for success, anything else for errors )<br />      reason : string reasons representation for the code<br />      reason_len : length of the reason parameter</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      module - a string describing the module the current statistics belong to. Will be used when fetching the statistics via MI<br />      stats - the statistics to be registered</div></div>
        <div class='difftype'>Changed lines 1497-1509 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      A new mi_root tree, or NULL in case of error. Note that this function will allocate the node in PKG and it typically has to be returned - the freeing will be done in the MI core, after the output tree is written by the transport module */<br />struct mi_root *init_mi_tree(unsigned int code, char *reason, int reason_len);<br /><br />/* Adding a new child node to our tree - typically first called to mi_root-&gt;node.kids<br />Parameters :<br />      parent : the parent node for our newly added node<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this node needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current node needs to be duplicated in PKG<br />      name : the name of the current node<br />      name_len : length of the node's name<br />      value : the value of the current node<br />      value_len : length of the node's value</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      0 in case of success, negative in case of error</div></div>
        <div class='difftype'>Changed lines 1499-1501 from:</div>
        <div class='diffdel'><div class='diffmarkup'>struct mi_node *add_mi_node_child(struct mi_node *parent, int flags,<br />        char *name, int name_len, char *value, int value_len);<br />/* Adding a new sibling node to one of our nodes</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>int register_module_stats(char *module, stat_export_t *stats;<br />(:sourceend:)<br />\\<br />Note that '''register_module_stats''' will export the statistics, and also allocate them in SHM memory, for them to be accessible by all OpenSIPS processes.<br />\\<br /><br />&gt;&gt;important&lt;&lt;<br />Important to note here that all the above statistics related functions MUST be called in the context of the attendant process before forking is done.<br />&gt;&gt;&lt;&lt;<br /><br />\\<br />At runtime, the developer has access to the following functions for operating on statistics :<br /><br />(:source lang=C -link -getcode :)<br />/* </div></div>
        <div class='difftype'>Changed lines 1515-1522 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      brother : the brother node for our newly added node<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this node needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current node needs to be duplicated in PKG<br />      name : the name of the current node<br />      name_len : length of the node's name<br />      value : the value of the current node<br />      value_len : length of the node's value</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      var : the statistics to be updated<br />      n : the value ( if positive -&gt; stat will be increment. negative -&gt; stat will be decremented )</div></div>
        <div class='difftype'>Changed lines 1518-1528 from:</div>
        <div class='diffdel'><div class='diffmarkup'>struct mi_node *add_mi_node_sibling(struct mi_node *brother, int flags,<br />        char *name, int name_len, char *value, int value_len);<br />/* Adding a new attribute to one of our nodes<br />      node : the node we will be adding the key-value attribute to<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this attribute needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current attribute needs to be duplicated in PKG<br />      name : the name of the current attribute<br />      name_len : length of the node's attribute name<br />      value : the value of the current value<br />      value_len : length of the node's attribute value</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>void update_stat(stat_var* var, int n);<br /><br />/* <br />Parameters :<br />      var : the statistics to be reseted</div></div>
        <div class='difftype'>Changed lines 1524-1525 from:</div>
        <div class='diffdel'><div class='diffmarkup'>struct mi_attr *add_mi_attr(struct mi_node *node, int flags,                                      <br />        char *name, int name_len, char *value, int value_len)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>void reset_stat(stat_var* var);<br /><br />/*<br />Parameters :<br />      var : the statistics to be fetched<br />Returns :<br />      statistic value<br />*/<br />unsigned long get_stat_val(stat_var* var)</div></div>
        <div class='difftype'>Changed lines 1534-1578 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\<br />Further on, we will follow the implementation of the '''debug''' MI function. If called with no parameters, the function will return the current debug level in OpenSIPS. If called with one integer parameter, then the function will set the current debug level to the provided parameter.<br /><br />(:source lang=C -link -getcode :)<br />struct mi_root *mi_debug(struct mi_root *cmd, void *param)<br />{<br />      struct mi_root *rpl_tree;<br />      struct mi_node *node;<br />      char *p;<br />      int len;<br />      int new_debug;<br /><br />      /* check the kids member of our root node - <br />      if the input root node has kids, our command was called with parameters */<br />      node = cmd-&gt;node.kids;<br />      if (node!=NULL) {<br />            /* take the node's value and convert it to int, to make sure the parameter is valid */<br />            if (str2sint( &amp;node-&gt;value, &amp;new_debug) &lt; 0)<br />                  /* if failed to convert to int, still return a RPL tree with an &gt;=400 code and reason */<br />                  return init_mi_tree( 400, MI_SSTR(MI_BAD_PARM));<br />      } else<br />            new_debug = *debug;<br /><br />      /* all is good so far, initialize a new output ROOT tree which has a 200 OK code &amp; reason */<br />      rpl_tree = init_mi_tree( 200, MI_SSTR(MI_OK));<br />      if (rpl_tree==0)<br />              return 0;<br /><br />      p = sint2str((long)new_debug, &amp;len);<br />      /* add a new node to our output tree, which the current debug level */<br />      node = add_mi_node_child( &amp;rpl_tree-&gt;node, MI_DUP_VALUE,<br />             MI_SSTR(&quot;DEBUG&quot;),p, len);<br />      if (node==0) {<br />              free_mi_tree(rpl_tree);<br />              return 0;<br />      }<br /><br />      /* if all was successful, overwrite the actual debug level, and return our tree */<br />      *debug = new_debug;<br />      return rpl_tree;<br />}<br />(:sourceend:)<br />\\<br />&gt;&gt;tip&lt;&lt;<br />For more generic information on the MI Interface as well as some examples used for running MI commands with the '''opensipsctl''' utility, see the [[http://www.opensips.org/Documentation/Interface-MI|MI Interface]] documentation page.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;important&lt;&lt;<br />All statistics related code should be guarded by '''#ifdef STATISTICS''' , since the statistics are not a mandatory part of the OpenSIPS core ( they can be disabled from within menuconfig ).</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402839103-1402838983-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402839103:1402838983:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:29 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Added lines 1533-1536:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />&gt;&gt;tip&lt;&lt;<br />For more generic information on the MI Interface as well as some examples used for running MI commands with the '''opensipsctl''' utility, see the [[http://www.opensips.org/Documentation/Interface-MI|MI Interface]] documentation page.<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402838983-1402838777-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402838983:1402838777:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:26 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Added lines 2543-2546:</div>
        <div class='diffadd'><div class='diffmarkup'><br />Adding new module pseudo-variables is done by populating the '''items''' member in our module's exports structure. \\<br />For the full description of the used structures and functions for pseudo-variables, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc17|Pseudovariables]] section.<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402838777-1402838559-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402838777:1402838559:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:22 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed lines 2524-2525 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For the full description of the used structures and functions, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc27 | Management Interface API]] section.<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For the full description of the used structures and functions, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc27 | Management Interface API]] section. \\<br /><br />&gt;&gt;tip&lt;&lt;<br />The MI functions in the '''mi_cmds''' member of the exports structure will be automatically registered by the module interface.<br />&gt;&gt;&lt;&lt;<br /></div></div>
        <div class='difftype'>Added lines 2531-2540:</div>
        <div class='diffadd'><div class='diffmarkup'><br />Adding new module exported statistics is done by populating the '''stats''' member in our module's exports structure.<br />\\<br />For the full description of the used structures and functions for statistics, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc26|Statistics API]] section. \\<br /><br />&gt;&gt;tip&lt;&lt;<br />The statistics in the '''stats''' member of the exports structure will be automatically registered by the module interface.<br />If our new module named '''mynewmod''' exports a statistic called '''mycustomstat''' we will be able to fetch that statistic by using opensipsctl : \\<br />opensipsctl fifo get_statistics mynewmod mycustomstat<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402838559-1402837698-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402838559:1402837698:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:08 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed line 2524 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For the full description of the used structures and functions, please see the generic [[ttp://www.opensips.org/Documentation/Development-Manual#toc27 | Management Interface API]] section.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For the full description of the used structures and functions, please see the generic [[http://www.opensips.org/Documentation/Development-Manual#toc27 | Management Interface API]] section.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402837698-1402837609-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402837698:1402837609:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:06 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed line 2524 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For a description of the used structures and functions, please see the generic [[ttp://www.opensips.org/Documentation/Development-Manual#toc27|Management Interface API]] section.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For the full description of the used structures and functions, please see the generic [[ttp://www.opensips.org/Documentation/Development-Manual#toc27 | Management Interface API]] section.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402837609-1402837546-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402837609:1402837546:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:05 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed line 2524 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For a description of the used structures and functions, please see the generic [[Management Interface API|http://www.opensips.org/Documentation/Development-Manual#toc27]] section.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For a description of the used structures and functions, please see the generic [[ttp://www.opensips.org/Documentation/Development-Manual#toc27|Management Interface API]] section.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402837546-1402837495-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402837546:1402837495:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 03:04 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Added lines 2521-2524:</div>
        <div class='diffadd'><div class='diffmarkup'><br />Adding new module MI functions is done by populating the '''mi_cmds''' member in our module's exports structure.<br />\\<br />For a description of the used structures and functions, please see the generic [[Management Interface API|http://www.opensips.org/Documentation/Development-Manual#toc27]] section.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402837495-1402836102-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402837495:1402836102:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 02:41 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed line 2584 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!! Useful Module APIs</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Module APIs</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402836102-1402836071-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402836102:1402836071:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 15, 2014, at 02:41 PM 
        by <span class='diffauthor' title='188.27.106.202'>188.27.106.202</span> - </div>
        <div class='difftype'>Changed lines 2582-2590 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The flags member of the structure can be 0 or PROC_FLAG_INITCHILD. If PROC_FLAG_INITCHILD is provided, all the child_init function from the loaded modules will also be run in the context of our new module process.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The flags member of the structure can be 0 or PROC_FLAG_INITCHILD. If PROC_FLAG_INITCHILD is provided, all the child_init function from the loaded modules will also be run in the context of our new module process.<br /><br />!!!! Useful Module APIs<br /><br />!!!!! TM module<br /><br />!!!!! RR Module<br /><br />!!!!! Dialog Module</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1402836071-1401718885-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1402836071:1401718885:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 02, 2014, at 04:21 PM 
        by <span class='diffauthor' title='89.120.101.121'>89.120.101.121</span> - </div>
        <div class='difftype'>Changed line 2549 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Once the function exists, the entire OpenSIPS will stop.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Once the function exits, the entire OpenSIPS will stop.</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401718885:1401718681:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401718885:1401718681:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401718885:1401718681:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 02, 2014, at 04:18 PM 
        by <span class='diffauthor' title='89.120.101.121'>89.120.101.121</span> - </div>
        <div class='difftype'>Added line 2546:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 2551:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 2555:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 2559:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 2563:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 2567:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401718681-1401718623-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401718681:1401718623:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 02, 2014, at 04:17 PM 
        by <span class='diffauthor' title='89.120.101.121'>89.120.101.121</span> - </div>
        <div class='difftype'>Changed lines 2526-2576 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Adding module dedicated Processes</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Adding module dedicated Processes<br /><br />For certain use cases, our module might need to talk to external entities which are not SIP based. \\<br />For such cases, we will need to have one ( or multiple ) processes which will be dedicated to handling such communication. Examples for this include the RTPProxy module ( which handles the communication with an external RTP Proxy engine ) or even the mi_fifo and mi_datagram ( which read MI commands from a FIFO file or respectively an UDP socket ). \\<br />Adding new module parameters is done by populating the '''procs''' member in our module's exports structure. The '''proc_export_t''' structure describing extra requested processes is the following :<br />(:source lang=C -link -getcode :)<br />struct proc_export_ {<br />        char *name;                             /* name of the new task */<br />        mod_proc_wrapper pre_fork_function;     /* function to be run before the fork */<br />        mod_proc_wrapper post_fork_function;    /* function to be run after the fork */<br />        mod_proc function;                      /* actual function that will be run in the context of the new process */<br />        unsigned int no;                        /* number of processes that will be forked to run the above function */<br />        unsigned int flags;                     /* flags for our new processes - only PROC_FLAG_INITCHILD makes sense here*/<br />};<br /><br />typedef void (*mod_proc)(int no);<br />typedef int (*mod_proc_wrapper)();<br /><br />(:sourceend:)<br />\\<br />&gt;&gt;important&lt;&lt;<br />The function that will run in the context of the new process must never terminate.<br />Once the function exists, the entire OpenSIPS will stop.<br />&gt;&gt;&lt;&lt;<br />\\<br />The pre_fork_function and post_fork_function serve as helpers to create various auxiliary needed by the starting of the main process.<br />\\<br />&gt;&gt;important&lt;&lt;<br />They are both executed within the context of the attendant OpenSIPS process<br />&gt;&gt;&lt;&lt;<br />\\<br />The '''no''' member of the structure dictates how many processes OpenSIPS will fork in order to run the respective function. \\<br />It can come in handy when there is a big work-load to be handled, at your module logic will spread the work load across all the forked processes, by making use of the '''no''' parameter provided to the process function.\\<br />&gt;&gt;tip&lt;&lt;<br />The number of processes forked by OpenSIPS for a particular function is not neccesarily static.<br />&gt;&gt;&lt;&lt;<br />\\<br />Below is an example of how the MI datagram handles the forking of processes. The default value for the number of processes is MI_CHILD_NO, but that number is also configurable by the '''children_count''' parameter, as seen below.<br />(:source lang=C -link -getcode :)<br />static proc_export_t mi_procs[] = {<br />        {&quot;MI Datagram&quot;,  pre_datagram_process,  post_datagram_process,<br />                        datagram_process, MI_CHILD_NO, PROC_FLAG_INITCHILD },<br />        {0,0,0,0,0,0}<br />};<br /><br /><br />static param_export_t mi_params[] = {<br />        {&quot;children_count&quot;,      INT_PARAM,    &amp;mi_procs[0].no           },<br />(:sourceend:)<br />\\<br />The flags member of the structure can be 0 or PROC_FLAG_INITCHILD. If PROC_FLAG_INITCHILD is provided, all the child_init function from the loaded modules will also be run in the context of our new module process.</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401718623:1401701201:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401718623:1401701201:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401718623:1401701201:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 02, 2014, at 11:26 AM 
        by <span class='diffauthor' title='89.120.101.121'>89.120.101.121</span> - </div>
        <div class='difftype'>Changed lines 1053-1101 from:</div>
        <div class='diffdel'><div class='diffmarkup'>inline static rw_lock_t * lock_init_rw(void)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>inline static rw_lock_t * lock_init_rw(void);<br />(:sourceend:)<br />\\<br />In order to acquire the lock for reading purpose, one should use lock_start_read :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be acquired<br />*/<br />void lock_start_read(rw_lock_t * lock);<br />(:sourceend:)<br />\\<br />In case there is currently a write access ongoing, the lock will block until the write is done. Otherwise, the lock will be acquired immediately. \\<br />After the read is finished, you must call lock_stop_read :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be released<br />*/<br />void lock_stop_read(rw_lock_t * lock);<br />(:sourceend:)<br />\\<br />For requesting a write access, you can use lock_start_write :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be acquired<br />*/<br />void lock_start_write(rw_lock_t * lock);<br />(:sourceend:)<br />\\<br />In case there are other ongoing writes, the op will block until the other writes complete. Otherwise, the lock will block until all the existing readers finish reading. \\<br />After the write operation is finished, call lock_stop_write :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be release<br />*/<br />void lock_stop_write(rw_lock_t * lock);<br />(:sourceend:)<br />\\<br />Upon calling the above function, readers will again be allowed in the critical section. \\<br />For destroying and deallocating a rw lock, use lock_destroy_rw :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be destroyed<br />*/<br />void lock_destroy_rw(rw_lock_t * lock);</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401701201:1401700224:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401701201:1401700224:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401701201:1401700224:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 02, 2014, at 11:10 AM 
        by <span class='diffauthor' title='89.120.101.121'>89.120.101.121</span> - </div>
        <div class='difftype'>Added lines 1041-1054:</div>
        <div class='diffadd'><div class='diffmarkup'><br />A readers-writer lock is like a mutex, in that it controls access to a shared resource, allowing concurrent access to multiple threads for reading but restricting access to a single thread for writes (or other changes) to the resource. \\<br />This can prove very useful when having an use case where all the OpenSIPS processes need read-only access to a resource, but you need to have an MI command to reload that resource ( eg. from a database ). In such scenarios, using a readers-writers lock can improve performance by a considerable margin. \\<br />The API can be used by including “rw_locking.h” . The OpenSIPS generic lock is defined by the '''rw_lock_t''' structure. <br /><br />Allocating a new readers-writers lock into shared memory and initializing it is done by calling lock_init_rw :<br /><br />(:source lang=C -link -getcode :)<br />/*<br />Returns :<br />      A shared memory allocated rw lock, or NULL in case of an error.<br />*/<br />inline static rw_lock_t * lock_init_rw(void)<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401700224-1401655342-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401700224:1401655342:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 10:42 PM 
        by <span class='diffauthor' title='188.27.107.106'>188.27.107.106</span> - </div>
        <div class='difftype'>Added lines 1039-1040:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!!! Readers-Writers Locking API</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401655342-1401653041-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401655342:1401653041:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 10:04 PM 
        by <span class='diffauthor' title='188.27.107.106'>188.27.107.106</span> - </div>
        <div class='difftype'>Added lines 2432-2454:</div>
        <div class='diffadd'><div class='diffmarkup'>(:source lang=C -link -getcode :)<br />static int w_lb_is_dst4(struct sip_msg *msg,char *ip,char *port,char *grp,<br />                        char *active)<br />{<br />        int ret, group;<br /><br />        if (fixup_get_ivalue(msg, (gparam_p)grp, &amp;group) != 0) {<br />                LM_ERR(&quot;Invalid lb group pseudo variable!\n&quot;);<br />                return -1;<br />        }<br /><br />        ret = lb_is_dst(*curr_data, msg, (pv_spec_t*)ip, (pv_spec_t*)port,<br />                        group, (int)(long)active);<br />(:sourceend:)<br />\\<br />As we can see, the input char* parameters are casted to their according valus after fixup. \\<br />Again, '''mod_fix.h''' provides varius functions for accessing the results of the fixup.In our example, '''fixup_get_ivalue''' is used to get the provided integer value ( either directly from the plaintext provided integer, or it will extract the integer value from the spec that was parsed at fixup ). Also, note how the active parameter is cast directly to long, since we're accepting only plain-text integers for that parameter, and it has been already converted for us at fixup time.<br /><br />&gt;&gt;important&lt;&lt;<br />The return code of the script exported functions from the module are very important. \\<br />A strictly positive return code will mean success, while a stricly negative return code will signal a failure \\<br />Returning 0 in a function exporting to the script will STOP the script execution after the function ends. Use a 0 return code with caution and only when absolutely necessary.<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401653041-1401652942-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401653041:1401652942:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 10:02 PM 
        by <span class='diffauthor' title='188.27.107.106'>188.27.107.106</span> - </div>
        <div class='difftype'>Changed lines 2384-2385 from:</div>
        <div class='diffdel'><div class='diffmarkup'>* if we accept it, our functions can accept pseudo-variables into the provided parameters. In this case, the fixup can be used to lookup the pvar's spec, and then at runtime we will be left just with evaluating that specific pvar.<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>* if we accept it, our functions can accept pseudo-variables into the provided parameters. In this case, the fixup can be used to lookup the pvar's spec, and then at runtime we will be left just with evaluating that specific pvar in the context of the current SIP message<br />\\<br />Further on we will follow the implementation of '''lb_is_destination''' from the load_balancer module, to fully grasp the concept. The function definition is the following :<br />(:source lang=C -link -getcode :)<br />        {&quot;lb_is_destination&quot;,(cmd_function)w_lb_is_dst4,     4,    fixup_is_dst,<br />                0, REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE},<br />(:sourceend:)<br />\\<br />As noted, the function receives 4 parameters. The desired usage case for '''lb_is_destination(ip,port,group,active)''' is the following :<br />* ip - string or pvar with the IP to check<br />* port - string or pvar with the Port to check - if empty, we skip any port check<br />* group - integer or pvar containing integer with the load_balancer group to check<br />* active - integer. if 1, we accept just active destinations for our check<br />\\<br />Knowing these, the fixup_is_dst is the following :<br />(:source lang=C -link -getcode :)<br />static int fixup_is_dst(void** param, int param_no)<br />{<br />        if (param_no==1) {<br />                /* the ip to test */<br />                return fixup_pvar(param);<br />        } else if (param_no==2) {<br />                /* the port to test */<br />                if (*param==NULL) {<br />                        return 0;<br />                } else if ( *((char*)*param)==0 ) {<br />                        pkg_free(*param);<br />                        *param = NULL;<br />                        return 0;<br />                }<br />                return fixup_pvar(param);<br />        } else if (param_no==3) {<br />                /* the group to check in */<br />                return fixup_igp(param);<br />        } else if (param_no==4) {<br />                /*  active only check ? */<br />                return fixup_uint(param);<br />        } else {<br />                LM_CRIT(&quot;bug - too many params (%d) in lb_is_dst()\n&quot;,param_no);<br />                return -1;<br />        }<br />}<br />(:sourceend:)<br />\\<br />The fixup function will get called for each parameter provided, with the param_no parameter representing the index of the parameter we are parsing ( starting with 1, since the first parameter is the actual SIP msg ) \\<br />'''mod_fix.h''' exports many helper functions that can be used for fixups. See the file for a full list of currently implemented fixups.<br />\\<br />The above fixup functions will replace the parameter that you will receive in the main function with their respective output. Thus, in the main function you will not receive any more the plain text parameters that were provided by the script writer, but rather you'll receive the pvar's spec after it was parsed, or directly the integer value supplied by the script writer. Here is how the '''w_lb_is_dst4''' handles the provided parameters after fixup :</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401652942-1401652774-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401652942:1401652774:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 09:59 PM 
        by <span class='diffauthor' title='188.27.107.106'>188.27.107.106</span> - </div>
        <div class='difftype'>Changed line 2358 from:</div>
        <div class='diffdel'><div class='diffmarkup'>As can be seen, all the OpenSIPS module functions receive string parameters ONLY, and a function can have a maximum of 6 parameters. The SIP message that is currently being processed is also transmitted as the first parameter, although this is transparent to the script writes ( he just provides the parameters idx 1 to 5 )</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>As can be seen, all the OpenSIPS module functions receive string parameters ONLY, and a function can have a maximum of 6 parameters. The SIP message that is currently being processed is also transmitted as the first parameter, although this is transparent to the script writer ( he just provides the parameters idx 1 to 5 )</div></div>
        <div class='difftype'>Added lines 2380-2385:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />A very important concept to grasp here is the '''fixup_function'''. This function is called just once, when the script is initially parsed, and it serves as an optimization, where the provided parameters are further parsed so that we can speed up the runtime function. \\<br />Examples for the use cases of the fixup function, just to provide a few :<br />* since all our module parameters are strings, sometimes our module might need an integer parameter to be passed in that string. The fixup function can be used to convert that string to integer only once<br />* if we accept it, our functions can accept pseudo-variables into the provided parameters. In this case, the fixup can be used to lookup the pvar's spec, and then at runtime we will be left just with evaluating that specific pvar.<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401652774-1401652677-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401652774:1401652677:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 09:57 PM 
        by <span class='diffauthor' title='188.27.107.106'>188.27.107.106</span> - </div>
        <div class='difftype'>Added lines 2331-2379:</div>
        <div class='diffadd'><div class='diffmarkup'><br />Adding new module parameters is done by populating the '''cmds''' member in our module's '''exports''' structure. \\<br />The exported functions structure is the following :<br />(:source lang=C -link -getcode :)<br />struct cmd_export_ {<br />        char* name;             /* null terminated command name */<br />        cmd_function function;  /* pointer to the corresponding function */<br />        int param_no;           /* number of parameters used by the function */<br />        fixup_function fixup;   /* pointer to the function called to &quot;fix&quot; the<br />                                                           parameters */<br />        free_fixup_function<br />                                free_fixup; /* pointer to the function called to free the<br />                                                           &quot;fixed&quot; parameters */<br />        int flags;              /* Function flags */<br />};<br />(:sourceend:)<br />\\<br />Very similar to the params member in the exports structure, the cmds member MUST be NULL terminated. \\<br />At startup, OpenSIPS tries to locate each function called in the script either in the core functions, or in the list of functions exported by all list modules.<br />\\<br /><br />&gt;&gt;tip&lt;&lt;<br />In order to overload a particular function, you can simply list it twice with the same name in the cmds structure, but change the param_no field.<br />&gt;&gt;&lt;&lt;<br /><br />A script function exported by a module has the following definition :<br />(:source lang=C -link -getcode :)<br />As can be seen, all the OpenSIPS module functions receive string parameters ONLY, and a function can have a maximum of 6 parameters. The SIP message that is currently being processed is also transmitted as the first parameter, although this is transparent to the script writes ( he just provides the parameters idx 1 to 5 )<br />(:sourceend:)<br />\\<br /><br />&gt;&gt;important&lt;&lt;<br />The flags member in the cmd_export_ structure dictates where within the OpenSIPS script can that particular function be called.<br />&gt;&gt;&lt;&lt;<br /><br />Current options here are :<br />(:source lang=C -link -getcode :)<br />#define REQUEST_ROUTE 1   /*!&lt; Request route block */<br />#define FAILURE_ROUTE 2   /*!&lt; Negative-reply route block */<br />#define ONREPLY_ROUTE 4   /*!&lt; Received-reply route block */<br />#define BRANCH_ROUTE  8   /*!&lt; Sending-branch route block */<br />#define ERROR_ROUTE  16   /*!&lt; Error-handling route block */<br />#define LOCAL_ROUTE  32   /*!&lt; Local-requests route block */<br />#define STARTUP_ROUTE 64  /*!&lt; Startup route block */<br />#define TIMER_ROUTE  128  /*!&lt; Timer route block */<br />#define EVENT_ROUTE  256  /*!&lt; Event route block */<br />(:sourceend:)<br />\\<br />Allowing multiple types of routes by provided a bitmask of the above values is also supported.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401652677-1401636033-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401652677:1401636033:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 05:20 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Changed line 2280 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Adding module parameters</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Adding module Parameters</div></div>
        <div class='difftype'>Changed lines 2328-2338 from:</div>
        <div class='diffdel'><div class='diffmarkup'>(:sourceend:)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />!!!!! Adding module Functions<br /><br />!!!!! Adding module MI Functions<br /><br />!!!!! Adding module Statistics<br /><br />!!!!! Adding module Pseudo-variables<br /><br />!!!!! Adding module dedicated Processes</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401636033:1401635656:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401636033:1401635656:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401636033:1401635656:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 05:14 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Changed line 2325 from:</div>
        <div class='diffdel'><div class='diffmarkup'>        LM_INFO(&quot;Our parameter has been set : value is %d\n&quot;,(char *)val);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>        LM_INFO(&quot;Our parameter has been set : value is %s\n&quot;,(char *)val);</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401635656-1401635572-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401635656:1401635572:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 05:12 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Added lines 2281-2328:</div>
        <div class='diffadd'><div class='diffmarkup'>Adding new module parameters is done by populating the '''params''' member in our module's '''exports''' structure. At OpenSIPS startup, OpenSIPS will parse the provided script and set our internal variables accordingly to what the OpenSIPS script writer has configured.<br />The parameter definition ( param_export_t ) is the following :<br /><br />(:source lang=C -link -getcode :)<br />struct param_export_ {<br />        char* name;             /*!&lt; null terminated param. name */<br />        modparam_t type;        /*!&lt; param. type */<br />        void* param_pointer;    /*!&lt; pointer to the param. memory location */<br />};<br />(:sourceend:)<br />\\<br />The OpenSIPS modules can export both string and integer parameters. \\<br />Find below some examples for each of them. Note how the param_export_t structure does not receive any length parameters as to indicate how many parameters the module exports - rather, the structure must end with a row full of 0,<br /><br />(:source lang=C -link -getcode :)<br />int enable_stats = 0;<br />static str db_url = {NULL,0};<br /><br />static param_export_t mod_params[]={<br />        { &quot;enable_stats&quot;,          INT_PARAM, &amp;enable_stats         },<br />        { &quot;db_url&quot;,                STR_PARAM, &amp;db_url.s             },<br />        { 0,0,0 }<br />}<br />(:sourceend:)<br />\\<br />Example of setting these parameters from the OpenSIPS script, for our '''ournewmod''' module.<br />(:source lang=C -link -getcode :)<br />loadmodule &quot;ournewmod.so&quot;<br /><br />modparam(&quot;ournewmod&quot;,&quot;enable_stats&quot;, 1)<br />modparam(&quot;ournewmod&quot;,&quot;db_url&quot;,&quot;mysql://vlad:mypw@localhost/opensips&quot;)<br />(:sourceend:)<br />\\<br />Also, OpenSIPS supports triggering a module's internal function when the script writer set a particular parameter. This can prove useful if the provided parameter needs to be converted to a form that the module knows how to process, or simply if one parameter should be able to be set multiple times. \\<br />Find an example of such parameters below, where an NoSQL URL can be set multiple times in order to initialize as many back-end connections :<br /><br />(:source lang=C -link -getcode :)<br />static param_export_t params[]={<br />        { &quot;cachedb_url&quot;,                 STR_PARAM|USE_FUNC_PARAM, (void *)&amp;set_connection},<br />        {0,0,0}<br />};<br /><br />int set_connection(unsigned int type, void *val)<br />{<br />        LM_INFO(&quot;Our parameter has been set : value is %d\n&quot;,(char *)val);<br />        /* continue processing, eg : add our new parameter to a list to be further processed */<br />}<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401635572-1401635286-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401635572:1401635286:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 05:08 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Added lines 2270-2278:</div>
        <div class='diffadd'><div class='diffmarkup'><br />This function must be specified in the '''destroy_function''' member of our module_exports exports structure. \\<br />It is ran from within a single process' context ( the attendant ), when OpenSIPS is about to shutdown. \\<br />The purpose of the function is to cleanup various resources that OpenSIPS has been using ( shared memory, DB connections, etc ). Also, the '''destroy_function''' is a good time to save whatever state that the module was keeping into a persistent storage, so that they can be loaded afterwards, when OpenSIPS starts. ( eg. the dialog module saves all the dialog states in the database in the destroy function ). \\<br />Prototype of the function is<br /><br />(:source lang=C -link -getcode :)<br />typedef void (*destroy_function)();<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401635286-1401635057-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401635286:1401635057:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 05:04 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Added line 2262:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401635057-1401635016-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401635057:1401635016:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 05:03 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Changed lines 2229-2230 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br /></div></div>
        <div class='difftype'>Added lines 2237-2266:</div>
        <div class='diffadd'><div class='diffmarkup'><br />This function must be specified in the '''init_child_f''' member of our module_exports exports structure. \\<br />It is ran from within the context of ALL OpenSIPS processes, right after the new processes has been forked. \\<br />The purpose of the function is to create various connectors ( db, cachedb, etc ) which should be different for each created OpenSIPS process and to initialize various other variables depending on the OpenSIPS process context we are currently in. \\<br /><br />Prototype of the function is<br /><br />(:source lang=C -link -getcode :)<br />/* MUST return 0 in case of success, anything else in case of error */<br />typedef int (*child_init_function)(int rank);<br />(:sourceend:)<br />\\<br />The function will receive an integer parameter, indicating the type of OpenSIPS process that is currently running our function.<br />Below are all the available options :<br /><br />(:source lang=C -link -getcode :)<br />#define PROC_MAIN      0  /* Main opensips process */<br />#define PROC_TIMER    -1  /* Timer attendant process */<br />#define PROC_MODULE   -2  /* Extra process requested by modules */<br />#define PROC_TCP_MAIN -4  /* TCP main process */<br />#define PROC_BIN      -8  /* Any binary interface listener */<br />(:sourceend:)<br />\\<br />A positive value for our rank parameter denotes that we are currently operating in the context of an OpenSIPS listener ( UDP, TCP or SCTP ).<br />\\<br />&gt;&gt;tip&lt;&lt;<br />If we must do time consuming operations ( eg. load many rows from a database ) , we should be doing this inside the child_init() function for a single process ( eg. rank == 1 would be the context of our first UDP listener) , instead of the mod_init() function. <br />\\<br />This will make OpenSIPS startup faster, and also we will be able to process traffic faster ( at least the traffic that does not explicitly depend on having our module's internal data fully populated ).<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401635016:1401634765:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401635016:1401634765:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401635016:1401634765:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 04:59 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Added lines 2218-2233:</div>
        <div class='diffadd'><div class='diffmarkup'><br />This function must be specified in the '''init_f''' member of our module_exports exports structure. \\<br />It is ran from within a single process' context ( the attendant ), after the full OpenSIPS config has been parsed ( our own module parameters included ), and all the helper APIs are initialized at this point ( shared memory, locking, timer processes, etc ). \\<br />The purpose of the function is to check the integrity of how the module was configured from the OpenSIPS script, to initialize needed structures, etc. Also, some critical resources ( like new timer processes, see above section ) can ONLY be initialized from the mod_init() function of our new modules. \\<br /><br />Prototype of the function is<br /><br />(:source lang=C -link -getcode :)<br />/* MUST return 0 in case of success, anything else in case of error */<br />typedef int (*init_function)(void);<br />(:sourceend:)<br /><br />&gt;&gt;tip&lt;&lt;<br />Since this function is called from the context of only one process, after OpenSIPS forks, each OpenSIPS process will receive a copy of what the attendat process had. \\<br />Due to this, do NOT use the mod_init function to initialize structures / connections that should have different instances for each OpenSIPS process.<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401634765-1401634659-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401634765:1401634659:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 04:57 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Added line 2200:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 2204:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401634659:1401634565:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401634659:1401634565:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401634659:1401634565:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 04:56 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Added lines 2102-2103:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Introduction<br /></div></div>
        <div class='difftype'>Changed lines 2167-2221 from:</div>
        <div class='diffdel'><div class='diffmarkup'>(:sourceend:)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />!!!!! Compiling a module<br /><br />Further on, we will be following the various options we have in building our new module, named '''ournewmod'''.<br />\\<br />After creating the '''ournewmod''' folder in the OpenSIPS modules/ path, we should create a Makefile for our module, located also in the '''ournewmod''' folder.<br />The most basic Makefile for a module with no external library dependencies is the following :<br /><br />(:source lang=C -link -getcode :)<br /># $Id$<br />#<br /># WARNING: do not run this directly, it should be run by the master Makefile<br /><br />include ../../Makefile.defs<br />auto_gen=<br />NAME=ournewmod.so<br />LIBS=<br /><br />include ../../Makefile.modules<br />(:sourceend:)<br />\\<br />If the module has external library dependencies, they should be linked in the module's Makefile as well. Eg, the cachedb_memcached module :<br />(:source lang=C -link -getcode :)<br />include ../../Makefile.defs<br />auto_gen=<br />NAME=cachedb_memcached.so<br />DEFS+=-I$(LOCALBASE)/include<br />LIBS=-L$(LOCALBASE)/lib -lmemcached<br /><br />include ../../Makefile.modules<br />(:sourceend:)<br />\\<br />&gt;&gt;important&lt;&lt;<br />If our new module depends on external libraries, the module must not be left to compile by default !<br />&gt;&gt;&lt;&lt;<br />This must be done by editing the '''Makefile.conf.template''' file - where we specify which modules are to not be compiled by default, along with the dependencies they have. \\<br />We should add a new line to Makefile.conf.template, with the following format :<br />(:source lang=C -link -getcode :)<br />modulename= Module Description | module dependency<br />(:sourceend:)<br />\\<br />Also, we should modify '''Makefile.conf.template''' to add our new module's name to the '''exclude_modules''' list of modules that will not compile by default.<br /><br />!!!!! Initializing the module<br /><br />In the context of initializing our new module, there are two types of functions that will help us :<br /><br />!!!!!! mod_init<br /><br />!!!!!! child_init<br /><br />!!!!! Destroying the module<br /><br />!!!!! Adding module parameters</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401634565-1401634285-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401634565:1401634285:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 04:51 PM 
        by <span class='diffauthor' title='213.233.84.72'>213.233.84.72</span> - </div>
        <div class='difftype'>Changed lines 2100-2165 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!! Module Development</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Module Development<br /><br />Due to the OpenSIPS modular architecture, the easiest way to add new features ( new parameters, script functions, MI function etc ) is to incorporate them into a new '''OpenSIPS module'''. \\<br />An OpenSIPS module is actually a shared library ( .so file ) which OpenSIPS can dinamically load at OpenSIPS startup, if the module is loaded from within the OpenSIPS script, by using the '''loadmodule''' directive :<br /><br />(:source lang=C -link -getcode :)<br />loadmodule &quot;mynewmod.so&quot;<br />(:sourceend:)<br /><br />\\<br />Upon loading a new module, the OpenSIPS core will lookup the '''exports''' variable, of type '''struct module_exports'''. This structure and variable are of the utmost importance when developing a new OpenSIPS module<br /><br />(:source lang=C -link -getcode :)<br />        struct module_exports{<br />              char* name;                     /*!&lt; null terminated module name */<br />              char *version;                  /*!&lt; module version */<br />              char *compile_flags;            /*!&lt; compile flags used on the module */<br />              unsigned int dlflags;           /*!&lt; flags for dlopen */<br /><br />              cmd_export_t* cmds;             /*!&lt; null terminated array of the exported<br />                                           commands */<br />              param_export_t* params;         /*!&lt; null terminated array of the exported<br />                                           module parameters */<br /><br />              stat_export_t* stats;           /*!&lt; null terminated array of the exported<br />                                           module statistics */<br /><br />              mi_export_t* mi_cmds;           /*!&lt; null terminated array of the exported<br />                                           MI functions */<br /><br />              pv_export_t* items;             /*!&lt; null terminated array of the exported<br />                                           module items (pseudo-variables) */<br /><br />              proc_export_t* procs;           /*!&lt; null terminated array of the additional<br />                                           processes reqired by the module */<br /><br />              init_function init_f;           /*!&lt; Initialization function */<br />              response_function response_f;   /*!&lt; function used for responses,<br />                                           returns yes or no; can be null */<br />              destroy_function destroy_f;     /*!&lt; function called when the module should<br />                                           be &quot;destroyed&quot;, e.g: on opensips exit */<br />              child_init_function init_child_f;/*!&lt; function called by all processes<br />                                            after the fork */<br />        };<br />(:sourceend:)<br />\\<br />The module_exports contents ( along with the above coments ) are self-explanatory. \\<br /><br />Further on, we will discuss about each member of the module_exports structure and how it is meant to be used when building a nw OpenSIPS. Purely as an example, See below the exports used by the dialog module<br />(:source lang=C -link -getcode :)<br />        struct module_exports exports= {<br />              &quot;dialog&quot;,        /* module's name */<br />              MODULE_VERSION,<br />              DEFAULT_DLFLAGS, /* dlopen flags */<br />              cmds,            /* exported functions */<br />              mod_params,      /* param exports */<br />              mod_stats,       /* exported statistics */<br />              mi_cmds,         /* exported MI functions */<br />              mod_items,       /* exported pseudo-variables */<br />              0,               /* extra processes */<br />              mod_init,        /* module initialization function */<br />              0,               /* reply processing function */<br />              mod_destroy,<br />              child_init       /* per-child init function */<br />        };<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401634285:1401623465:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401634285:1401623465:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401634285:1401623465:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>June 01, 2014, at 01:51 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Added lines 1890-1891:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;tip&lt;&lt;</div></div>
        <div class='difftype'>Changed lines 1893-1894 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For such scenarios, using the '''fetch_result''' API function is highly recommended :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For such scenarios, using the '''fetch_result''' API function is highly recommended<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401623465-1401563567-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401623465:1401563567:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 09:12 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Changed lines 2093-2095 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!! Event Interface<br /><br />!!!! BIN Interface</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Event Interface API<br /><br />!!!! BIN Interface API</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401563567-1401563522-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401563567:1401563522:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 09:12 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Added lines 2092-2095:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!! Event Interface<br /><br />!!!! BIN Interface</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401563522-1401563283-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401563522:1401563283:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 09:08 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Added line 2072:</div>
        <div class='diffadd'><div class='diffmarkup'>For running all other database queries, one should use the '''raw_query''' API function. </div></div>
        <div class='difftype'>Deleted line 2073:</div>
        <div class='diffdel'><div class='diffmarkup'>For running all other database queries, one should use the '''raw_query''' API function. </div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401563283-1401563258-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401563283:1401563258:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 09:07 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Added lines 2036-2089:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br />\\<br />Sometimes, for optimizing database operations, it is useful to know the auto-increment primary key value upon inserting / updating a record. For such cases, the '''last_inserted_id''' API call can be used :<br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Retrieve the last inserted ID in a table.<br /> *<br /> * The function returns the value generated for an AUTO_INCREMENT column by the<br /> * previous INSERT or UPDATE  statement. Use this function after you have<br /> * performed an INSERT statement into a table that contains an AUTO_INCREMENT<br /> * field.<br /> * \param _h structure representing database connection<br /> * \return returns the ID as integer or returns 0 if the previous statement<br /> * does not use an AUTO_INCREMENT value.<br /> */<br />typedef int (*db_last_inserted_id_f) (const db_con_t* _h);<br />(:sourceend:)<br />\\<br />Also, when we want to insert a row into a table, and update the row in case of duplicate key errors, we should use the '''insert_update''' API call :<br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Insert a row into specified table, update on duplicate key.<br /> *<br /> * The function implements the INSERT ON DUPLICATE KEY UPDATE SQL directive.<br /> * It is possible to insert a row and update if one already exists.<br /> * The old row will not deleted before the insertion of the new data.<br /> * \param _h structure representing database connection<br /> * \param _k key names<br /> * \param _v values of the keys<br /> * \param _n number of key=value pairs<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */<br />typedef int (*db_insert_update_f) (const db_con_t* _h, const db_key_t* _k,<br />                                const db_val_t* _v, const int _n);<br />(:sourceend:)<br />\\<br />(:source lang=C -link -getcode :)<br />For running all other database queries, one should use the '''raw_query''' API function. <br />/**<br /> * \brief Raw SQL query.<br /> *<br /> * This function can be used to do database specific queries. Please<br /> * use this function only if needed, as this creates portability issues<br /> * for the different databases. Also keep in mind that you need to<br /> * escape all external data sources that you use. You could use the<br /> * escape_common and unescape_common functions in the core for this task.<br /> * \see escape_common<br /> * \see unescape_common<br /> * \param _h structure representing database connection<br /> * \param _s the SQL query<br /> * \param _r structure for the result<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */<br />typedef int (*db_raw_query_f) (const db_con_t* _h, const str* _s, db_res_t** _r);</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401563258-1401562666-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401563258:1401562666:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 08:57 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Added lines 1996-2035:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br />\\<br />Updating rows in a table can be done by calling the '''update''' API function :<br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Update some rows in the specified table.<br /> *<br /> * The function implements UPDATE SQL directive. It is possible to modify one<br /> * or more rows in a table using this function.<br /> * \param _h database connection handle<br /> * \param _k array of keys (column names) that will be matched<br /> * \param _o array of operators to be used with key-value pairs<br /> * \param _v array of values that the row must match to be modified<br /> * \param _uk array of keys (column names) that will be modified<br /> * \param _uv new values for keys specified in _k parameter<br /> * \param _n number of key-value pairs in _k and _v parameters<br /> * \param _un number of key-value pairs in _uk and _uv parameters<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */<br />typedef int (*db_update_f) (const db_con_t* _h, const db_key_t* _k, const db_op_t* _o,<br />                                const db_val_t* _v, const db_key_t* _uk, const db_val_t* _uv,<br />                                const int _n, const int _un);<br />(:sourceend:)<br />\\<br />Replacing rows in a database table can be done with the '''replace''' function from the API :<br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Insert a row and replace if one already exists.<br /> *<br /> * The function implements the REPLACE SQL directive. It is possible to insert<br /> * a row and replace if one already exists. The old row will be deleted before<br /> * the insertion of the new data.<br /> * \param _h structure representing database connection<br /> * \param _k key names<br /> * \param _v values of the keys<br /> * \param _n number of key=value pairs<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br />*/<br />typedef int (*db_replace_f) (const db_con_t* handle, const db_key_t* keys,<br />                                const db_val_t* vals, const int n);</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401562666:1401561120:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401562666:1401561120:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401562666:1401561120:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 08:32 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Deleted line 1955:</div>
        <div class='diffdel'><div class='diffmarkup'>(:source lang=C -link -getcode :)</div></div>
        <div class='difftype'>Added lines 1957-1958:</div>
        <div class='diffadd'><div class='diffmarkup'><br />(:source lang=C -link -getcode :)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401561120-1401561080-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401561120:1401561080:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 08:31 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Added lines 1954-1994:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br />\\<br />(:source lang=C -link -getcode :)<br />Inserting rows in a table can be done by calling the '''insert''' API function :<br />/**<br /> * \brief Insert a row into the specified table.<br /> *<br /> * This function implements INSERT SQL directive, you can insert one or more<br /> * rows in a table using this function.<br /> * \param _h database connection handle<br /> * \param _k array of keys (column names)<br /> * \param _v array of values for keys specified in _k parameter<br /> * \param _n number of keys-value pairs int _k and _v parameters<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */<br />typedef int (*db_insert_f) (const db_con_t* _h, const db_key_t* _k,<br />                                const db_val_t* _v, const int _n);<br /><br />(:sourceend:)<br />\\<br />Deleting rows from a table is accomplished by calling the '''delete''' API function :<br /><br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Delete a row from the specified table.<br /> *<br /> * This function implements DELETE SQL directive, it is possible to delete one or<br /> * more rows from a table.<br /> * If _k is NULL and _v is NULL and _n is zero, all rows are deleted, the<br /> * resulting table will be empty.<br /> * If _o is NULL, the equal operator &quot;=&quot; will be used for the comparison.<br /> *<br /> * \param _h database connection handle<br /> * \param _k array of keys (column names) that will be matched<br /> * \param _o array of operators to be used with key-value pairs<br /> * \param _v array of values that the row must match to be deleted<br /> * \param _n number of keys-value parameters in _k and _v parameters<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */<br />typedef int (*db_delete_f) (const db_con_t* _h, const db_key_t* _k, const db_op_t* _o,<br />                                const db_val_t* _v, const int _n);</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401561080-1401560310-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401561080:1401560310:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 08:18 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Added lines 1910-1953:</div>
        <div class='diffadd'><div class='diffmarkup'>        /* check if our used DB driver supports fetching a limited number of rows */<br />        if (DB_CAPABILITY(*dr_dbf, DB_CAP_FETCH)) {<br />                /* run our query as usual, but DO NOT provide a result set pointer ( last parameter 0 ) */<br />                if ( dr_dbf-&gt;query( db_hdl, 0, 0, 0, columns, 0, db_cols, 0, 0 ) &lt; 0) {<br />                        LM_ERR(&quot;DB query failed\n&quot;);<br />                        goto error;<br />                }<br />                /* estimate how many rows we can fit into our current PKG memory */<br />                no_rows = estimate_available_rows( 4+32+15+4+32+4+128+4+32+4, db_cols);<br />                if (no_rows==0) no_rows = 10;<br />                /* try to fetch our rows */<br />                if(dr_dbf-&gt;fetch_result(db_hdl, &amp;res, no_rows )&lt;0) {<br />                        LM_ERR(&quot;Error fetching rows\n&quot;);<br />                        goto error;<br />                }<br />        } else {<br />                /* no fetching rows support - fallback to full rows loading */<br />                if ( dr_dbf-&gt;query(db_hdl,0,0,0,columns,0,db_cols,0,&amp;res) &lt; 0) {<br />                        LM_ERR(&quot;DB query failed\n&quot;);<br />                        goto error;<br />                }<br />        }<br /><br />        do {<br />                for(i=0; i &lt; RES_ROW_N(res); i++) {<br />                        row = RES_ROWS(res) + i;<br />                        /* start processing our loaded rows */<br />                }<br /><br />                if (DB_CAPABILITY(*dr_dbf, DB_CAP_FETCH)) {<br />                        /* any more rows to fetch ? */<br />                        if(dr_dbf-&gt;fetch_result(db_hdl, &amp;res, no_rows)&lt;0) {<br />                                LM_ERR( &quot;fetching rows (1)\n&quot;);<br />                                goto error;<br />                        }<br />                        /* success in fetching more rows - continue the loop */<br />                } else {<br />                        /* we were not supporting fetching rows in the first place, processed everything */<br />                        break;<br />                }<br />        } while(RES_ROW_N(res)&gt;0);<br /><br />        dr_dbf-&gt;free_result(db_hdl, res);<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401560310-1401559833-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401560310:1401559833:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 08:10 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Added lines 1888-1909:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br />\\<br />Sometimes, especially when querying large tables, it is not desirable to fetch all the rows in one chunk, since that might lead to the filling of the OpenSIPS private memory. \\<br />For such scenarios, using the '''fetch_result''' API function is highly recommended :<br /><br />(:source lang=C -link -getcode :)<br />/**                                                               <br /> * \brief Fetch a number of rows from a result.                                 <br /> *<br /> * The function fetches a number of rows from a database result. If the number <br /> * of wanted rows is zero, the function returns anything with a result of zero.<br /> * \param _h structure representing database connection<br /> * \param _r structure for the result<br /> * \param _n the number of rows that should be fetched            <br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0         <br /> */<br />typedef int (*db_fetch_result_f) (const db_con_t* _h, db_res_t** _r, const int _n);<br />(:sourceend:)<br />\\<br />Find below a full example of using '''fetch_result''' :<br /><br />(:source lang=C -link -getcode :)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401559833-1401559423-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401559833:1401559423:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 08:03 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401559423-1401559399-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401559423:1401559399:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 08:03 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Changed lines 1873-1888 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />As can be seen from the example above, any successful call to the '''query''' SQL function must be followed by the freeing of the returned result set, which is done by calling the '''free_result''' API function :<br /><br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Free a result allocated by db_query.<br /> *<br /> * This function frees all memory allocated previously in db_query. Its<br /> * neccessary to call this function on a db_res_t structure if you don't need the<br /> * structure anymore. You must call this function before you call db_query again!<br /> * \param _h database connection handle<br /> * \param _r pointer to db_res_t structure to destroy<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */<br />typedef int (*db_free_result_f) (db_con_t* _h, db_res_t* _r);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401559399-1401559202-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401559399:1401559202:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>May 31, 2014, at 08:00 PM 
        by <span class='diffauthor' title='79.112.219.219'>79.112.219.219</span> - </div>
        <div class='difftype'>Changed lines 1821-1823 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>db_row_t * rows;<br />db_val_t * values;<br /></div></div>
        <div class='difftype'>Changed lines 1848-1852 from:</div>
        <div class='diffdel'><div class='diffmarkup'>if (RES_ROW_N(db_res) &lt;= 0) {</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>nr_rows = RES_ROW_N(db_res);<br />rows = RES_ROWS(res);<br /><br /><br />if (nr_rows &lt;= 0) {</div></div>
        <div class='difftype'>Added lines 1857-1870:</div>
        <div class='diffadd'><div class='diffmarkup'><br />for (i=0;i&lt;nr_rows;i++) {<br />      values = ROW_VALUES(rows + i);<br />      if (VAL_NULL(values)) {<br />            LM_WARN(&quot;Column value should not be null - skipping \n&quot;);<br />            continue;<br />      }<br /><br />      LM_DBG(&quot;We have feteched %s\n&quot;,VAL_STRING(values));<br />      /* do further rows processing here */<br />}<br /><br />sql_functions.free_result(db_handle, db_res);<br />return 0;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1401559202-1398186541-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1401559202:1398186541:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 07:09 PM 
        by <span class='diffauthor' title='213.233.85.84'>213.233.85.84</span> - </div>
        <div class='difftype'>Changed lines 1814-1851 from:</div>
        <div class='diffdel'><div class='diffmarkup'># TODO</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* we will work on 'mytable' table with just two columns, keyname and value.<br />The select query we will run is 'select value from mytable where keyname='abc';'<br />*/<br />db_key_t key;<br />db_val_t val;<br />db_key_t col;<br />db_res_t* db_res = NULL;<br /><br />#define KEY_COL &quot;keyname&quot;<br />#define VALUE_COL &quot;value&quot;<br />str key_column = str_init(KEY_COL);<br />str value_column = str_init(VALUE_COL);<br />str db_table = str_init(&quot;mytable&quot;);<br /><br />val.type = DB_STR;<br />val.nul = 0;<br />val.val.str_val.s = &quot;abc&quot;;<br />val.val.str_val.len = 3;<br /><br />key = &amp;key_column;<br />col = &amp;value_column;<br /><br />if (sql_functions.use_table(db_handle, &amp;db_table) &lt; 0) {<br />      LM_ERR(&quot;sql use_table failed\n&quot;);<br />      return -1;<br />}<br /><br />if(sql_functions.query(db_handle, &amp;key, NULL, &amp;val, &amp;col, 1, 1, NULL, &amp;db_res) &lt; 0) {<br />       LM_ERR(&quot;failed to query database\n&quot;);<br />       return -1;<br />}<br /><br />if (RES_ROW_N(db_res) &lt;= 0) {<br />      LM_DBG(&quot;no rows found\n&quot;);<br />      sql_functions.free_result(db_handle, db_res);<br />      return -1;<br />}<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398186541-1398185789-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398186541:1398185789:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 06:56 PM 
        by <span class='diffauthor' title='213.233.85.84'>213.233.85.84</span> - </div>
        <div class='difftype'>Added lines 1765-1815:</div>
        <div class='diffadd'><div class='diffmarkup'>Many macros are in place in order to help writing faster and easier to read code :<br /><br />(:source lang=C -link -getcode :)<br />/* Macros below work on result sets ( db_res_t )<br />/** Return the column names */<br />#define RES_NAMES(re) ((re)-&gt;col.names)<br />/** Return the column types */<br />#define RES_TYPES(re) ((re)-&gt;col.types)<br />/** Return the number of columns */<br />#define RES_COL_N(re) ((re)-&gt;col.n)<br />/** Return the result rows */<br />#define RES_ROWS(re)  ((re)-&gt;rows)<br />/** Return the number of current result rows */<br />#define RES_ROW_N(re) ((re)-&gt;n)<br />/** Return the last row of the result */<br />#define RES_LAST_ROW(re)  ((re)-&gt;last_row)<br />/** Return the number of total result rows */<br />#define RES_NUM_ROWS(re) ((re)-&gt;res_rows)<br /><br />/* Macros below work on rows */<br />/** Return the columns in the row */<br />#define ROW_VALUES(rw) ((rw)-&gt;values)<br />/** Return the number of colums */<br />#define ROW_N(rw)      ((rw)-&gt;n)<br /><br />/* Macros below work on values */<br />/**<br /> * Use this macro if you need to set/get the type of the value.<br /> */<br />#define VAL_TYPE(dv)   ((dv)-&gt;type)<br />/**<br /> * Use this macro if you need to set/get the null flag. A non-zero flag means that<br /> * the corresponding cell in the database contains no data (a NULL value in MySQL<br /> * terminology).<br /> */<br />#define VAL_NULL(dv)   ((dv)-&gt;nul)<br />/**<br /> * Use this macro if you need to access the integer value in the db_val_t structure.<br /> */<br />#define VAL_INT(dv)    ((dv)-&gt;val.int_val)<br />/**<br /> * Use this macro if you need to access the str structure in the db_val_t structure.<br /> */<br />#define VAL_STR(dv)    ((dv)-&gt;val.str_val)<br />(:sourceend:)<br />\\<br />Find below an example of a full select query from start to finish :<br /><br />(:source lang=C -link -getcode :)<br /># TODO<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398185789-1398185312-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398185789:1398185312:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 06:48 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1659-1764:</div>
        <div class='diffadd'><div class='diffmarkup'><br />For running a '''SELECT''' query, you should use the '''query''' function. Prototype is :<br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Query table for specified rows.<br /> *<br /> * This function implements the SELECT SQL directive.<br /> * If _k and _v parameters are NULL and _n is zero, you will get the whole table.<br /> *<br /> * if _c is NULL and _nc is zero, you will get all table columns in the result.<br /> * _r will point to a dynamically allocated structure, it is neccessary to call<br /> * db_free_result function once you are finished with the result.<br /> *<br /> * If _op is 0, equal (=) will be used for all key-value pairs comparisons.<br /> *<br /> * Strings in the result are not duplicated, they will be discarded if you call<br /> * db_free_result, make a copy yourself if you need to keep it after db_free_result.<br /> *<br /> * You must call db_free_result before you can call db_query again!<br /> * \see db_free_result<br /> *<br /> * \param _h database connection handle<br /> * \param _k array of column names that will be compared and their values must match<br /> * \param _op array of operators to be used with key-value pairs<br /> * \param _v array of values, columns specified in _k parameter must match these values<br /> * \param _c array of column names that you are interested in<br /> * \param _n number of key-value pairs to match in _k and _v parameters<br /> * \param _nc number of columns in _c parameter<br /> * \param _o order by statement for query<br /> * \param _r address of variable where pointer to the result will be stored<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */<br />typedef int (*db_query_f) (const db_con_t* _h, const db_key_t* _k, const db_op_t* _op,<br />                                const db_val_t* _v, const db_key_t* _c, const int _n, const int _nc,<br />                                const db_key_t _o, db_res_t** _r);<br />(:sourceend:)<br />\\<br />Upon a successful select query call, the developer will have to manipulate the output db_res_t in order to use the results of his select query. Below are the used structures for interpreting a query result set.<br /> <br />(:source lang=C -link -getcode :)<br />/**<br /> * This type represents a result returned by db_query function (see below). The<br /> * result can consist of zero or more rows (see db_row_t description).<br /> *<br /> * Note: A variable of type db_res_t returned by db_query function uses dynamicaly<br /> * allocated memory, don't forget to call db_free_result if you don't need the<br /> * variable anymore. You will encounter memory leaks if you fail to do this!<br /> *<br /> * In addition to zero or more rows, each db_res_t object contains also an array<br /> * of db_key_t objects. The objects represent keys (names of columns). *<br /> */<br />typedef struct db_res {<br />        struct {<br />                db_key_t* names;   /**&lt; Column names                    */<br />                db_type_t* types;  /**&lt; Column types                    */<br />                int n;             /**&lt; Number of columns               */<br />        } col;<br />        struct db_row* rows;   /**&lt; Rows                            */<br />        int n;                 /**&lt; Number of rows in current fetch */<br />        int res_rows;          /**&lt; Number of total rows in query   */<br />        int last_row;          /**&lt; Last row                        */<br />} db_res_t;<br /><br />/**<br /> * Structure holding the result of a query table function.<br /> * It represents one row in a database table. In other words, the row is an<br /> * array of db_val_t variables, where each db_val_t variable represents exactly<br /> * one cell in the table.<br /> */<br />typedef struct db_row {<br />        db_val_t* values;  /**&lt; Columns in the row */<br />        int n;             /**&lt; Number of columns in the row */<br />} db_row_t;<br /><br />/**<br /> * This structure represents a value in the database. Several datatypes are<br /> * recognized and converted by the database API. These datatypes are automaticaly<br /> * recognized, converted from internal database representation and stored in the<br /> * variable of corresponding type.<br /> *<br /> * Module that want to use this values needs to copy them to another memory<br /> * location, because after the call to free_result there are not more available.<br /> *<br /> * If the structure holds a pointer to a string value that needs to be freed<br /> * because the module allocated new memory for it then the free flag must<br /> * be set to a non-zero value. A free flag of zero means that the string<br /> * data must be freed internally by the database driver.<br /> */<br />typedef struct {<br />        db_type_t type; /**&lt; Type of the value                              */<br />        int nul;                /**&lt; Means that the column in database has no value */<br />        int free;               /**&lt; Means that the value should be freed */<br />        /** Column value structure that holds the actual data in a union.  */<br />        union {<br />                int           int_val;    /**&lt; integer value              */<br />                long long     bigint_val; /**&lt; big integer value          */<br />                double        double_val; /**&lt; double value               */<br />                time_t        time_val;   /**&lt; unix time_t value          */<br />                const char*   string_val; /**&lt; zero terminated string     */<br />                str           str_val;    /**&lt; str type string value      */<br />                str           blob_val;   /**&lt; binary object data         */<br />                unsigned int  bitmap_val; /**&lt; Bitmap data type           */<br />        } val;<br />} db_val_t;<br />(:sourceend:)<br />\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398185312-1398184200-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398185312:1398184200:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 06:30 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 1638-1658 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />Before running a query through the API, we need to choose the table that the query will run on :<br /><br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Specify table name that will be used for subsequent operations.<br /> *<br /> * The function db_use_table takes a table name and stores it db_con_t structure.<br /> * All subsequent operations (insert, delete, update, query) are performed on<br /> * that table.<br /> * \param _h database connection handle<br /> * \param _t table name<br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */<br />typedef int (*db_use_table_f)(db_con_t* _h, const str * _t);<br />(:sourceend:)<br />\\<br /><br />&gt;&gt;important&lt;&lt;<br />All queries must be preceded by a call to the '''use_table''' function. OpenSIPS internally does connection pooling - in case multiple module request connections to the same database, the connection will be shared between all those modules. Thus, in the context of a process, the same connection might be used by different modules - never assume a connection is dedicated to a single module.<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398184200:1398183805:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398184200:1398183805:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398184200:1398183805:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 06:23 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1608-1637:</div>
        <div class='diffadd'><div class='diffmarkup'><br />The output of the init() function will be the handler to be further used for all database interactions. When the connection is not needed anymore, the '''close''' method should be called :<br /><br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Close a database connection and free all memory used.<br /> *<br /> * The function closes previously open connection and frees all previously<br /> * allocated memory. The function db_close must be the very last function called.<br /> * \param _h db_con_t structure representing the database connection<br /> */<br />typedef void (*db_close_f) (db_con_t* _h);<br />(:sourceend:)<br />\\<br />Before running any queries on the back-end, common practice dictates that the used tables should be versioned, in order to ensure that the user is not running your code on top of an older database structure.<br />\\<br />db/db.h exposes db_check_table_version for this purpose, that checks the '''version''' table in the default OpenSIPS database structure :<br /><br />(:source lang=C -link -getcode :)<br />/*              <br />Parameters :<br />      dbf - the functions to be used for running the version query<br />      dbh - the connection to run the version query<br />      table - str containing the table name we want to check for version<br />      version - the version we expect to find<br />Returns :<br />      0 means table version was successfully validated, negative in case of error ( internal error or older version found )<br /> */<br />int db_check_table_version(db_func_t* dbf, db_con_t* dbh, const str* table, const unsigned int version);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398183805-1398183182-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398183805:1398183182:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 06:13 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1568-1608:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />Now that we have binded to the needed module and also made sure it supports our needed capabilities, we can go ahead and connect to the back-end, by invoking the init function from the binded functions :<br />(:source lang=C -link -getcode :)<br />/**<br /> * \brief Initialize database connection and obtain the connection handle.<br /> *<br /> * This function initialize the database API and open a new database<br /> * connection. This function must be called after db_bind_mod but before any<br /> * other database API function is called.<br /> *<br /> * The function takes one parameter, the parameter must contain the database<br /> * connection URL. The URL is of the form<br /> * mysql://username:password\@host:port/database where:<br /> *<br /> * username: Username to use when logging into database (optional).<br /> * password: password if it was set (optional)<br /> * host:     Hosname or IP address of the host where database server lives (mandatory)<br /> * port:     Port number of the server if the port differs from default value (optional)<br /> * database: If the database server supports multiple databases, you must specify the<br /> * name of the database (optional).<br /> * \see bind_dbmod<br /> * \param _sqlurl database connection URL<br /> * \return returns a pointer to the db_con_t representing the connection if it was<br /> * successful, otherwise 0 is returned<br /> */<br />typedef db_con_t* (*db_init_f) (const str* _sqlurl);<br /><br />/* Example of usage below */<br />static db_con_t* db_connection;<br /><br />if ((db_connection = sql_functions.init(db_url)) == NULL) {<br />      LM_ERR(&quot;Failed to connect to the database \n&quot;);<br />      return -1;<br />}<br />(:sourceend:)<br />\\<br /><br />&gt;&gt;important&lt;&lt;<br />Connection sharing between multiple processes does not work for the majority of back-end specific connectors ( eg. MySQL, Postgres, etc ). Due to this fact, the developers MUST make sure to create a sepparate database connection for each process that will eventually need one - in the context of Module development, the connections need to be opened in the child_init function.<br />&gt;&gt;&lt;&lt;<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398183182-1398178889-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398183182:1398178889:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 05:01 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 1476-1477 from:</div>
        <div class='diffdel'><div class='diffmarkup'>db/db.h exposes most of the database related functions. At startup, the developer will have just the database URL where he needs to connect. By calling, '''db_bind_mod''' , the OpenSIPS DB API will try to automatically locate the actual DB module that support that specific back-end, and will return all the needed functions for operating on the back-end.<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>'''db/db.h''' exposes most of the database related functions. At startup, the developer will have just the database URL where he needs to connect. By calling '''db_bind_mod''' , the OpenSIPS DB API will try to automatically locate the actual DB module that support that specific back-end, and will return all the needed functions for operating on the back-end.<br /></div></div>
        <div class='difftype'>Added lines 1517-1526:</div>
        <div class='diffadd'><div class='diffmarkup'>/* Example of usage below */<br />db_func_t sql_functions;<br />db_url = str_init(&quot;mysql://root:vlad@localhost/opensips&quot;);<br /><br />if (db_bind_mod(db_url, &amp;sql_functions) &lt; 0){<br />      /* most likely the db_mysql modules was not loaded, or it was loaded after our module */<br />      LM_ERR(&quot;Unable to bind to a database driver\n&quot;);<br />      return -1;<br />}<br /></div></div>
        <div class='difftype'>Added lines 1528-1568:</div>
        <div class='diffadd'><div class='diffmarkup'><br />After successfully binding to the module, the developer must also make sure that the URL provided from the script writer point of a back-end which also supports the capabilities that will be further used ( eg. when operating on a flat text file, the db_last_inserted_id_f function will not be populated, and thus if the C code calls that function, the module will crash ). This is done by using the '''DB_CAPABILITY''' macro :<br /><br />(:source lang=C -link -getcode :)<br />/**<br /> * Returns true if all the capabilities in cpv are supported by module<br /> * represented by dbf, false otherwise<br /> */<br />#define DB_CAPABILITY(dbf, cpv) (((dbf).cap &amp; (cpv)) == (cpv))<br /><br />/**<br /> * Represents the capabilities that a database driver supports.<br /> */<br />typedef enum db_cap {<br />        DB_CAP_QUERY =     1 &lt;&lt; 0,  /**&lt; driver can perform queries                                     */<br />        DB_CAP_RAW_QUERY = 1 &lt;&lt; 1,  /**&lt; driver can perform raw queries                                 */<br />        DB_CAP_INSERT =    1 &lt;&lt; 2,  /**&lt; driver can insert data                                         */<br />        DB_CAP_DELETE =    1 &lt;&lt; 3,  /**&lt; driver can delete data                                         */<br />        DB_CAP_UPDATE =    1 &lt;&lt; 4,  /**&lt; driver can update data                                         */<br />        DB_CAP_REPLACE =   1 &lt;&lt; 5,  /**&lt; driver can replace (also known as INSERT OR UPDATE) data       */<br />        DB_CAP_FETCH   =   1 &lt;&lt; 6,  /**&lt; driver supports fetch result queries                           */<br />        DB_CAP_LAST_INSERTED_ID = 1 &lt;&lt; 7,  /**&lt; driver can return the ID of the last insert operation   */<br />        DB_CAP_INSERT_UPDATE = 1 &lt;&lt; 8, /**&lt; driver can insert data into database and update on duplicate */<br />        DB_CAP_MULTIPLE_INSERT = 1 &lt;&lt; 9 /**&lt; driver can insert multiple rows at once */<br />} db_cap_t;<br /><br /><br />/**<br /> * All database capabilities except raw_query, replace, insert_update and<br /> * last_inserted_id which should be checked separately when needed<br /> */<br />#define DB_CAP_ALL (DB_CAP_QUERY | DB_CAP_INSERT | DB_CAP_DELETE | DB_CAP_UPDATE)<br /><br />/* Example of usage below */<br />if (!DB_CAPABILITY(sql_functions, DB_CAP_ALL)) {<br />      LM_CRIT(&quot;Database modules does not &quot;<br />            &quot;provide all functions needed by our module\n&quot;);<br />      return -1;<br />}<br />(:sourceend:)<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398178889-1398178249-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398178889:1398178249:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 04:50 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1472-1517:</div>
        <div class='diffadd'><div class='diffmarkup'>OpenSIPS exposes a SQL database API that the module developers can use for operating the most common SQL queries. Advantages here are :<br />* writing back-end independent code, since the DB API is decoupled from the actual modules implementing the back-end specific code<br />* the ability to expose SQL-like capabilities to back-ends who are not internally SQL ( eg. the db_flatstore modules operates directly with flat-text files, yet the developer can insert into the file as if he was inserting into a regular SQL database<br />\\<br />db/db.h exposes most of the database related functions. At startup, the developer will have just the database URL where he needs to connect. By calling, '''db_bind_mod''' , the OpenSIPS DB API will try to automatically locate the actual DB module that support that specific back-end, and will return all the needed functions for operating on the back-end.<br /><br />(:source lang=C -link -getcode :)<br />/**                                        <br /> * \brief Bind database module functions                            <br /> *                                                                      <br /> * This function is special, it's only purpose is to call find_export function in<br /> * the core and find the addresses of all other database related functions. The<br /> * db_func_t callback given as parameter is updated with the found addresses.<br /> *                                                             <br /> * This function must be called before any other database API call!<br /> *                                                               <br /> * The database URL is of the form &quot;mysql://username:password@host:port/database&quot; or<br /> * &quot;mysql&quot; (database module name).<br /> * In the case of a database connection URL, this function looks only at the first<br /> * token (the database protocol). In the example above that would be &quot;mysql&quot;:<br /> * \see db_func_t                                                            <br /> * \param mod database connection URL or a database module name<br /> * \param dbf database module callbacks to be further used                  <br /> * \return returns 0 if everything is OK, otherwise returns value &lt; 0<br /> */                                       <br />int db_bind_mod(const str* mod, db_func_t* dbf);<br /><br />typedef struct db_func {<br />      unsigned int           cap;           /* Capability vector of the database transport */<br />      db_use_table_f         use_table;     /* Specify table name */<br />      db_init_f              init;          /* Initialize database connection */<br />      db_close_f             close;         /* Close database connection */<br />      db_query_f             query;         /* query a table */<br />      db_fetch_result_f      fetch_result;  /* fetch result */<br />      db_raw_query_f         raw_query;     /* Raw query - SQL */<br />      db_free_result_f       free_result;   /* Free a query result */<br />      db_insert_f            insert;        /* Insert into table */<br />      db_delete_f            delete;        /* Delete from table */<br />      db_update_f            update;        /* Update table */<br />      db_replace_f           replace;       /* Replace row in a table */<br />      db_last_inserted_id_f  last_inserted_id;  /* Retrieve the last inserted ID<br />                                                    in a table */<br />      db_insert_update_f insert_update;     /* Insert into table, update on duplicate key */<br />} db_func_t;<br /><br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398178249-1398177052-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398178249:1398177052:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 04:30 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 1377 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For building the output MI tree, mi/tree.h and mi/attr.h expose the following functions :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For building the output MI tree, '''mi/tree.h''' and '''mi/attr.h''' expose the following functions :</div></div>
        <div class='difftype'>Added line 1423:</div>
        <div class='diffadd'><div class='diffmarkup'>*/</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398177052-1398176986-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398177052:1398176986:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 04:29 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1376-1425:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />For building the output MI tree, mi/tree.h and mi/attr.h expose the following functions :<br />(:source lang=C -link -getcode :)<br />/* Use for creating a new output reply tree<br />Parameters :<br />      code : success code for this tree ( &gt;=200&lt;300 for success, anything else for errors )<br />      reason : string reasons representation for the code<br />      reason_len : length of the reason parameter<br />Returns :<br />      A new mi_root tree, or NULL in case of error. Note that this function will allocate the node in PKG and it typically has to be returned - the freeing will be done in the MI core, after the output tree is written by the transport module */<br />struct mi_root *init_mi_tree(unsigned int code, char *reason, int reason_len);<br /><br />/* Adding a new child node to our tree - typically first called to mi_root-&gt;node.kids<br />Parameters :<br />      parent : the parent node for our newly added node<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this node needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current node needs to be duplicated in PKG<br />      name : the name of the current node<br />      name_len : length of the node's name<br />      value : the value of the current node<br />      value_len : length of the node's value<br />*/<br />struct mi_node *add_mi_node_child(struct mi_node *parent, int flags,<br />        char *name, int name_len, char *value, int value_len);<br />/* Adding a new sibling node to one of our nodes<br />Parameters :<br />      brother : the brother node for our newly added node<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this node needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current node needs to be duplicated in PKG<br />      name : the name of the current node<br />      name_len : length of the node's name<br />      value : the value of the current node<br />      value_len : length of the node's value<br />*/<br />struct mi_node *add_mi_node_sibling(struct mi_node *brother, int flags,<br />        char *name, int name_len, char *value, int value_len);<br />/* Adding a new attribute to one of our nodes<br />      node : the node we will be adding the key-value attribute to<br />      flags : Current options are :<br />                   MI_DUP_NAME : the name of this attribute needs to be duplicated in PKG <br />                   MI_DUP_VALUE : the value of the current attribute needs to be duplicated in PKG<br />      name : the name of the current attribute<br />      name_len : length of the node's attribute name<br />      value : the value of the current value<br />      value_len : length of the node's attribute value<br />struct mi_attr *add_mi_attr(struct mi_node *node, int flags,                                      <br />        char *name, int name_len, char *value, int value_len)<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398176986-1398176112-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398176986:1398176112:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 04:15 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1378-1417:</div>
        <div class='diffadd'><div class='diffmarkup'><br />(:source lang=C -link -getcode :)<br />struct mi_root *mi_debug(struct mi_root *cmd, void *param)<br />{<br />      struct mi_root *rpl_tree;<br />      struct mi_node *node;<br />      char *p;<br />      int len;<br />      int new_debug;<br /><br />      /* check the kids member of our root node - <br />      if the input root node has kids, our command was called with parameters */<br />      node = cmd-&gt;node.kids;<br />      if (node!=NULL) {<br />            /* take the node's value and convert it to int, to make sure the parameter is valid */<br />            if (str2sint( &amp;node-&gt;value, &amp;new_debug) &lt; 0)<br />                  /* if failed to convert to int, still return a RPL tree with an &gt;=400 code and reason */<br />                  return init_mi_tree( 400, MI_SSTR(MI_BAD_PARM));<br />      } else<br />            new_debug = *debug;<br /><br />      /* all is good so far, initialize a new output ROOT tree which has a 200 OK code &amp; reason */<br />      rpl_tree = init_mi_tree( 200, MI_SSTR(MI_OK));<br />      if (rpl_tree==0)<br />              return 0;<br /><br />      p = sint2str((long)new_debug, &amp;len);<br />      /* add a new node to our output tree, which the current debug level */<br />      node = add_mi_node_child( &amp;rpl_tree-&gt;node, MI_DUP_VALUE,<br />             MI_SSTR(&quot;DEBUG&quot;),p, len);<br />      if (node==0) {<br />              free_mi_tree(rpl_tree);<br />              return 0;<br />      }<br /><br />      /* if all was successful, overwrite the actual debug level, and return our tree */<br />      *debug = new_debug;<br />      return rpl_tree;<br />}<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398176112-1398175589-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398176112:1398175589:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 04:06 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 1329-1332 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      if (register_mi_mod( &quot;core&quot;, mi_core_cmds)&lt;0) {<br />            LM_ERR(&quot;unable to register core MI cmds\n&quot;);<br />            return -1;  <br />      }  </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>if (register_mi_mod( &quot;core&quot;, mi_core_cmds)&lt;0) {<br />      LM_ERR(&quot;unable to register core MI cmds\n&quot;);<br />      return -1;  <br />}</div></div>
        <div class='difftype'>Added lines 1334-1377:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />The structures commonly used for implementing MI functions are also found in '''mi/mi.h''' :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      input : the tree that contains the command paramenters<br />      param : the parameter provided at function registration<br />Returns :<br />      A mi_root tree containing the function reply<br />*/<br />typedef struct mi_root* (mi_cmd_f)(struct mi_root *input, void *param);<br /><br />/* below are the used structures for representing the tree root and the tree nodes */<br />struct mi_root {<br />      /* int code - similar to SIP or HTTP code */<br />      unsigned int       code;<br />      /* string reason for code - similar to SIP or HTTP reason */<br />      str                reason;<br />      /* handler in case of asynchronous MI commands */ <br />      struct mi_handler  *async_hdl;<br />      /* the actual root node in our tree */<br />      struct mi_node     node; <br />};<br /><br />struct mi_node {<br />      str value;<br />      str name;<br />      unsigned int flags;<br />      struct mi_node *kids;<br />      struct mi_node *next;<br />      struct mi_node *last; <br />      struct mi_attr *attributes;<br />};      <br />                <br />struct mi_attr{<br />        str name;<br />        str value;<br />        struct mi_attr *next;<br />};<br />(:sourceend:)<br />\\<br />As can be noted from the above tree definition, a node has a name and a value associated to it,it can have one or multiple children ( stored in kids pointer ), and also it can have a list of key-value attributes associated to it.<br />\\<br />Further on, we will follow the implementation of the '''debug''' MI function. If called with no parameters, the function will return the current debug level in OpenSIPS. If called with one integer parameter, then the function will set the current debug level to the provided parameter.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398175589-1398174993-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398175589:1398174993:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 03:56 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1319-1332:</div>
        <div class='diffadd'><div class='diffmarkup'>/* For exporting the populated array of MI functions<br />Parameters :<br />      mod_name : the name of the module exporting these functions<br />      mis : the array of exported MI functions<br />Returns :<br />      0 on success, negative in case of error<br />*/<br />int register_mi_mod( char *mod_name, mi_export_t *mis);<br /><br />/* Example of usage */<br />      if (register_mi_mod( &quot;core&quot;, mi_core_cmds)&lt;0) {<br />            LM_ERR(&quot;unable to register core MI cmds\n&quot;);<br />            return -1;  <br />      }  </div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398174993-1398174711-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398174993:1398174711:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 03:51 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 1285-1319 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />The structures commonly used for exporting MI functions are found in '''mi/mi.h''' :<br /><br />(:source lang=C -link -getcode :)<br />typedef struct mi_export_ {<br />        /* the name of the function ( users will call this from their transport of choice */<br />        char *name;<br />        /* short description of the usage of this function */<br />        char *help;<br />        /* actual function that will get called */<br />        mi_cmd_f *cmd;<br />        /* flags for this function. Currently options are :<br />             - MI_ASYNC_RPL_FLAG - the function has an asynchronous behaviour ( eg: MI functions that send SIP messages and wait for their reply )<br />             - MI_NO_INPUT_FLAG - the function does not receive any parameters <br />        */<br />        unsigned int flags;<br />        /* parameter that will be passed when the cmd function gets called */<br />        void *param;<br />        /* the initialization function to be called by OpenSIPS ( one time ) */<br />        mi_child_init_f *init_f;<br />}mi_export_t;<br /><br />/* Example of core MI exported function */<br />static mi_export_t mi_core_cmds[] = {<br />        { &quot;uptime&quot;, &quot;prints various time information about OpenSIPS - &quot;<br />                &quot;when it started to run, for how long it runs&quot;,<br />                mi_uptime,     MI_NO_INPUT_FLAG,  0,  init_mi_uptime },<br />        { &quot;version&quot;, &quot;prints the version string of a runningOpenSIPS&quot;,<br />                mi_version,    MI_NO_INPUT_FLAG,  0,  0 },<br />        { &quot;pwd&quot;, &quot;prints the working directory of OpenSIPS&quot;,<br />                mi_pwd,        MI_NO_INPUT_FLAG,  0,  0 },<br />...<br />...<br />...<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398174711-1398174142-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398174711:1398174142:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 03:42 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1277-1285:</div>
        <div class='diffadd'><div class='diffmarkup'><br />The Management Interface is the abstract layer that is commonly used to control and monitor OpenSIPS. The MI Interface supports multiple actual back-ends ( eg. FIFO, Datagram, XMLRPC, HTTP GET JSON, etc ) - due to the modularity of the interface and also due to the clear separation between the  logic and the transport layer, the developer just defines the functions to be externally called, and then it is up to the OpenSIPS script writer to chose what transport he will actually use for controlling OpenSIPS.<br />\\<br />The MI interface heavily uses trees :<br />* the Interface will provide as input a tree with the parameters provided by the user<br />* an MI function has to also return a tree, which will then be converted by the transport module to it's specific representation<br />\\<br />Further on we will focus on the core MI functions, with a specific focus on the '''debug''' function. Note that modules can ( an commonly ) also export MI functions - see the Modules Development MI functions topic for more information on that.<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1398174142-1398169475-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398174142:1398169475:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 22, 2014, at 02:24 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 1255 from:</div>
        <div class='diffdel'><div class='diffmarkup'>void update_stat(stat_var* var, int n)updated</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>void update_stat(stat_var* var, int n);</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398169475:1397931057:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398169475:1397931057:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1398169475:1397931057:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 08:10 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 16:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 18:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 24:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 26:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397931057-1397930360-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397931057:1397930360:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 07:59 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 1278:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Module Development</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397930360-1397929924-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397930360:1397929924:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 07:52 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 1267-1270:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;important&lt;&lt;<br />All statistics related code should be guarded by '''#ifdef STATISTICS''' , since the statistics are not a mandatory part of the OpenSIPS core ( they can be disabled from within menuconfig ).<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397929924-1397929817-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397929924:1397929817:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 07:50 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 1173 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The most important structures used for extending statistics are the following :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The most important structures used for extending statistics are exported by '''statistics.h''' :</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397929817-1397925606-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397929817:1397925606:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 06:40 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 1218 from:</div>
        <div class='diffdel'><div class='diffmarkup'>As note from the above structure, a statistics can either be a simple counter ( eg. rcv_requests ), but it can also be a function. Statistics function might come in handy when the developer needs to do extra processing on the raw counters before providing the final output.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>As note from the above structure, statistics can either be a simple counter ( eg. rcv_requests ), but it can also be a function. Statistics function might come in handy when the developer needs to do extra processing on the raw counters before providing the final output.</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397925606:1397924096:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397925606:1397924096:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397925606:1397924096:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 06:14 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397924096-1397924001-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397924096:1397924001:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 06:13 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 1118 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Important to note here that all the above timer related functions MUST be called for the context of the attendant process before forking is done ( so either from the modules mod_init or directly from the core, before forking ).</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Important to note here that all the above timer related functions MUST be called in the context of the attendant process before forking is done ( so either from the modules mod_init or directly from the core, before forking ).</div></div>
        <div class='difftype'>Changed line 1239 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Important to note here that all the above statistics related functions MUST be called for the context of the attendant process before forking is done.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Important to note here that all the above statistics related functions MUST be called in the context of the attendant process before forking is done.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397924001-1397923948-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397924001:1397923948:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 06:12 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Deleted line 1234:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>Deleted lines 1235-1236:</div>
        <div class='diffdel'><div class='diffmarkup'><br /></div></div>
        <div class='difftype'>Added lines 1237-1267:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;important&lt;&lt;<br />Important to note here that all the above statistics related functions MUST be called for the context of the attendant process before forking is done.<br />&gt;&gt;&lt;&lt;<br /><br />\\<br />At runtime, the developer has access to the following functions for operating on statistics :<br /><br />(:source lang=C -link -getcode :)<br />/* <br />Parameters :<br />      var : the statistics to be updated<br />      n : the value ( if positive -&gt; stat will be increment. negative -&gt; stat will be decremented )<br />*/<br />void update_stat(stat_var* var, int n)updated<br /><br />/* <br />Parameters :<br />      var : the statistics to be reseted<br />*/<br />void reset_stat(stat_var* var);<br /><br />/*<br />Parameters :<br />      var : the statistics to be fetched<br />Returns :<br />      statistic value<br />*/<br />unsigned long get_stat_val(stat_var* var)<br />(:sourceend:)<br /></div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397923948:1397923503:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397923948:1397923503:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397923948:1397923503:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 06:05 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 1216-1221:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;tip&lt;&lt;<br />As note from the above structure, a statistics can either be a simple counter ( eg. rcv_requests ), but it can also be a function. Statistics function might come in handy when the developer needs to do extra processing on the raw counters before providing the final output.<br />&gt;&gt;&lt;&lt;<br /><br />\\</div></div>
        <div class='difftype'>Changed lines 1236-1238 from:</div>
        <div class='diffdel'><div class='diffmarkup'>&gt;&gt;tip&lt;&lt;<br />register_module_stats will export the statistics, and also allocate them in SHM memory, for them to be accessible by all OpenSIPS processes.<br />&gt;&gt;&lt;&lt;</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Note that '''register_module_stats''' will export the statistics, and also allocate them in SHM memory, for them to be accessible by all OpenSIPS processes.<br /></div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397923503:1397923347:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397923503:1397923347:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397923503:1397923347:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 06:02 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 1183-1234 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />For example, the core stats exported by OpenSIPS are defined in the following array :<br /><br />(:source lang=C -link -getcode :)<br />stat_var* rcv_reqs;<br />stat_var* rcv_rpls;<br />stat_var* fwd_reqs;<br />stat_var* fwd_rpls;<br />stat_var* drp_reqs;<br />stat_var* drp_rpls;<br />stat_var* err_reqs;<br />stat_var* err_rpls;<br />stat_var* bad_URIs;<br />stat_var* unsupported_methods;<br />stat_var* bad_msg_hdr;<br /><br />stat_export_t core_stats[] = {<br />        {&quot;rcv_requests&quot; ,         0,  &amp;rcv_reqs              },<br />        {&quot;rcv_replies&quot; ,          0,  &amp;rcv_rpls              },<br />        {&quot;fwd_requests&quot; ,         0,  &amp;fwd_reqs              },<br />        {&quot;fwd_replies&quot; ,          0,  &amp;fwd_rpls              },<br />        {&quot;drop_requests&quot; ,        0,  &amp;drp_reqs              },<br />        {&quot;drop_replies&quot; ,         0,  &amp;drp_rpls              },<br />        {&quot;err_requests&quot; ,         0,  &amp;err_reqs              },<br />        {&quot;err_replies&quot; ,          0,  &amp;err_rpls              },<br />        {&quot;bad_URIs_rcvd&quot;,         0,  &amp;bad_URIs              },<br />        {&quot;unsupported_methods&quot;,   0,  &amp;unsupported_methods   },<br />        {&quot;bad_msg_hdr&quot;,           0,  &amp;bad_msg_hdr           },<br />        {&quot;timestamp&quot;,  STAT_IS_FUNC, (stat_var**)get_ticks   },<br />        {0,0,0}<br />};<br />(:sourceend:)<br />\\<br />After defining your array of statistics that you want to export, one should use the following for exporting the stats to be accessible by all<br /><br />(:source lang=C -link -getcode :)<br />/* <br />Parameters :<br />      module - a string describing the module the current statistics belong to. Will be used when fetching the statistics via MI<br />      stats - the statistics to be registered<br />Returns :<br />      0 in case of success, negative in case of error<br />*/<br />int register_module_stats(char *module, stat_export_t *stats;<br />(:sourceend:)<br />\\<br /><br />&gt;&gt;tip&lt;&lt;<br />register_module_stats will export the statistics, and also allocate them in SHM memory, for them to be accessible by all OpenSIPS processes.<br />&gt;&gt;&lt;&lt;<br /><br />\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397923347-1397922776-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397923347:1397922776:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 05:52 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 1173-1182 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The most important structures used for extending statistics are the following :<br /><br />(:source lang=C -link -getcode :)<br />typedef struct stat_export_ {<br />        char* name;                /* null terminated statistic name */<br />        unsigned short flags;      /* flags */<br />        stat_var** stat_pointer;   /* pointer to the variable's mem location *<br />                                    * NOTE - it's in shm mem */<br />} stat_export_t;<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397922776:1397922593:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397922776:1397922593:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397922776:1397922593:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 05:49 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 1166-1173:</div>
        <div class='diffadd'><div class='diffmarkup'><br />OpenSIPS exposes a statistics API that can be used both from the core or the modules. The statistics are essentially counters that will be internally incremented/decremented by OpenSIPS and that can be fetched by the outside world ( via the MI interface ) for understanding the OpenSIPS load / health status / etc.<br />\\<br />The advantages of using the OpenSIPS Statistics API instead of regular counters is :<br />* easily fetched from the MI Interface<br />* on supported architectures, the statistics do not use an explicit lock ( the consistency is ensured by employing assembly code ), thus you will get better performance<br />\\<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397922593-1397921735-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397922593:1397921735:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 05:35 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 647 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      param - the parameter provided for evaluated the pvar</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      param - the parameter provided for evaluating the pvar</div></div>
        <div class='difftype'>Added line 673:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 677:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added lines 680-688:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters :<br />      msg - the SIP message to apply the changes to<br />      param - the parameter provided for evaluating the pvar<br />      op - further indication on the type of write access to be done<br />      val - value to be pushed to our pvar<br />Returns :<br />      0 in case of success, negative in case of error<br />*/</div></div>
        <div class='difftype'>Added line 697:</div>
        <div class='diffadd'><div class='diffmarkup'>      /* type checking, we can only push strings to R-URI */</div></div>
        <div class='difftype'>Added line 703:</div>
        <div class='diffadd'><div class='diffmarkup'>      /* populate the message R-URI with the string value from the provided val */</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397921735-1397921517-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397921735:1397921517:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 05:31 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 641-642 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br /></div></div>
        <div class='difftype'>Added lines 644-651:</div>
        <div class='diffadd'><div class='diffmarkup'>/* <br />Parameters :<br />      msg - the message context to evaluate the current pvar <br />      param - the parameter provided for evaluated the pvar<br />      res - the output value of our pvar <br />Returns :<br />      0 in case of success, negative in case of error<br />*/      </div></div>
        <div class='difftype'>Changed line 672 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 674 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For all read access on the PVARs from contexts where the PVAR does not have any meaningful value ( eg Request-URI from a Reply Context ), make sure to use '''pv_get_null''' to signal this to the script writer.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For all read access on the PVARs from contexts where the PVAR does not have any meaningful value (eg. Request-URI from a Reply Context), make sure to use '''pv_get_null''' to signal this to the script writer.</div></div>
        <div class='difftype'>Added lines 676-700:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />(:source lang=C -link -getcode :)<br />int pv_set_ruri(struct sip_msg* msg, pv_param_t *param,<br />                int op, pv_value_t *val)<br />{<br />      if(msg==NULL || param==NULL || val==NULL) {<br />            LM_ERR(&quot;bad parameters\n&quot;);<br />            return -1;<br />      }<br /><br />      if(!(val-&gt;flags&amp;PV_VAL_STR)) {<br />            LM_ERR(&quot;str value required to set R-URI\n&quot;);<br />            goto error;<br />      }<br /><br />      if (set_ruri( msg, &amp;val-&gt;rs)!=0) {<br />            LM_ERR(&quot;failed to set RURI\n&quot;);<br />            goto error;<br />      }<br /><br />      return 0;<br />error:<br />      return -1;<br />}<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397921517-1397920722-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397921517:1397920722:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 05:18 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 640-666 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Since out $ru pvar does not support indexing by concept ( the SIP message has one and only one Request-URI ), there is no need to add a parsing or an indexing function for our pseudovariable. Also, no special initialization is needed for our psedovariable case, since we will operate directly on the currently processed SIP message in the script.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Since the $ru pvar does not support indexing by concept ( the SIP message has one and only one Request-URI ), there is no need to add a parsing or an indexing function for our pseudovariable. Also, no special initialization is needed for our psedovariable case, since we will operate directly on the currently processed SIP message in the script.<br /><br />(:source lang=C -link -getcode :)<br />static int pv_get_ruri(struct sip_msg *msg, pv_param_t *param,<br />            pv_value_t *res)<br />{<br />      if(msg==NULL || res==NULL)<br />            return -1;<br /><br />      if(msg-&gt;first_line.type == SIP_REPLY)   /* REPLY doesnt have a ruri */<br />            return pv_get_null(msg, param, res);<br /><br />      if(msg-&gt;parsed_uri_ok==0 /* R-URI not parsed*/ &amp;&amp; parse_sip_msg_uri(msg)&lt;0) {<br />            LM_ERR(&quot;failed to parse the R-URI\n&quot;);<br />            return pv_get_null(msg, param, res);<br />      }<br /><br />      if (msg-&gt;new_uri.s!=NULL)<br />            return pv_get_strval(msg, param, res, &amp;msg-&gt;new_uri);<br /><br />      return pv_get_strval(msg, param, res, &amp;msg-&gt;first_line.u.request.uri);<br />}<br />(:sourceend:)<br /><br />&gt;&gt;important&lt;&lt;<br />For all read access on the PVARs from contexts where the PVAR does not have any meaningful value ( eg Request-URI from a Reply Context ), make sure to use '''pv_get_null''' to signal this to the script writer.<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397920722-1397920417-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397920722:1397920417:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 05:13 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 626-640:</div>
        <div class='diffadd'><div class='diffmarkup'>Further on we will follow the implementation of the '''$ru''' pseudovariable, which offers read/write access to the SIP message Request-URI.<br />\\<br />First, PVT_RURI was added in '''pvar.h''' in '''enum _pv_type'''.<br />\\\<br />Afterwards, the following was added in '''_pv_names_table''' :<br /><br />(:source lang=C -link -getcode :)<br />        {{&quot;ru&quot;, (sizeof(&quot;ru&quot;)-1)}, /* */             <br />                PVT_RURI, pv_get_ruri, pv_set_ruri,  <br />                0, 0, 0, 0},  <br />(:sourceend:)<br /><br />Our new pvar will be accessible from script by using '''$ru'''. Read access from the script will lead to '''pv_get_ruri''' getting called, while write requests to $ru will make a call to '''pv_set_ruri'''.<br />\\<br />Since out $ru pvar does not support indexing by concept ( the SIP message has one and only one Request-URI ), there is no need to add a parsing or an indexing function for our pseudovariable. Also, no special initialization is needed for our psedovariable case, since we will operate directly on the currently processed SIP message in the script.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397920417-1397919609-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397920417:1397919609:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 05:00 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 599-625:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />The general syntax of an OpenSIPS pseudo-variable, along with the pv_export_t structure to be used in OpenSIPS ( both in core and in modules ) to expose new PVARs are shown below :<br /><br />(:source lang=C -link -getcode :)<br />/*! \brief<br /> * PV spec format:<br /> * - $class_name<br /> * - $class_name(inner_name)<br /> * - $(class_name[index])<br /> * - $(class_name(inner_name)[index])<br /> * - $(class_name{transformation})<br /> * - $(class_name(inner_name){transformation})<br /> * - $(class_name[index]{transformation})            <br /> * - $(class_name(inner_name)[index]{transformation})<br /> */             <br />typedef struct _pv_export {<br />        str name;                      /*!&lt; class name of PV */<br />        pv_type_t type;                /*!&lt; type of PV */<br />        pv_getf_t  getf;               /*!&lt; function to get the value */<br />        pv_setf_t  setf;               /*!&lt; function to set the value */<br />        pv_parse_name_f parse_name;    /*!&lt; function to parse the inner name */<br />        pv_parse_index_f parse_index;  /*!&lt; function to parse the index of PV */<br />        pv_init_param_f init_param;    /*!&lt; function to init the PV spec */<br />        int iparam;                    /*!&lt; parameter for the init function */<br />} pv_export_t;  <br />(:sourceend:)<br />\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397919609-1397919424-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397919609:1397919424:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 04:57 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 15-18 from:</div>
        <div class='diffdel'><div class='diffmarkup'>TBD<br />TBD<br />TBD<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>TBD \\<br />TBD \\<br />TBD \\<br /></div></div>
        <div class='difftype'>Changed lines 21-23 from:</div>
        <div class='diffdel'><div class='diffmarkup'>TBD<br />TBD<br />TBD</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>TBD \\ <br />TBD \\<br />TBD \\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397919424-1397919399-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397919424:1397919399:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 04:56 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 16-18 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>TBD<br />TBD<br /></div></div>
        <div class='difftype'>Added lines 21-22:</div>
        <div class='diffadd'><div class='diffmarkup'>TBD<br />TBD</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397919399-1397919374-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397919399:1397919374:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 04:56 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 15-16:</div>
        <div class='diffadd'><div class='diffmarkup'>TBD<br /></div></div>
        <div class='difftype'>Added lines 18-19:</div>
        <div class='diffadd'><div class='diffmarkup'><br />TBD</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397919374-1397919334-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397919374:1397919334:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 04:55 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 569-571 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Adding Core Pseudo-Variable<br /><br />TBD</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Adding a core Pseudo-Variable<br /><br />All the OpenSIPS core pseudo-variables are defined in '''pvar.c''' :<br />(:source lang=C -link -getcode :)<br />static pv_export_t _pv_names_table[] = {             <br />      {{&quot;avp&quot;, (sizeof(&quot;avp&quot;)-1)}, PVT_AVP, pv_get_avp, pv_set_avp,<br />            pv_parse_avp_name, pv_parse_index, 0, 0},<br />      {{&quot;hdr&quot;, (sizeof(&quot;hdr&quot;)-1)}, PVT_HDR, pv_get_hdr, 0, pv_parse_hdr_name,<br />            pv_parse_index, 0, 0},               <br />      {{&quot;hdrcnt&quot;, (sizeof(&quot;hdrcnt&quot;)-1)}, PVT_HDRCNT, pv_get_hdrcnt, 0, pv_parse_hdr_name, 0, 0, 0},<br />      {{&quot;var&quot;, (sizeof(&quot;var&quot;)-1)}, PVT_SCRIPTVAR, pv_get_scriptvar,<br />            pv_set_scriptvar, pv_parse_scriptvar_name, 0, 0, 0},<br />      {{&quot;ai&quot;, (sizeof(&quot;ai&quot;)-1)}, /* */             <br />            PVT_PAI_URI, pv_get_pai, 0,          <br />            0, 0, 0, 0},  <br />      {{&quot;au&quot;, (sizeof(&quot;au&quot;)-1)}, /* */<br />            PVT_AUTH_USERNAME, pv_get_authattr, 0,<br />            0, 0, pv_init_iname, 1},<br />...<br />...<br />...<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397919334-1397918978-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397919334:1397918978:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 04:49 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 569-572:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Adding Core Pseudo-Variable<br /><br />TBD<br /></div></div>
        <div class='difftype'>Added lines 1025-1029:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Management Interface API<br /><br />!!!! SQL Database API<br /><br />!!!! NoSQL API</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397918978-1397918812-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397918978:1397918812:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 04:46 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 1018-1021:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!! Statistics API<br /><br /></div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397918812:1397918773:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397918812:1397918773:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397918812:1397918773:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 04:46 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 456-458 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!! Locking API<br /><br />OpenSIPS has it's own locking API, and it is recommended to use it instead of the system exposed locks, since they offer greater flexibility - depending on the usage case and the menuconfig provided compilation flags, the OpenSIPS generic locks can be converted either to busy locks, futexes, SysV locks, etc. </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Extending OpenSIPS core Config File<br /><br />OpenSIPS uses flex and bison in order to parse the configuration file and then build the entire action tree that a SIP message will go through once it is read from network level. \\<br />When it comes to extending the OpenSIPS configuration file directly in the core, the developer can either choose to add a new core parameter, or a new core function. <br /><br />!!!!! Adding a core parameter<br /><br />In the following step by step tutorial, we will follow the implementation of the '''children''' core parameter, which is an integer controlling the number of OpenSIPS processes per UDP interface. \\<br />First of all, we will have to add the variable that will hold the value of our new core parameter. \\<br />In our case, in '''globals.h''' we have added <br />(:source lang=C -link -getcode :)<br />extern int children_no;<br />(:sourceend:)</div></div>
        <div class='difftype'>Changed lines 470-475 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The Locking API offers two distinct functionalities, one for using single lock elements, and another for operating on entire sets of locks.<br /><br />!!!!! Single Lock API<br /><br />The API can be used by including “locking.h” . The OpenSIPS generic lock is defined by the gen_lock_t structure. \\<br />Allocating a new lock is done by calling lock_alloc :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Adding the variable here will make it visible in both the OpenSIPS core and the OpenSIPS modules. '''main.c''' will hold the actual variable :</div></div>
        <div class='difftype'>Changed lines 472-476 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/* <br />Returns : <br />      A shared memory allocated lock, or NULL in case of an error.<br />*/<br />gen_lock_t *lock_alloc(void);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* Default value in case the parameter is not set from the script */<br />int children_no = 8;</div></div>
        <div class='difftype'>Changed lines 476-477 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Since  the locks usually have to be reachable by all processes fighting on some resource, the locks are allocated by default in shared memory. Also, note that it is not necessary to always allocate the lock separately - if the lock is embedded within a structure which is allocated in SHM, the effect is the same. \\<br />Before any operation on the lock, it must be initialized :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Next, we will have to modify the grammar in order to accept our new parameter.<br />In '''cfg.y''' , first we will define our new token :</div></div>
        <div class='difftype'>Changed lines 479-485 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock instance to be initialized<br />Returns :<br />      The initialized lock in case of success, or NULL in case of error.<br />*/<br />gen_lock_t* lock_init(gen_lock_t* lock);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>%token CHILDREN</div></div>
        <div class='difftype'>Changed line 482 from:</div>
        <div class='diffdel'><div class='diffmarkup'>In order to acquire a lock, one must use the lock_get function :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>And then we'll set the parsing rules for the new token</div></div>
        <div class='difftype'>Changed lines 484-488 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock to be acquired<br />*/<br />void lock_get(gen_lock_t *lock);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>| CHILDREN EQUAL NUMBER { children_no=$3; } <br />| CHILDREN EQUAL error { yyerror(&quot;number expected&quot;); }</div></div>
        <div class='difftype'>Changed lines 488-490 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The function will block if the lock is acquired by another process, and will only return once the lock has been acquired by the current process.<br />\\<br />For releasing a lock, lock_release should be used :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Our variable will have a numeric variable, anything else will trigger and error in parsing the OpenSIPS script.<br /><br />!!!!! Adding a core function<br /><br />In the following step by step tutorial, we will follow the implementation of the '''xlog''' core parameter, which is used to print debugging information to the logging facility.<br /><br />&gt;&gt;tip&lt;&lt;<br />Note that xlog can receive either a single parameter ( the string to be printed ), or two parameters ( the log level and then the string to be printed ).<br />&gt;&gt;&lt;&lt;<br /><br />First, the grammar will have to be extended. In '''cfg,y''' we have :</div></div>
        <div class='difftype'>Changed lines 500-504 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock to be released.<br />*/<br />void lock_release(gen_lock_t *lock);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>%token XLOG<br />...<br />...<br />| XLOG LPAREN STRING RPAREN {                                                     <br />      mk_action1($$, XLOG_T, STR_ST, $3); }                             <br /> XLOG LPAREN STRING COMMA STRING RPAREN {                                        <br />      mk_action2($$, XLOG_T, STR_ST, STR_ST, $3, $5); } </div></div>
        <div class='difftype'>Changed lines 509-511 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Once a lock is no longer needed, one must first destroy the lock, and then the lock can be safely deallocated.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Note the two different forms of xlog displayed above.<br />\\<br />From the grammar, we will start building the actions. In '''route.c''' we will define the fixup part of the function, where all the sanity checks and parameter parsing should be done. The fixup part will be invoked only once, at script parsing.</div></div>
        <div class='difftype'>Changed lines 513-522 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock to be destroyed<br />*/<br />void lock_destroy(gen_lock_t *lock);<br />/*<br />Parameters :<br />      lock - the lock to be deallocated<br />*/<br />void lock_dealloc(gen_lock_t *lock);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>case XLOG_T: <br />      s.s = (char*)t-&gt;elem[1].u.data; <br />      if (s.s == NULL) { <br />            /* commands have only one parameter */ <br />            s.s = (char *)t-&gt;elem[0].u.data; <br />            s.len = strlen(s.s); <br />            if(s.len==0) { <br />                  LM_ERR(&quot;param is empty string!\n&quot;); <br />                  return E_CFG; <br />            } <br /><br />            /* parse the format provided to xlog - we can have variables inside */<br />            if(pv_parse_format(&amp;s ,&amp;model) || model==NULL) { <br />                  LM_ERR(&quot;wrong format [%s] for value param!\n&quot;, s.s); <br />                  ret=E_BUG; <br />                  goto error; <br />            } <br /><br />            /* overwrite the data that will be passed to contain our new parsed model */<br />            t-&gt;elem[0].u.data = (void*)model; <br />            t-&gt;elem[0].type = SCRIPTVAR_ELEM_ST; <br />      } else {<br />            /* two parameters */</div></div>
        <div class='difftype'>Changed line 538 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Here is a code snippet showing the typical code used when dealing with single lock instances :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>In '''action.c''' we will have to add the actual code that needs to get executed when the function gets called from the OpenSIPS script at runtime :</div></div>
        <div class='difftype'>Changed lines 540-586 from:</div>
        <div class='diffdel'><div class='diffmarkup'><br />gen_lock_t *my_lock;<br /><br />int init_function(void) <br />{<br />	/* … */<br /><br />	my_lock = lock_alloc();<br />	if (my_lock == NULL) {<br />		LM_ERR(“Failed to allocate lock \n”);<br />		return -1;<br />	}<br /><br />	if (lock_init(my_lock) == NULL) {<br />		LM_ERR(“Failed to init lock \n”);<br />		return -1;<br />	}<br /><br />	/* … */<br />	return 0;<br />}<br /><br /><br />int do_work(void) <br />{<br /><br />	/* … */<br />	lock_get(my_lock)<br /><br /><br />	/* critical region protected by our lock<br />	generally recommended to keep critical regions short<br />	I/O operations to be avoided in such critical regions */<br /><br />	lock_release(my_lock)<br />	/* … */<br />}<br /><br />void destroy_function(void) {<br /><br />	/* … */<br /><br />	lock_destroy(my_lock);<br />	lock_dealloc(my_lock);<br /><br />	/* … */<br />}</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>case XLOG_T:<br />      /* add helpers for tracing the script */<br />      script_trace(&quot;core&quot;, &quot;xlog&quot;, msg, a-&gt;line) ;<br />      if (a-&gt;elem[1].u.data != NULL) {<br />            /* we have two parameters */ <br /><br />            /* do security checks for the types of the provided parameters, second param has to be a SCRIPTVAR model as we've coded in the fixup */<br />            if (a-&gt;elem[1].type != SCRIPTVAR_ELEM_ST) { <br />                  LM_ALERT(&quot;BUG in xlog() type %d\n&quot;, a-&gt;elem[1].type); <br />                  ret=E_BUG; <br />                  break; <br />            }<br />            /* log level should be a plaintext string */ <br />            if (a-&gt;elem[0].type != STR_ST) { <br />                  LM_ALERT(&quot;BUG in xlog() type %d\n&quot;, a-&gt;elem[0].type); <br />                  ret=E_BUG; <br />                  break; <br />            }<br />          <br />            /* call our C code function implementing the desired actions */<br />            if (xlog_2(msg,a-&gt;elem[0].u.data, a-&gt;elem[1].u.data) &lt; 0) { <br />                  LM_ALERT(&quot;Cannot print xlog debug message&quot;); <br />                  break;<br />            }<br />      } else {<br />            /* one parameter case */<br />      }</div></div>
        <div class='difftype'>Changed lines 569-572 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Lock Set API<br /><br />Operating on an entire array of locks can become very useful when dealing with structures like hashes, where you would need a lock per each hash entry.\\<br />The API can be used by including '''locking.h''' . The OpenSIPS generic array of locks is defined by the gen_lock_set_t structure, and working with it is very similar in concept to operating a single lock entry.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Adding Transformations<br /><br />The so called transformations are methods operating directly on the OpenSIPS various pseudo-variables. A transformation takes as input the value of the provided pseudo-variable and processes it, outputing a 'transformed' version. </div></div>
        <div class='difftype'>Changed lines 573-574 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Allocating a new lock set is done by calling lock_set_alloc :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Transformation examples are the URI transformations ( working on a SIP URI, and they allow extracting various useful information from the URI, like the user , domain, various parameters, etc ), the S class of transformations ( work on generic strings, and provide various useful methods as fetching the length of the string, searching the first occurrence of a character inside the string, etc ), and many others – see http://www.opensips.org/Documentation/Script-Tran-1-10<br />\\</div></div>
        <div class='difftype'>Changed lines 576-580 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/* <br />Returns : <br />      A shared memory allocated lock set, or NULL in case of an error.<br />*/<br />gen_lock_set_t *lock_set_alloc(void);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'># example of usage<br />$var(tutorial)  = “OpenSIPSDevel”;<br />xlog(“Our variable has $(var(tutorial){s.len}) characters \n”);</div></div>
        <div class='difftype'>Changed lines 581-582 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Since  the locks usually have to be reachable by all processes fighting on some resource, the locks are allocated by default in shared memory. Also, note that it is not necessary to always allocate the lock set separately - if the lock set is embedded within a structure which is allocated in SHM, the effect is the same. \\<br />Before any operation on the lock set, it must be initialized :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;tip&lt;&lt;<br />Note that transformations can be chained together, which will have an impact on the transformations C development<br />&gt;&gt;&lt;&lt;<br /><br />\\</div></div>
        <div class='difftype'>Changed lines 588-594 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock set instance to be initialized<br />Returns :<br />      The initialized lock in case of success, or NULL in case of error.<br />*/<br />gen_lock_set_t* lock_set_init(gen_lock_set_t* lock);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>$var(our_uri) = “sip:vlad@opensips.org”;<br />xlog(“The username of our URI has $(var(our_uri){uri.user}{s.len}) characters \n”);</div></div>
        <div class='difftype'>Changed lines 592-597 from:</div>
        <div class='diffdel'><div class='diffmarkup'>In order to acquire a lock in a lock set, one must use the lock_set_get function :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>In our examples, '''uri''' and '''s''' are the so called '''classes of transformations''', while '''user''' and '''len''' are the actual operations within the class.<br />\\<br />We will further follow the implementation of the uri class of transformation, and then focusing on the user function.\\<br />Adding new classes of transformations is done in '''transformations.h''' , where , for our example's case, '''TR_URI''' was added. Then, each class of transformations should have it's own functions enumeration, which is our case is enum '''_tr_uri_subtype''' . \\<br />'''transformations.c''' holds the actual implementation of transformations. '''parse_transformation''' will get called when the script needs to evaluate a transformation. There, we should add the matching for our new class of transformations :<br /></div></div>
        <div class='difftype'>Changed lines 599-604 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock to be acquired<br />      entry - the entry in the lock set that needs to be acquired<br />*/<br />void lock_set_get(gen_lock_set_t *lock,int entry);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>else if(tclass.len==3 &amp;&amp; strncasecmp(tclass.s, &quot;uri&quot;, 3)==0) { <br />      t-&gt;type = TR_URI; <br />      t-&gt;trf = tr_eval_uri; <br />      s.s = p; s.len = in-&gt;s + in-&gt;len - p; <br />      p0 = tr_parse_uri(&amp;s, t); <br />      if(p0==NULL) <br />            goto error; <br />      p = p0; <br />}</div></div>
        <div class='difftype'>Changed lines 610-612 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The function will block if the lock is acquired by another process, and will only return once the lock has been acquired by the current process.<br />\\<br />For releasing a lock, lock_set_release should be used :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Here, there are two main functions of interest. First, there is the '''tr_parse_uri''' function responsible for matching the actual function that needs to get executed inside our class of transformation, doing whatever parsing that is necessary for the transformation and advancing the position of the current pointer in the transformation string. This is a fixup type function and is only evaluated once :<br /></div></div>
        <div class='difftype'>Changed lines 613-618 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock to be released.<br />      entry - the entry in the lock set that needs to be released<br />*/<br />void lock_set_release(gen_lock_set_t *lock,int entry);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>p = in-&gt;s;<br />name.s = in-&gt;s;<br /><br />/* find next token */<br />while(*p &amp;&amp; *p!=TR_PARAM_MARKER &amp;&amp; *p!=TR_RBRACKET) p++;<br />if(*p=='\0') {<br />      LM_ERR(&quot;invalid transformation: %.*s\n&quot;, in-&gt;len, in-&gt;s);<br />      goto error;<br />}<br />name.len = p - name.s;<br />trim(&amp;name);<br /><br />if(name.len==4 &amp;&amp; strncasecmp(name.s, &quot;user&quot;, 4)==0) {<br />      t-&gt;subtype = TR_URI_USER;<br />      return p;<br />}</div></div>
        <div class='difftype'>Changed lines 631-632 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Once a lock set is no longer needed, one must first destroy the lock set, and then the lock set can be safely deallocated.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>After we've decided what actually needs to be done and did all the parsing,the  '''tr_eval_uri''' will be the one gets called at runtime and that actually evaluates our transformation and returns the new transformation output. \\<br />In our case, the function parses the provided string into a SIP URI, and then populates the output pv_value_t accordingly to the subtype provided :</div></div>
        <div class='difftype'>Changed lines 634-643 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock set to be destroyed<br />*/<br />void lock_set_destroy(gen_lock_set_t *lock);<br />/*<br />Parameters :<br />      lock - the lock set to be deallocated<br />*/<br />void lock_set_dealloc(gen_lock_set_t *lock);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* make a PKG copy of the input */<br />_tr_uri.s = (char*)pkg_malloc((val-&gt;rs.len+1)*sizeof(char));<br />memcpy(_tr_uri.s, val-&gt;rs.s, val-&gt;rs.len);<br />_tr_uri.s[_tr_uri.len] = '\0';<br />...<br />...<br />/* parse the input URI */<br />if(parse_uri(_tr_uri.s, _tr_uri.len, &amp;_tr_parsed_uri)!=0) {<br />      LM_ERR(&quot;invalid uri [%.*s]\n&quot;, val-&gt;rs.len,val-&gt;rs.s);<br />      return -1;<br />}<br />...<br />...<br />/* zero out the output val */<br />memset(val, 0, sizeof(pv_value_t));<br />/* the output pvar will be a string */<br />val-&gt;flags = PV_VAL_STR;<br /><br />switch(subtype) {<br />      case TR_URI_USER:<br />            val-&gt;rs = (_tr_parsed_uri.user.s)?_tr_parsed_uri.user:_tr_empty;<br />            break;<br />}</div></div>
        <div class='difftype'>Added lines 658-660:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Locking API<br /><br />OpenSIPS has it's own locking API, and it is recommended to use it instead of the system exposed locks, since they offer greater flexibility - depending on the usage case and the menuconfig provided compilation flags, the OpenSIPS generic locks can be converted either to busy locks, futexes, SysV locks, etc. </div></div>
        <div class='difftype'>Changed lines 662-667 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Here is a code snippet showing the typical code used when dealing with single lock instances :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The Locking API offers two distinct functionalities, one for using single lock elements, and another for operating on entire sets of locks.<br /><br />!!!!! Single Lock API<br /><br />The API can be used by including “locking.h” . The OpenSIPS generic lock is defined by the gen_lock_t structure. \\<br />Allocating a new lock is done by calling lock_alloc :</div></div>
        <div class='difftype'>Changed lines 669-719 from:</div>
        <div class='diffdel'><div class='diffmarkup'>gen_lock_set_t *my_lock;<br /><br />int init_function(void) <br />{<br />	/* … */<br /><br />        /* allocate lock set with 32 entries */<br />	my_lock = lock_set_alloc(32);<br />	if (my_lock == NULL) {<br />		LM_ERR(“Failed to allocate lock set \n”);<br />		return -1;<br />	}<br /><br />	if (lock_set_init(my_lock) == NULL) {<br />		LM_ERR(“Failed to init lock set \n”);<br />		return -1;<br />	}<br /><br />	/* … */<br />	return 0;<br />}<br /><br />int do_work(void) <br />{<br /><br />	/* … */<br />	<br />	/* acquire entry 5 in the lock set */<br />	lock_set_get(my_lock,5)<br /><br />	/* also acquire entry 21 in the lock set */<br />	lock_set_get(my_lock,21);<br /><br />	/* critical region protected by our lock<br />	generally recommended to keep critical regions short<br />	I/O operations to be avoided in such critical regions */<br /><br />	lock_set_release(my_lock,21);<br />	lock_set_release(my_lock,5);<br />	/* … */<br />}<br /><br />void destroy_function(void) <br />{<br />	/* … */<br /><br />	lock_set_destroy(my_lock);<br />	lock_set_dealloc(my_lock);<br /><br />	/* … */<br />}</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* <br />Returns : <br />      A shared memory allocated lock, or NULL in case of an error.<br />*/<br />gen_lock_t *lock_alloc(void);</div></div>
        <div class='difftype'>Changed lines 675-684 from:</div>
        <div class='diffdel'><div class='diffmarkup'><br />!!!! Timer API<br /><br />OpenSIPS exposes it's own API for implementing timer functions, with seconds and microsecond precision.\\<br />The OpenSIPS timer architecture is made out of the so called 'timer keeper' , which is a process which just increments global counter of second and microsecond precision, and one process which will execute the various timer functions when their time to execute has arrived.\\<br />Also, the OpenSIPS timers support automatic re-calibration in order to compensate timer drifting in case the timer executed functions do not complete in timely manners.<br /><br />!!!!! Global Timer Process<br /><br />'''timer.h''' exposes all the relevant functionalities for operating the OpenSIPS timers. For registering a new timer function with second precision, use :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />Since  the locks usually have to be reachable by all processes fighting on some resource, the locks are allocated by default in shared memory. Also, note that it is not necessary to always allocate the lock separately - if the lock is embedded within a structure which is allocated in SHM, the effect is the same. \\<br />Before any operation on the lock, it must be initialized :</div></div>
        <div class='difftype'>Changed lines 681-684 from:</div>
        <div class='diffdel'><div class='diffmarkup'>	label – opaque string containing a short timer function description ( to be used for logging )<br />	f – the actual function to be called<br />	param – parameter to be provided to the timer function<br />	interval – the interval, in seconds, that the function needs to be called at</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      lock - the lock instance to be initialized</div></div>
        <div class='difftype'>Changed line 683 from:</div>
        <div class='diffdel'><div class='diffmarkup'>	0 in case of success, negative code in case of internal error.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      The initialized lock in case of success, or NULL in case of error.</div></div>
        <div class='difftype'>Changed lines 685-686 from:</div>
        <div class='diffdel'><div class='diffmarkup'>int register_timer(char *label, timer_function f, void* param, <br />      unsigned int interval);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>gen_lock_t* lock_init(gen_lock_t* lock);<br />(:sourceend:)<br />\\<br />In order to acquire a lock, one must use the lock_get function :<br />(:source lang=C -link -getcode :)</div></div>
        <div class='difftype'>Deleted line 690:</div>
        <div class='diffdel'><div class='diffmarkup'>The seconds callback </div></div>
        <div class='difftype'>Changed lines 692-693 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      ticks - represents the current number of seconds since OpenSIPS startup when the callback is called at<br />      param - is the parameter provided at timer function registration.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      lock - the lock to be acquired</div></div>
        <div class='difftype'>Changed line 694 from:</div>
        <div class='diffdel'><div class='diffmarkup'>typedef void (timer_function)(unsigned int ticks, void* param); </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>void lock_get(gen_lock_t *lock);</div></div>
        <div class='difftype'>Changed lines 697-699 from:</div>
        <div class='diffdel'><div class='diffmarkup'>For registering a microsecond timer, you should use </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The function will block if the lock is acquired by another process, and will only return once the lock has been acquired by the current process.<br />\\<br />For releasing a lock, lock_release should be used :</div></div>
        <div class='difftype'>Changed lines 703-708 from:</div>
        <div class='diffdel'><div class='diffmarkup'>	label – opaque string containing a short timer function description ( to be used for logging )<br />	f – the actual function to be called<br />	param – parameter to be provided to the timer function<br />	interval – the interval, in microseconds, that the function needs to be called at<br />Returns :<br />	0 in case of success, negative code in case of internal error.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      lock - the lock to be released.</div></div>
        <div class='difftype'>Changed line 705 from:</div>
        <div class='diffdel'><div class='diffmarkup'>int register_utimer(char *label, utimer_function f, void* param, unsigned int interval);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>void lock_release(gen_lock_t *lock);</div></div>
        <div class='difftype'>Changed lines 707-712 from:</div>
        <div class='diffdel'><div class='diffmarkup'><br />!!!!! Dedicated Timer Process<br /><br />Since, by default, all the registered timer functions are called from within the same process context, in case you are writing a timer process that is doing I/O, it is better to register an entirely new process where to run your code, since your function might slow down all the other timer functions running in OpenSIPS.\\<br />Registering a new timer process can be done by calling :<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />Once a lock is no longer needed, one must first destroy the lock, and then the lock can be safely deallocated.</div></div>
        <div class='difftype'>Changed lines 712-718 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      label - opaque string containing a short timer function description ( to be used for logging )<br />      f - the actual function to be called<br />      param - parameter to be provided to the timer function<br />      interval - the interval, in seconds, that the function needs to be called at<br />      flags - flags controlling process behavior. Currently only option is TIMER_PROC_INIT_FLAG , which leads to child_init to be called in the new timer process context. To be used when inside the timer you need to operate various I/O options which generally require a per process connection.<br />Returns :<br />      struct sr_timer_process pointer in case of success, or NULL in case of error.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      lock - the lock to be destroyed</div></div>
        <div class='difftype'>Changed lines 714-719 from:</div>
        <div class='diffdel'><div class='diffmarkup'>void* register_timer_process(char *label, timer_function f, void* param, <br />      unsigned int interval, unsigned int flags);<br />(:sourceend:)<br />\\<br />The output struct sr_timer_process pointer can be further use to group together multiple functions inside the same process, by calling :<br />(:source lang=C -link -getcode :)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>void lock_destroy(gen_lock_t *lock);</div></div>
        <div class='difftype'>Changed lines 716-723 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Parameters:<br />      label – opaque string containing a short timer function description ( to be used for logging )<br />      f – the actual function to be called<br />      param – parameter to be provided to the timer function<br />      interval – the interval, in seconds, that the function needs to be called at<br />      timer – the  struct sr_timer_process pointer obtained by previously calling  register_timer_process<br />Returns:<br />      0 in case of success, negative code in case of internal error.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Parameters :<br />      lock - the lock to be deallocated</div></div>
        <div class='difftype'>Changed lines 719-720 from:</div>
        <div class='diffdel'><div class='diffmarkup'>int append_timer_to_process( char *label, timer_function f, void* param, <br />      unsigned int interval, void *timer);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>void lock_dealloc(gen_lock_t *lock);</div></div>
        <div class='difftype'>Changed lines 722-727 from:</div>
        <div class='diffdel'><div class='diffmarkup'><br />&gt;&gt;important&lt;&lt;<br />Important to note here that all the above timer related functions MUST be called for the context of the attendant process before forking is done ( so either from the modules mod_init or directly from the core, before forking ).<br />&gt;&gt;&lt;&lt;<br /><br />Below is a code snippet exemplifying how the dialog module's code used for registering two timers, with an option to either use the global timer process or to have it's own separate timer :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Here is a code snippet showing the typical code used when dealing with single lock instances :</div></div>
        <div class='difftype'>Changed lines 724-748 from:</div>
        <div class='diffdel'><div class='diffmarkup'>if (dlg_have_own_timer_proc) { <br />      LM_INFO(&quot;Running with dedicated dialog timer process\n&quot;); <br />      dlg_own_timer_proc = register_timer_process( &quot;dlg-timer&quot;, <br />            dlg_timer_routine, NULL,1,TIMER_PROC_INIT_FLAG ); <br />      if (dlg_own_timer_proc == NULL) { <br />            LM_ERR(&quot;Failed to init dialog own timer proc\n&quot;); <br />            return -1; <br />      } <br />      if (append_timer_to_process(&quot;dlg-pinger&quot;, dlg_ping_routine, NULL, <br />            ping_interval,dlg_own_timer_proc) &lt; 0) { <br />            LM_ERR(&quot;Failed to append ping timer \n&quot;); <br />            return -1; <br />      }<br />} else { <br />      if ( register_timer( &quot;dlg-timer&quot;, dlg_timer_routine, NULL, 1)&lt;0 ) { <br />            LM_ERR(&quot;failed to register timer \n&quot;); <br />            return -1; <br />      } <br /><br />      if ( register_timer( &quot;dlg-pinger&quot;, dlg_ping_routine, NULL, <br />            ping_interval)&lt;0) { <br />            LM_ERR(&quot;failed to register timer 2 \n&quot;); <br />            return -1; <br />      } <br />} </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />gen_lock_t *my_lock;<br /><br />int init_function(void) <br />{<br />	/* … */<br /><br />	my_lock = lock_alloc();<br />	if (my_lock == NULL) {<br />		LM_ERR(“Failed to allocate lock \n”);<br />		return -1;<br />	}<br /><br />	if (lock_init(my_lock) == NULL) {<br />		LM_ERR(“Failed to init lock \n”);<br />		return -1;<br />	}<br /><br />	/* … */<br />	return 0;<br />}<br /><br /><br />int do_work(void) <br />{<br /><br />	/* … */<br />	lock_get(my_lock)<br /><br /><br />	/* critical region protected by our lock<br />	generally recommended to keep critical regions short<br />	I/O operations to be avoided in such critical regions */<br /><br />	lock_release(my_lock)<br />	/* … */<br />}<br /><br />void destroy_function(void) {<br /><br />	/* … */<br /><br />	lock_destroy(my_lock);<br />	lock_dealloc(my_lock);<br /><br />	/* … */<br />}</div></div>
        <div class='difftype'>Added lines 772-776:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!!! Lock Set API<br /><br />Operating on an entire array of locks can become very useful when dealing with structures like hashes, where you would need a lock per each hash entry.\\<br />The API can be used by including '''locking.h''' . The OpenSIPS generic array of locks is defined by the gen_lock_set_t structure, and working with it is very similar in concept to operating a single lock entry.</div></div>
        <div class='difftype'>Changed line 778 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Also, the OpenSIPS API also exposes the number of seconds and microseconds passed from the OpenSIPS start time. These can be accessed by calling </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Allocating a new lock set is done by calling lock_set_alloc :</div></div>
        <div class='difftype'>Changed lines 780-782 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/*<br />Returns :<br />      the number of seconds elapsed from OpenSIPS start</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* <br />Returns : <br />      A shared memory allocated lock set, or NULL in case of an error.</div></div>
        <div class='difftype'>Changed lines 784-790 from:</div>
        <div class='diffdel'><div class='diffmarkup'>unsigned int get_ticks(void);<br /><br />/*<br />Returns:<br />      the number of microseconds elapsed from OpenSIPS start<br />*/<br />utime_t get_uticks(void);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>gen_lock_set_t *lock_set_alloc(void);</div></div>
        <div class='difftype'>Deleted lines 785-798:</div>
        <div class='diffdel'><div class='diffmarkup'><br />!!!! Extending OpenSIPS core Config File<br /><br />OpenSIPS uses flex and bison in order to parse the configuration file and then build the entire action tree that a SIP message will go through once it is read from network level. \\<br />When it comes to extending the OpenSIPS configuration file directly in the core, the developer can either choose to add a new core parameter, or a new core function. <br /><br />!!!!! Adding a core parameter<br /><br />In the following step by step tutorial, we will follow the implementation of the '''children''' core parameter, which is an integer controlling the number of OpenSIPS processes per UDP interface. \\<br />First of all, we will have to add the variable that will hold the value of our new core parameter. \\<br />In our case, in '''globals.h''' we have added <br />(:source lang=C -link -getcode :)<br />extern int children_no;<br />(:sourceend:)</div></div>
        <div class='difftype'>Changed lines 787-788 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Adding the variable here will make it visible in both the OpenSIPS core and the OpenSIPS modules. '''main.c''' will hold the actual variable :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Since  the locks usually have to be reachable by all processes fighting on some resource, the locks are allocated by default in shared memory. Also, note that it is not necessary to always allocate the lock set separately - if the lock set is embedded within a structure which is allocated in SHM, the effect is the same. \\<br />Before any operation on the lock set, it must be initialized :</div></div>
        <div class='difftype'>Changed lines 790-791 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/* Default value in case the parameter is not set from the script */<br />int children_no = 8;</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock set instance to be initialized<br />Returns :<br />      The initialized lock in case of success, or NULL in case of error.<br />*/<br />gen_lock_set_t* lock_set_init(gen_lock_set_t* lock);</div></div>
        <div class='difftype'>Changed lines 799-800 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Next, we will have to modify the grammar in order to accept our new parameter.<br />In '''cfg.y''' , first we will define our new token :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>In order to acquire a lock in a lock set, one must use the lock_set_get function :</div></div>
        <div class='difftype'>Changed lines 801-806 from:</div>
        <div class='diffdel'><div class='diffmarkup'>%token CHILDREN</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock to be acquired<br />      entry - the entry in the lock set that needs to be acquired<br />*/<br />void lock_set_get(gen_lock_set_t *lock,int entry);</div></div>
        <div class='difftype'>Changed lines 809-811 from:</div>
        <div class='diffdel'><div class='diffmarkup'>And then we'll set the parsing rules for the new token</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The function will block if the lock is acquired by another process, and will only return once the lock has been acquired by the current process.<br />\\<br />For releasing a lock, lock_set_release should be used :</div></div>
        <div class='difftype'>Changed lines 813-814 from:</div>
        <div class='diffdel'><div class='diffmarkup'>| CHILDREN EQUAL NUMBER { children_no=$3; } <br />| CHILDREN EQUAL error { yyerror(&quot;number expected&quot;); }</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock to be released.<br />      entry - the entry in the lock set that needs to be released<br />*/<br />void lock_set_release(gen_lock_set_t *lock,int entry);</div></div>
        <div class='difftype'>Changed lines 821-831 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Our variable will have a numeric variable, anything else will trigger and error in parsing the OpenSIPS script.<br /><br />!!!!! Adding a core function<br /><br />In the following step by step tutorial, we will follow the implementation of the '''xlog''' core parameter, which is used to print debugging information to the logging facility.<br /><br />&gt;&gt;tip&lt;&lt;<br />Note that xlog can receive either a single parameter ( the string to be printed ), or two parameters ( the log level and then the string to be printed ).<br />&gt;&gt;&lt;&lt;<br /><br />First, the grammar will have to be extended. In '''cfg,y''' we have :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Once a lock set is no longer needed, one must first destroy the lock set, and then the lock set can be safely deallocated.</div></div>
        <div class='difftype'>Changed lines 823-829 from:</div>
        <div class='diffdel'><div class='diffmarkup'>%token XLOG<br />...<br />...<br />| XLOG LPAREN STRING RPAREN {                                                     <br />      mk_action1($$, XLOG_T, STR_ST, $3); }                             <br /> XLOG LPAREN STRING COMMA STRING RPAREN {                                        <br />      mk_action2($$, XLOG_T, STR_ST, STR_ST, $3, $5); } </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters :<br />      lock - the lock set to be destroyed<br />*/<br />void lock_set_destroy(gen_lock_set_t *lock);<br />/*<br />Parameters :<br />      lock - the lock set to be deallocated<br />*/<br />void lock_set_dealloc(gen_lock_set_t *lock);</div></div>
        <div class='difftype'>Changed lines 835-837 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Note the two different forms of xlog displayed above.<br />\\<br />From the grammar, we will start building the actions. In '''route.c''' we will define the fixup part of the function, where all the sanity checks and parameter parsing should be done. The fixup part will be invoked only once, at script parsing.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Here is a code snippet showing the typical code used when dealing with single lock instances :</div></div>
        <div class='difftype'>Changed lines 837-859 from:</div>
        <div class='diffdel'><div class='diffmarkup'>case XLOG_T: <br />      s.s = (char*)t-&gt;elem[1].u.data; <br />      if (s.s == NULL) { <br />            /* commands have only one parameter */ <br />            s.s = (char *)t-&gt;elem[0].u.data; <br />            s.len = strlen(s.s); <br />            if(s.len==0) { <br />                  LM_ERR(&quot;param is empty string!\n&quot;); <br />                  return E_CFG; <br />            } <br /><br />            /* parse the format provided to xlog - we can have variables inside */<br />            if(pv_parse_format(&amp;s ,&amp;model) || model==NULL) { <br />                  LM_ERR(&quot;wrong format [%s] for value param!\n&quot;, s.s); <br />                  ret=E_BUG; <br />                  goto error; <br />            } <br /><br />            /* overwrite the data that will be passed to contain our new parsed model */<br />            t-&gt;elem[0].u.data = (void*)model; <br />            t-&gt;elem[0].type = SCRIPTVAR_ELEM_ST; <br />      } else {<br />            /* two parameters */</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>gen_lock_set_t *my_lock;<br /><br />int init_function(void) <br />{<br />	/* … */<br /><br />        /* allocate lock set with 32 entries */<br />	my_lock = lock_set_alloc(32);<br />	if (my_lock == NULL) {<br />		LM_ERR(“Failed to allocate lock set \n”);<br />		return -1;<br />	}<br /><br />	if (lock_set_init(my_lock) == NULL) {<br />		LM_ERR(“Failed to init lock set \n”);<br />		return -1;<br />	}<br /><br />	/* … */<br />	return 0;<br />}<br /><br />int do_work(void) <br />{<br /><br />	/* … */<br />	<br />	/* acquire entry 5 in the lock set */<br />	lock_set_get(my_lock,5)<br /><br />	/* also acquire entry 21 in the lock set */<br />	lock_set_get(my_lock,21);<br /><br />	/* critical region protected by our lock<br />	generally recommended to keep critical regions short<br />	I/O operations to be avoided in such critical regions */<br /><br />	lock_set_release(my_lock,21);<br />	lock_set_release(my_lock,5);<br />	/* … */<br />}<br /><br />void destroy_function(void) <br />{<br />	/* … */<br /><br />	lock_set_destroy(my_lock);<br />	lock_set_dealloc(my_lock);<br /><br />	/* … */<br />}</div></div>
        <div class='difftype'>Changed lines 889-890 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\<br />In '''action.c''' we will have to add the actual code that needs to get executed when the function gets called from the OpenSIPS script at runtime :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!! Timer API<br /><br />OpenSIPS exposes it's own API for implementing timer functions, with seconds and microsecond precision.\\<br />The OpenSIPS timer architecture is made out of the so called 'timer keeper' , which is a process which just increments global counter of second and microsecond precision, and one process which will execute the various timer functions when their time to execute has arrived.\\<br />Also, the OpenSIPS timers support automatic re-calibration in order to compensate timer drifting in case the timer executed functions do not complete in timely manners.<br /><br />!!!!! Global Timer Process<br /><br />'''timer.h''' exposes all the relevant functionalities for operating the OpenSIPS timers. For registering a new timer function with second precision, use :</div></div>
        <div class='difftype'>Changed lines 900-926 from:</div>
        <div class='diffdel'><div class='diffmarkup'>case XLOG_T:<br />      /* add helpers for tracing the script */<br />      script_trace(&quot;core&quot;, &quot;xlog&quot;, msg, a-&gt;line) ;<br />      if (a-&gt;elem[1].u.data != NULL) {<br />            /* we have two parameters */ <br /><br />            /* do security checks for the types of the provided parameters, second param has to be a SCRIPTVAR model as we've coded in the fixup */<br />            if (a-&gt;elem[1].type != SCRIPTVAR_ELEM_ST) { <br />                  LM_ALERT(&quot;BUG in xlog() type %d\n&quot;, a-&gt;elem[1].type); <br />                  ret=E_BUG; <br />                  break; <br />            }<br />            /* log level should be a plaintext string */ <br />            if (a-&gt;elem[0].type != STR_ST) { <br />                  LM_ALERT(&quot;BUG in xlog() type %d\n&quot;, a-&gt;elem[0].type); <br />                  ret=E_BUG; <br />                  break; <br />            }<br />          <br />            /* call our C code function implementing the desired actions */<br />            if (xlog_2(msg,a-&gt;elem[0].u.data, a-&gt;elem[1].u.data) &lt; 0) { <br />                  LM_ALERT(&quot;Cannot print xlog debug message&quot;); <br />                  break;<br />            }<br />      } else {<br />            /* one parameter case */<br />      }</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters :<br />	label – opaque string containing a short timer function description ( to be used for logging )<br />	f – the actual function to be called<br />	param – parameter to be provided to the timer function<br />	interval – the interval, in seconds, that the function needs to be called at<br />Returns :<br />	0 in case of success, negative code in case of internal error.<br />*/<br />int register_timer(char *label, timer_function f, void* param, <br />      unsigned int interval);<br />/*<br />The seconds callback <br />Parameters :<br />      ticks - represents the current number of seconds since OpenSIPS startup when the callback is called at<br />      param - is the parameter provided at timer function registration.<br />*/<br />typedef void (timer_function)(unsigned int ticks, void* param); </div></div>
        <div class='difftype'>Deleted lines 918-921:</div>
        <div class='diffdel'><div class='diffmarkup'><br />!!!! Adding Transformations<br /><br />The so called transformations are methods operating directly on the OpenSIPS various pseudo-variables. A transformation takes as input the value of the provided pseudo-variable and processes it, outputing a 'transformed' version. </div></div>
        <div class='difftype'>Changed lines 920-921 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Transformation examples are the URI transformations ( working on a SIP URI, and they allow extracting various useful information from the URI, like the user , domain, various parameters, etc ), the S class of transformations ( work on generic strings, and provide various useful methods as fetching the length of the string, searching the first occurrence of a character inside the string, etc ), and many others – see http://www.opensips.org/Documentation/Script-Tran-1-10<br />\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>For registering a microsecond timer, you should use </div></div>
        <div class='difftype'>Changed lines 922-924 from:</div>
        <div class='diffdel'><div class='diffmarkup'># example of usage<br />$var(tutorial)  = “OpenSIPSDevel”;<br />xlog(“Our variable has $(var(tutorial){s.len}) characters \n”);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters :<br />	label – opaque string containing a short timer function description ( to be used for logging )<br />	f – the actual function to be called<br />	param – parameter to be provided to the timer function<br />	interval – the interval, in microseconds, that the function needs to be called at<br />Returns :<br />	0 in case of success, negative code in case of internal error.<br />*/<br />int register_utimer(char *label, utimer_function f, void* param, unsigned int interval);</div></div>
        <div class='difftype'>Changed lines 933-939 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\<br /><br />&gt;&gt;tip&lt;&lt;<br />Note that transformations can be chained together, which will have an impact on the transformations C development<br />&gt;&gt;&lt;&lt;<br /><br />\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!!! Dedicated Timer Process<br /><br />Since, by default, all the registered timer functions are called from within the same process context, in case you are writing a timer process that is doing I/O, it is better to register an entirely new process where to run your code, since your function might slow down all the other timer functions running in OpenSIPS.\\<br />Registering a new timer process can be done by calling :<br /></div></div>
        <div class='difftype'>Changed lines 940-941 from:</div>
        <div class='diffdel'><div class='diffmarkup'>$var(our_uri) = “sip:vlad@opensips.org”;<br />xlog(“The username of our URI has $(var(our_uri){uri.user}{s.len}) characters \n”);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters :<br />      label - opaque string containing a short timer function description ( to be used for logging )<br />      f - the actual function to be called<br />      param - parameter to be provided to the timer function<br />      interval - the interval, in seconds, that the function needs to be called at<br />      flags - flags controlling process behavior. Currently only option is TIMER_PROC_INIT_FLAG , which leads to child_init to be called in the new timer process context. To be used when inside the timer you need to operate various I/O options which generally require a per process connection.<br />Returns :<br />      struct sr_timer_process pointer in case of success, or NULL in case of error.<br />*/<br />void* register_timer_process(char *label, timer_function f, void* param, <br />      unsigned int interval, unsigned int flags);</div></div>
        <div class='difftype'>Changed lines 954-959 from:</div>
        <div class='diffdel'><div class='diffmarkup'>In our examples, '''uri''' and '''s''' are the so called '''classes of transformations''', while '''user''' and '''len''' are the actual operations within the class.<br />\\<br />We will further follow the implementation of the uri class of transformation, and then focusing on the user function.\\<br />Adding new classes of transformations is done in '''transformations.h''' , where , for our example's case, '''TR_URI''' was added. Then, each class of transformations should have it's own functions enumeration, which is our case is enum '''_tr_uri_subtype''' . \\<br />'''transformations.c''' holds the actual implementation of transformations. '''parse_transformation''' will get called when the script needs to evaluate a transformation. There, we should add the matching for our new class of transformations :<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The output struct sr_timer_process pointer can be further use to group together multiple functions inside the same process, by calling :</div></div>
        <div class='difftype'>Changed lines 956-964 from:</div>
        <div class='diffdel'><div class='diffmarkup'>else if(tclass.len==3 &amp;&amp; strncasecmp(tclass.s, &quot;uri&quot;, 3)==0) { <br />      t-&gt;type = TR_URI; <br />      t-&gt;trf = tr_eval_uri; <br />      s.s = p; s.len = in-&gt;s + in-&gt;len - p; <br />      p0 = tr_parse_uri(&amp;s, t); <br />      if(p0==NULL) <br />            goto error; <br />      p = p0; <br />}</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Parameters:<br />      label – opaque string containing a short timer function description ( to be used for logging )<br />      f – the actual function to be called<br />      param – parameter to be provided to the timer function<br />      interval – the interval, in seconds, that the function needs to be called at<br />      timer – the  struct sr_timer_process pointer obtained by previously calling  register_timer_process<br />Returns:<br />      0 in case of success, negative code in case of internal error.<br />*/<br />int append_timer_to_process( char *label, timer_function f, void* param, <br />      unsigned int interval, void *timer);</div></div>
        <div class='difftype'>Changed lines 970-971 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Here, there are two main functions of interest. First, there is the '''tr_parse_uri''' function responsible for matching the actual function that needs to get executed inside our class of transformation, doing whatever parsing that is necessary for the transformation and advancing the position of the current pointer in the transformation string. This is a fixup type function and is only evaluated once :<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;important&lt;&lt;<br />Important to note here that all the above timer related functions MUST be called for the context of the attendant process before forking is done ( so either from the modules mod_init or directly from the core, before forking ).<br />&gt;&gt;&lt;&lt;<br /><br />Below is a code snippet exemplifying how the dialog module's code used for registering two timers, with an option to either use the global timer process or to have it's own separate timer :</div></div>
        <div class='difftype'>Changed lines 977-992 from:</div>
        <div class='diffdel'><div class='diffmarkup'>p = in-&gt;s;<br />name.s = in-&gt;s;<br /><br />/* find next token */<br />while(*p &amp;&amp; *p!=TR_PARAM_MARKER &amp;&amp; *p!=TR_RBRACKET) p++;<br />if(*p=='\0') {<br />      LM_ERR(&quot;invalid transformation: %.*s\n&quot;, in-&gt;len, in-&gt;s);<br />      goto error;<br />}<br />name.len = p - name.s;<br />trim(&amp;name);<br /><br />if(name.len==4 &amp;&amp; strncasecmp(name.s, &quot;user&quot;, 4)==0) {<br />      t-&gt;subtype = TR_URI_USER;<br />      return p;<br />}</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>if (dlg_have_own_timer_proc) { <br />      LM_INFO(&quot;Running with dedicated dialog timer process\n&quot;); <br />      dlg_own_timer_proc = register_timer_process( &quot;dlg-timer&quot;, <br />            dlg_timer_routine, NULL,1,TIMER_PROC_INIT_FLAG ); <br />      if (dlg_own_timer_proc == NULL) { <br />            LM_ERR(&quot;Failed to init dialog own timer proc\n&quot;); <br />            return -1; <br />      } <br />      if (append_timer_to_process(&quot;dlg-pinger&quot;, dlg_ping_routine, NULL, <br />            ping_interval,dlg_own_timer_proc) &lt; 0) { <br />            LM_ERR(&quot;Failed to append ping timer \n&quot;); <br />            return -1; <br />      }<br />} else { <br />      if ( register_timer( &quot;dlg-timer&quot;, dlg_timer_routine, NULL, 1)&lt;0 ) { <br />            LM_ERR(&quot;failed to register timer \n&quot;); <br />            return -1; <br />      } <br /><br />      if ( register_timer( &quot;dlg-pinger&quot;, dlg_ping_routine, NULL, <br />            ping_interval)&lt;0) { <br />            LM_ERR(&quot;failed to register timer 2 \n&quot;); <br />            return -1; <br />      } <br />} </div></div>
        <div class='difftype'>Changed lines 1004-1005 from:</div>
        <div class='diffdel'><div class='diffmarkup'>After we've decided what actually needs to be done and did all the parsing,the  '''tr_eval_uri''' will be the one gets called at runtime and that actually evaluates our transformation and returns the new transformation output. \\<br />In our case, the function parses the provided string into a SIP URI, and then populates the output pv_value_t accordingly to the subtype provided :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Also, the OpenSIPS API also exposes the number of seconds and microseconds passed from the OpenSIPS start time. These can be accessed by calling </div></div>
        <div class='difftype'>Changed lines 1006-1029 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/* make a PKG copy of the input */<br />_tr_uri.s = (char*)pkg_malloc((val-&gt;rs.len+1)*sizeof(char));<br />memcpy(_tr_uri.s, val-&gt;rs.s, val-&gt;rs.len);<br />_tr_uri.s[_tr_uri.len] = '\0';<br />...<br />...<br />/* parse the input URI */<br />if(parse_uri(_tr_uri.s, _tr_uri.len, &amp;_tr_parsed_uri)!=0) {<br />      LM_ERR(&quot;invalid uri [%.*s]\n&quot;, val-&gt;rs.len,val-&gt;rs.s);<br />      return -1;<br />}<br />...<br />...<br />/* zero out the output val */<br />memset(val, 0, sizeof(pv_value_t));<br />/* the output pvar will be a string */<br />val-&gt;flags = PV_VAL_STR;<br /><br />switch(subtype) {<br />      case TR_URI_USER:<br />            val-&gt;rs = (_tr_parsed_uri.user.s)?_tr_parsed_uri.user:_tr_empty;<br />            break;<br />}<br />(:sourceend:)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/*<br />Returns :<br />      the number of seconds elapsed from OpenSIPS start<br />*/<br />unsigned int get_ticks(void);<br /><br />/*<br />Returns:<br />      the number of microseconds elapsed from OpenSIPS start<br />*/<br />utime_t get_uticks(void);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397918773-1397913617-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397918773:1397913617:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 03:20 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 230:</div>
        <div class='diffadd'><div class='diffmarkup'>*/</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397913617-1397908370-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397913617:1397908370:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:52 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 967-1015:</div>
        <div class='diffadd'><div class='diffmarkup'>}<br />(:sourceend:)<br />\\<br />Here, there are two main functions of interest. First, there is the '''tr_parse_uri''' function responsible for matching the actual function that needs to get executed inside our class of transformation, doing whatever parsing that is necessary for the transformation and advancing the position of the current pointer in the transformation string. This is a fixup type function and is only evaluated once :<br /><br />(:source lang=C -link -getcode :)<br />p = in-&gt;s;<br />name.s = in-&gt;s;<br /><br />/* find next token */<br />while(*p &amp;&amp; *p!=TR_PARAM_MARKER &amp;&amp; *p!=TR_RBRACKET) p++;<br />if(*p=='\0') {<br />      LM_ERR(&quot;invalid transformation: %.*s\n&quot;, in-&gt;len, in-&gt;s);<br />      goto error;<br />}<br />name.len = p - name.s;<br />trim(&amp;name);<br /><br />if(name.len==4 &amp;&amp; strncasecmp(name.s, &quot;user&quot;, 4)==0) {<br />      t-&gt;subtype = TR_URI_USER;<br />      return p;<br />}<br />(:sourceend:)<br />\\<br />After we've decided what actually needs to be done and did all the parsing,the  '''tr_eval_uri''' will be the one gets called at runtime and that actually evaluates our transformation and returns the new transformation output. \\<br />In our case, the function parses the provided string into a SIP URI, and then populates the output pv_value_t accordingly to the subtype provided :<br />(:source lang=C -link -getcode :)<br />/* make a PKG copy of the input */<br />_tr_uri.s = (char*)pkg_malloc((val-&gt;rs.len+1)*sizeof(char));<br />memcpy(_tr_uri.s, val-&gt;rs.s, val-&gt;rs.len);<br />_tr_uri.s[_tr_uri.len] = '\0';<br />...<br />...<br />/* parse the input URI */<br />if(parse_uri(_tr_uri.s, _tr_uri.len, &amp;_tr_parsed_uri)!=0) {<br />      LM_ERR(&quot;invalid uri [%.*s]\n&quot;, val-&gt;rs.len,val-&gt;rs.s);<br />      return -1;<br />}<br />...<br />...<br />/* zero out the output val */<br />memset(val, 0, sizeof(pv_value_t));<br />/* the output pvar will be a string */<br />val-&gt;flags = PV_VAL_STR;<br /><br />switch(subtype) {<br />      case TR_URI_USER:<br />            val-&gt;rs = (_tr_parsed_uri.user.s)?_tr_parsed_uri.user:_tr_empty;<br />            break;</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397908370:1397907901:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397908370:1397907901:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397908370:1397907901:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:45 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 941:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 945:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397907901-1397907878-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397907901:1397907878:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:44 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 940 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 944 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397907878-1397907857-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397907878:1397907857:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:44 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 939-965:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />&gt;&gt;tip&lt;&lt;<br />Note that transformations can be chained together, which will have an impact on the transformations C development<br />&gt;&gt;&lt;&lt;<br /><br />(:source lang=C -link -getcode :)<br />$var(our_uri) = “sip:vlad@opensips.org”;<br />xlog(“The username of our URI has $(var(our_uri){uri.user}{s.len}) characters \n”);<br />(:sourceend:)<br />\\<br />In our examples, '''uri''' and '''s''' are the so called '''classes of transformations''', while '''user''' and '''len''' are the actual operations within the class.<br />\\<br />We will further follow the implementation of the uri class of transformation, and then focusing on the user function.\\<br />Adding new classes of transformations is done in '''transformations.h''' , where , for our example's case, '''TR_URI''' was added. Then, each class of transformations should have it's own functions enumeration, which is our case is enum '''_tr_uri_subtype''' . \\<br />'''transformations.c''' holds the actual implementation of transformations. '''parse_transformation''' will get called when the script needs to evaluate a transformation. There, we should add the matching for our new class of transformations :<br /><br />(:source lang=C -link -getcode :)<br />else if(tclass.len==3 &amp;&amp; strncasecmp(tclass.s, &quot;uri&quot;, 3)==0) { <br />      t-&gt;type = TR_URI; <br />      t-&gt;trf = tr_eval_uri; <br />      s.s = p; s.len = in-&gt;s + in-&gt;len - p; <br />      p0 = tr_parse_uri(&amp;s, t); <br />      if(p0==NULL) <br />            goto error; <br />      p = p0; <br />}</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397907857-1397907609-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397907857:1397907609:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:40 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 927-938:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />!!!! Adding Transformations<br /><br />The so called transformations are methods operating directly on the OpenSIPS various pseudo-variables. A transformation takes as input the value of the provided pseudo-variable and processes it, outputing a 'transformed' version. <br />\\<br />Transformation examples are the URI transformations ( working on a SIP URI, and they allow extracting various useful information from the URI, like the user , domain, various parameters, etc ), the S class of transformations ( work on generic strings, and provide various useful methods as fetching the length of the string, searching the first occurrence of a character inside the string, etc ), and many others – see http://www.opensips.org/Documentation/Script-Tran-1-10<br />\\<br />(:source lang=C -link -getcode :)<br /># example of usage<br />$var(tutorial)  = “OpenSIPSDevel”;<br />xlog(“Our variable has $(var(tutorial){s.len}) characters \n”);</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397907609-1397906988-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397907609:1397906988:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:29 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 871 from:</div>
        <div class='diffdel'><div class='diffmarkup'>From the grammar, we will start building the actions. In '''route.c''' we will define the fixup part of the function, where all the sanity checks and parameter parsing should be done :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>From the grammar, we will start building the actions. In '''route.c''' we will define the fixup part of the function, where all the sanity checks and parameter parsing should be done. The fixup part will be invoked only once, at script parsing.</div></div>
        <div class='difftype'>Added lines 897-927:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />In '''action.c''' we will have to add the actual code that needs to get executed when the function gets called from the OpenSIPS script at runtime :<br />(:source lang=C -link -getcode :)<br />case XLOG_T:<br />      /* add helpers for tracing the script */<br />      script_trace(&quot;core&quot;, &quot;xlog&quot;, msg, a-&gt;line) ;<br />      if (a-&gt;elem[1].u.data != NULL) {<br />            /* we have two parameters */ <br /><br />            /* do security checks for the types of the provided parameters, second param has to be a SCRIPTVAR model as we've coded in the fixup */<br />            if (a-&gt;elem[1].type != SCRIPTVAR_ELEM_ST) { <br />                  LM_ALERT(&quot;BUG in xlog() type %d\n&quot;, a-&gt;elem[1].type); <br />                  ret=E_BUG; <br />                  break; <br />            }<br />            /* log level should be a plaintext string */ <br />            if (a-&gt;elem[0].type != STR_ST) { <br />                  LM_ALERT(&quot;BUG in xlog() type %d\n&quot;, a-&gt;elem[0].type); <br />                  ret=E_BUG; <br />                  break; <br />            }<br />          <br />            /* call our C code function implementing the desired actions */<br />            if (xlog_2(msg,a-&gt;elem[0].u.data, a-&gt;elem[1].u.data) &lt; 0) { <br />                  LM_ALERT(&quot;Cannot print xlog debug message&quot;); <br />                  break;<br />            }<br />      } else {<br />            /* one parameter case */<br />      }<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397906988-1397906609-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397906988:1397906609:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:23 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 884 from:</div>
        <div class='diffdel'><div class='diffmarkup'>            /* parse the format provided to xlog - we can have variables inside</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>            /* parse the format provided to xlog - we can have variables inside */</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397906609-1397906584-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397906609:1397906584:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:23 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 871-896 from:</div>
        <div class='diffdel'><div class='diffmarkup'>From the grammar, we will start building the actions. In '''route.c''' we will define the fixup part of the function, where all the sanity checks and parameter parsing should be done :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>From the grammar, we will start building the actions. In '''route.c''' we will define the fixup part of the function, where all the sanity checks and parameter parsing should be done :<br />(:source lang=C -link -getcode :)<br />case XLOG_T: <br />      s.s = (char*)t-&gt;elem[1].u.data; <br />      if (s.s == NULL) { <br />            /* commands have only one parameter */ <br />            s.s = (char *)t-&gt;elem[0].u.data; <br />            s.len = strlen(s.s); <br />            if(s.len==0) { <br />                  LM_ERR(&quot;param is empty string!\n&quot;); <br />                  return E_CFG; <br />            } <br /><br />            /* parse the format provided to xlog - we can have variables inside<br />            if(pv_parse_format(&amp;s ,&amp;model) || model==NULL) { <br />                  LM_ERR(&quot;wrong format [%s] for value param!\n&quot;, s.s); <br />                  ret=E_BUG; <br />                  goto error; <br />            } <br /><br />            /* overwrite the data that will be passed to contain our new parsed model */<br />            t-&gt;elem[0].u.data = (void*)model; <br />            t-&gt;elem[0].type = SCRIPTVAR_ELEM_ST; <br />      } else {<br />            /* two parameters */<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397906584-1397906231-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397906584:1397906231:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:17 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 850-871 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Adding a core function</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Adding a core function<br /><br />In the following step by step tutorial, we will follow the implementation of the '''xlog''' core parameter, which is used to print debugging information to the logging facility.<br /><br />&gt;&gt;tip&lt;&lt;<br />Note that xlog can receive either a single parameter ( the string to be printed ), or two parameters ( the log level and then the string to be printed ).<br />&gt;&gt;&lt;&lt;<br /><br />First, the grammar will have to be extended. In '''cfg,y''' we have :<br />(:source lang=C -link -getcode :)<br />%token XLOG<br />...<br />...<br />| XLOG LPAREN STRING RPAREN {                                                     <br />      mk_action1($$, XLOG_T, STR_ST, $3); }                             <br /> XLOG LPAREN STRING COMMA STRING RPAREN {                                        <br />      mk_action2($$, XLOG_T, STR_ST, STR_ST, $3, $5); } <br />(:sourceend:)<br />\\<br />Note the two different forms of xlog displayed above.<br />\\<br />From the grammar, we will start building the actions. In '''route.c''' we will define the fixup part of the function, where all the sanity checks and parameter parsing should be done :</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397906231-1397905970-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397906231:1397905970:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:12 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905970:1397905965:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905970:1397905965:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905970:1397905965:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:12 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 829-830 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\Adding the variable here will make it visible in both the OpenSIPS core and the OpenSIPS modules. '''main.c''' will hold the actual variable :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />Adding the variable here will make it visible in both the OpenSIPS core and the OpenSIPS modules. '''main.c''' will hold the actual variable :</div></div>
        <div class='difftype'>Added lines 835-849:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />Next, we will have to modify the grammar in order to accept our new parameter.<br />In '''cfg.y''' , first we will define our new token :<br />(:source lang=C -link -getcode :)<br />%token CHILDREN<br />(:sourceend:)<br />\\<br />And then we'll set the parsing rules for the new token<br />(:source lang=C -link -getcode :)<br />| CHILDREN EQUAL NUMBER { children_no=$3; } <br />| CHILDREN EQUAL error { yyerror(&quot;number expected&quot;); }<br />(:sourceend:)<br />\\<br />Our variable will have a numeric variable, anything else will trigger and error in parsing the OpenSIPS script.<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397905965-1397905826-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905965:1397905826:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:10 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 823-833:</div>
        <div class='diffadd'><div class='diffmarkup'>In the following step by step tutorial, we will follow the implementation of the '''children''' core parameter, which is an integer controlling the number of OpenSIPS processes per UDP interface. \\<br />First of all, we will have to add the variable that will hold the value of our new core parameter. \\<br />In our case, in '''globals.h''' we have added <br />(:source lang=C -link -getcode :)<br />extern int children_no;<br />(:sourceend:)<br />\\Adding the variable here will make it visible in both the OpenSIPS core and the OpenSIPS modules. '''main.c''' will hold the actual variable :<br />(:source lang=C -link -getcode :)<br />/* Default value in case the parameter is not set from the script */<br />int children_no = 8;<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397905826-1397905632-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905826:1397905632:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:07 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 814-823 from:</div>
        <div class='diffdel'><div class='diffmarkup'>(:sourceend:)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />!!!! Extending OpenSIPS core Config File<br /><br />OpenSIPS uses flex and bison in order to parse the configuration file and then build the entire action tree that a SIP message will go through once it is read from network level. \\<br />When it comes to extending the OpenSIPS configuration file directly in the core, the developer can either choose to add a new core parameter, or a new core function. <br /><br />!!!!! Adding a core parameter<br /><br />!!!!! Adding a core function</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397905632-1397905300-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905632:1397905300:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:01 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 767-771 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Important to note here that all the above timer related functions MUST be called for the context of the attendant process before forking is done ( so either from the modules mod_init or directly from the core, before forking ). \\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;important&lt;&lt;<br />Important to note here that all the above timer related functions MUST be called for the context of the attendant process before forking is done ( so either from the modules mod_init or directly from the core, before forking ).<br />&gt;&gt;&lt;&lt;<br /></div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905300:1397905263:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905300:1397905263:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905300:1397905263:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:01 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 204-205:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;tip&lt;&lt;</div></div>
        <div class='difftype'>Added lines 207-208:</div>
        <div class='diffadd'><div class='diffmarkup'>&gt;&gt;&lt;&lt;<br /></div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905263:1397905215:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905263:1397905215:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905263:1397905215:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 01:00 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 144-148 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Important to note that the parse_headers() function will not duplicate SIP headers at all – the hooks in the struct sip_msg structure will be populated with pointers that point directly in the SIP message buffer.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />&gt;&gt;tip&lt;&lt;<br />The parse_headers() function will not duplicate SIP headers at all – the hooks in the struct sip_msg structure will be populated with pointers that point directly in the SIP message buffer.<br />&gt;&gt;&lt;&lt;<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397905215-1397905162-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905215:1397905162:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 12:59 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 35:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 39:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397905162-1397905130-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905162:1397905130:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 12:58 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 35-37 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Also, note the common use case where , before forking OpenSIPS processes, the developer stores some static variables in private memory of the main process. After forking, all the child processes will inherit that private memory chunk and each will have it's individual copy of it.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>&gt;&gt;tip&lt;&lt;<br />Note the common use case where , before forking OpenSIPS processes, the developer stores some static variables in private memory of the main process. After forking, all the child processes will inherit that private memory chunk and each will have it's individual copy of it.<br />&gt;&gt;&lt;&lt;</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397905130-1397904859-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397905130:1397904859:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 12:54 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 680-682 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!!! Global Timer Process<br /></div></div>
        <div class='difftype'>Changed lines 718-720 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!!! Dedicated Timer Process<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397904859-1397904754-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397904859:1397904754:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 12:52 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 780-794:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />Also, the OpenSIPS API also exposes the number of seconds and microseconds passed from the OpenSIPS start time. These can be accessed by calling <br />(:source lang=C -link -getcode :)<br />/*<br />Returns :<br />      the number of seconds elapsed from OpenSIPS start<br />*/<br />unsigned int get_ticks(void);<br /><br />/*<br />Returns:<br />      the number of microseconds elapsed from OpenSIPS start<br />*/<br />utime_t get_uticks(void);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397904754-1397904587-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397904754:1397904587:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 12:49 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 732-733 from:</div>
        <div class='diffdel'><div class='diffmarkup'>                         unsigned int interval, unsigned int flags);<br />(:sourceend:)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      unsigned int interval, unsigned int flags);<br />(:sourceend:)<br />\\<br />The output struct sr_timer_process pointer can be further use to group together multiple functions inside the same process, by calling :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters:<br />      label – opaque string containing a short timer function description ( to be used for logging )<br />      f – the actual function to be called<br />      param – parameter to be provided to the timer function<br />      interval – the interval, in seconds, that the function needs to be called at<br />      timer – the  struct sr_timer_process pointer obtained by previously calling  register_timer_process<br />Returns:<br />      0 in case of success, negative code in case of internal error.<br />*/<br />int append_timer_to_process( char *label, timer_function f, void* param, <br />      unsigned int interval, void *timer);<br />(:sourceend:)<br />\\<br />Important to note here that all the above timer related functions MUST be called for the context of the attendant process before forking is done ( so either from the modules mod_init or directly from the core, before forking ). \\<br />Below is a code snippet exemplifying how the dialog module's code used for registering two timers, with an option to either use the global timer process or to have it's own separate timer :<br />(:source lang=C -link -getcode :)<br />if (dlg_have_own_timer_proc) { <br />      LM_INFO(&quot;Running with dedicated dialog timer process\n&quot;); <br />      dlg_own_timer_proc = register_timer_process( &quot;dlg-timer&quot;, <br />            dlg_timer_routine, NULL,1,TIMER_PROC_INIT_FLAG ); <br />      if (dlg_own_timer_proc == NULL) { <br />            LM_ERR(&quot;Failed to init dialog own timer proc\n&quot;); <br />            return -1; <br />      } <br />      if (append_timer_to_process(&quot;dlg-pinger&quot;, dlg_ping_routine, NULL, <br />            ping_interval,dlg_own_timer_proc) &lt; 0) { <br />            LM_ERR(&quot;Failed to append ping timer \n&quot;); <br />            return -1; <br />      }<br />} else { <br />      if ( register_timer( &quot;dlg-timer&quot;, dlg_timer_routine, NULL, 1)&lt;0 ) { <br />            LM_ERR(&quot;failed to register timer \n&quot;); <br />            return -1; <br />      } <br /><br />      if ( register_timer( &quot;dlg-pinger&quot;, dlg_ping_routine, NULL, <br />            ping_interval)&lt;0) { <br />            LM_ERR(&quot;failed to register timer 2 \n&quot;); <br />            return -1; <br />      } <br />} <br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397904587:1397897789:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397904587:1397897789:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397904587:1397897789:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 10:56 AM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 716-733 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br />Since, by default, all the registered timer functions are called from within the same process context, in case you are writing a timer process that is doing I/O, it is better to register an entirely new process where to run your code, since your function might slow down all the other timer functions running in OpenSIPS.\\<br />Registering a new timer process can be done by calling :<br /><br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      label - opaque string containing a short timer function description ( to be used for logging )<br />      f - the actual function to be called<br />      param - parameter to be provided to the timer function<br />      interval - the interval, in seconds, that the function needs to be called at<br />      flags - flags controlling process behavior. Currently only option is TIMER_PROC_INIT_FLAG , which leads to child_init to be called in the new timer process context. To be used when inside the timer you need to operate various I/O options which generally require a per process connection.<br />Returns :<br />      struct sr_timer_process pointer in case of success, or NULL in case of error.<br />*/<br />void* register_timer_process(char *label, timer_function f, void* param, <br />                         unsigned int interval, unsigned int flags);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397897789-1397897626-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397897789:1397897626:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 10:53 AM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 683:</div>
        <div class='diffadd'><div class='diffmarkup'>/*</div></div>
        <div class='difftype'>Changed line 691 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>*/</div></div>
        <div class='difftype'>Changed line 700 from:</div>
        <div class='diffdel'><div class='diffmarkup'>	typedef void (timer_function)(unsigned int ticks, void* param); </div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>typedef void (timer_function)(unsigned int ticks, void* param); </div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397897626-1397897573-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397897626:1397897573:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 19, 2014, at 10:52 AM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 673-715 from:</div>
        <div class='diffdel'><div class='diffmarkup'>(:sourceend:)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />!!!! Timer API<br /><br />OpenSIPS exposes it's own API for implementing timer functions, with seconds and microsecond precision.\\<br />The OpenSIPS timer architecture is made out of the so called 'timer keeper' , which is a process which just increments global counter of second and microsecond precision, and one process which will execute the various timer functions when their time to execute has arrived.\\<br />Also, the OpenSIPS timers support automatic re-calibration in order to compensate timer drifting in case the timer executed functions do not complete in timely manners.<br />\\<br />'''timer.h''' exposes all the relevant functionalities for operating the OpenSIPS timers. For registering a new timer function with second precision, use :<br />(:source lang=C -link -getcode :)<br />Parameters :<br />	label – opaque string containing a short timer function description ( to be used for logging )<br />	f – the actual function to be called<br />	param – parameter to be provided to the timer function<br />	interval – the interval, in seconds, that the function needs to be called at<br />Returns :<br />	0 in case of success, negative code in case of internal error.<br /><br />int register_timer(char *label, timer_function f, void* param, <br />      unsigned int interval);<br />/*<br />The seconds callback <br />Parameters :<br />      ticks - represents the current number of seconds since OpenSIPS startup when the callback is called at<br />      param - is the parameter provided at timer function registration.<br />*/<br />	typedef void (timer_function)(unsigned int ticks, void* param); <br />(:sourceend:)<br />\\<br />For registering a microsecond timer, you should use <br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />	label – opaque string containing a short timer function description ( to be used for logging )<br />	f – the actual function to be called<br />	param – parameter to be provided to the timer function<br />	interval – the interval, in microseconds, that the function needs to be called at<br />Returns :<br />	0 in case of success, negative code in case of internal error.<br />*/<br />int register_utimer(char *label, utimer_function f, void* param, unsigned int interval);<br />(:sourceend:)<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397897573-1397856865-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397897573:1397856865:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 11:34 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 2:</div>
        <div class='diffadd'><div class='diffmarkup'>This page has been visited {$PageCount} times.</div></div>
        <div class='difftype'>Deleted line 3:</div>
        <div class='diffdel'><div class='diffmarkup'>This page has been visited {$PageCount} times.</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397856865:1397856836:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397856865:1397856836:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397856865:1397856836:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 11:33 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 3:</div>
        <div class='diffadd'><div class='diffmarkup'>This page has been visited {$PageCount} times.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397856836-1397856066-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397856836:1397856066:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 11:21 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 611 from:</div>
        <div class='diffdel'><div class='diffmarkup'>void lock_destroy(gen_lock_set_t *lock);</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>void lock_set_destroy(gen_lock_set_t *lock);</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397856066-1397855980-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397856066:1397855980:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 11:19 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 557-672 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Lock Set API</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Lock Set API<br /><br />Operating on an entire array of locks can become very useful when dealing with structures like hashes, where you would need a lock per each hash entry.\\<br />The API can be used by including '''locking.h''' . The OpenSIPS generic array of locks is defined by the gen_lock_set_t structure, and working with it is very similar in concept to operating a single lock entry.<br />\\<br />Allocating a new lock set is done by calling lock_set_alloc :<br />(:source lang=C -link -getcode :)<br />/* <br />Returns : <br />      A shared memory allocated lock set, or NULL in case of an error.<br />*/<br />gen_lock_set_t *lock_set_alloc(void);<br />(:sourceend:)<br />\\<br />Since  the locks usually have to be reachable by all processes fighting on some resource, the locks are allocated by default in shared memory. Also, note that it is not necessary to always allocate the lock set separately - if the lock set is embedded within a structure which is allocated in SHM, the effect is the same. \\<br />Before any operation on the lock set, it must be initialized :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock set instance to be initialized<br />Returns :<br />      The initialized lock in case of success, or NULL in case of error.<br />*/<br />gen_lock_set_t* lock_set_init(gen_lock_set_t* lock);<br />(:sourceend:)<br />\\<br />In order to acquire a lock in a lock set, one must use the lock_set_get function :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be acquired<br />      entry - the entry in the lock set that needs to be acquired<br />*/<br />void lock_set_get(gen_lock_set_t *lock,int entry);<br />(:sourceend:)<br />\\<br />The function will block if the lock is acquired by another process, and will only return once the lock has been acquired by the current process.<br />\\<br />For releasing a lock, lock_set_release should be used :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be released.<br />      entry - the entry in the lock set that needs to be released<br />*/<br />void lock_set_release(gen_lock_set_t *lock,int entry);<br />(:sourceend:)<br />\\<br />Once a lock set is no longer needed, one must first destroy the lock set, and then the lock set can be safely deallocated.<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock set to be destroyed<br />*/<br />void lock_destroy(gen_lock_set_t *lock);<br />/*<br />Parameters :<br />      lock - the lock set to be deallocated<br />*/<br />void lock_set_dealloc(gen_lock_set_t *lock);<br />(:sourceend:)<br />\\<br />Here is a code snippet showing the typical code used when dealing with single lock instances :<br />(:source lang=C -link -getcode :)<br />gen_lock_set_t *my_lock;<br /><br />int init_function(void) <br />{<br />	/* … */<br /><br />        /* allocate lock set with 32 entries */<br />	my_lock = lock_set_alloc(32);<br />	if (my_lock == NULL) {<br />		LM_ERR(“Failed to allocate lock set \n”);<br />		return -1;<br />	}<br /><br />	if (lock_set_init(my_lock) == NULL) {<br />		LM_ERR(“Failed to init lock set \n”);<br />		return -1;<br />	}<br /><br />	/* … */<br />	return 0;<br />}<br /><br />int do_work(void) <br />{<br /><br />	/* … */<br />	<br />	/* acquire entry 5 in the lock set */<br />	lock_set_get(my_lock,5)<br /><br />	/* also acquire entry 21 in the lock set */<br />	lock_set_get(my_lock,21);<br /><br />	/* critical region protected by our lock<br />	generally recommended to keep critical regions short<br />	I/O operations to be avoided in such critical regions */<br /><br />	lock_set_release(my_lock,21);<br />	lock_set_release(my_lock,5);<br />	/* … */<br />}<br /><br />void destroy_function(void) <br />{<br />	/* … */<br /><br />	lock_set_destroy(my_lock);<br />	lock_set_dealloc(my_lock);<br /><br />	/* … */<br />}<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397855980-1397855626-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397855980:1397855626:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 11:13 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed line 557 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!! Lock Set API</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Lock Set API</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397855626-1397855613-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397855626:1397855613:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 11:13 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 442-557 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!! Locking API</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Locking API<br /><br />OpenSIPS has it's own locking API, and it is recommended to use it instead of the system exposed locks, since they offer greater flexibility - depending on the usage case and the menuconfig provided compilation flags, the OpenSIPS generic locks can be converted either to busy locks, futexes, SysV locks, etc. <br />\\<br />The Locking API offers two distinct functionalities, one for using single lock elements, and another for operating on entire sets of locks.<br /><br />!!!!! Single Lock API<br /><br />The API can be used by including “locking.h” . The OpenSIPS generic lock is defined by the gen_lock_t structure. \\<br />Allocating a new lock is done by calling lock_alloc :<br />(:source lang=C -link -getcode :)<br />/* <br />Returns : <br />      A shared memory allocated lock, or NULL in case of an error.<br />*/<br />gen_lock_t *lock_alloc(void);<br />(:sourceend:)<br />\\<br />Since  the locks usually have to be reachable by all processes fighting on some resource, the locks are allocated by default in shared memory. Also, note that it is not necessary to always allocate the lock separately - if the lock is embedded within a structure which is allocated in SHM, the effect is the same. \\<br />Before any operation on the lock, it must be initialized :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock instance to be initialized<br />Returns :<br />      The initialized lock in case of success, or NULL in case of error.<br />*/<br />gen_lock_t* lock_init(gen_lock_t* lock);<br />(:sourceend:)<br />\\<br />In order to acquire a lock, one must use the lock_get function :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be acquired<br />*/<br />void lock_get(gen_lock_t *lock);<br />(:sourceend:)<br />\\<br />The function will block if the lock is acquired by another process, and will only return once the lock has been acquired by the current process.<br />\\<br />For releasing a lock, lock_release should be used :<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be released.<br />*/<br />void lock_release(gen_lock_t *lock);<br />(:sourceend:)<br />\\<br />Once a lock is no longer needed, one must first destroy the lock, and then the lock can be safely deallocated.<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      lock - the lock to be destroyed<br />*/<br />void lock_destroy(gen_lock_t *lock);<br />/*<br />Parameters :<br />      lock - the lock to be deallocated<br />*/<br />void lock_dealloc(gen_lock_t *lock);<br />(:sourceend:)<br />\\<br />Here is a code snippet showing the typical code used when dealing with single lock instances :<br />(:source lang=C -link -getcode :)<br /><br />gen_lock_t *my_lock;<br /><br />int init_function(void) <br />{<br />	/* … */<br /><br />	my_lock = lock_alloc();<br />	if (my_lock == NULL) {<br />		LM_ERR(“Failed to allocate lock \n”);<br />		return -1;<br />	}<br /><br />	if (lock_init(my_lock) == NULL) {<br />		LM_ERR(“Failed to init lock \n”);<br />		return -1;<br />	}<br /><br />	/* … */<br />	return 0;<br />}<br /><br /><br />int do_work(void) <br />{<br /><br />	/* … */<br />	lock_get(my_lock)<br /><br /><br />	/* critical region protected by our lock<br />	generally recommended to keep critical regions short<br />	I/O operations to be avoided in such critical regions */<br /><br />	lock_release(my_lock)<br />	/* … */<br />}<br /><br />void destroy_function(void) {<br /><br />	/* … */<br /><br />	lock_destroy(my_lock);<br />	lock_dealloc(my_lock);<br /><br />	/* … */<br />}<br />(:sourceend:)<br /><br />!!!! Lock Set API</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397855613:1397855065:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397855613:1397855065:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397855613:1397855065:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 11:04 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 440-442 from:</div>
        <div class='diffdel'><div class='diffmarkup'>(:sourceend:)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />!!!! Locking API</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397855065-1397851631-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397855065:1397851631:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 10:07 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added line 343:</div>
        <div class='diffadd'><div class='diffmarkup'>*/</div></div>
        <div class='difftype'>Added lines 426-427:</div>
        <div class='diffadd'><div class='diffmarkup'>*/<br />struct lump_rpl* add_lump_rpl(struct sip_msg *msg, char *s, int len, int flags);</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397851631:1397851570:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397851631:1397851570:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397851631:1397851570:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 10:06 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Changed lines 411-437 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! SIP Reply Lumps</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! SIP Reply Lumps<br /><br />When used in the case of a SIP request, these lumps will operate on the SIP reply that will be internally generated when rejecting a request from within OpenSIPS ( if the Request if forwarded instead of rejected at OpenSIPS level, these lumps will have no effect ). Since the reply will be internally generated by OpenSIPS,  the Reply Lumps can only add new content.<br />\\<br />'''data_lump_rpl.h'''  exposes<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      msg - the SIP Request that the reply will be generated for<br />      s - the string to be added to the reply<br />      len - the length of the string to be added<br />      flags - Since the reply will be generated by OpenSIPS, it is important to mark your lump if it should be added to the Reply headers or to the Reply body. Relevant flags for these cases are LUMP_RPL_HDR and LUMP_RPL_BODY.<br />Returns :<br />      the created lump structure for adding to the SIP reply. Can be further used to chain together lumps in the message attached list of lumps. NULL is returned in case of internal error.<br />(:sourceend:)<br />\\<br />Example of Adding contact header to the internally generated reply :<br />(:source lang=C -link -getcode :)<br />      static char ct[CT_LEN] = “Contact: opensips@my_domain.com\r\n”;<br /><br />      /* we are adding a lump to the headers, so we pass the  LUMP_RPL_HDR flag<br />      also , our buffer is located in a static buffer, thus no need for the core to allocate memory for this lump, we also pass the LUMP_RPL_NODUP flag */<br />      if (add_lump_rpl(msg, ct, CT_LEN, LUMP_RPL_HDR |  LUMP_RPL_NODUP)==0) { <br />            LM_ERR(&quot;unable to add lump\n&quot;); <br />            return -1; <br />      } <br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397851570-1397851303-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397851570:1397851303:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 10:01 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 379-409:</div>
        <div class='diffadd'><div class='diffmarkup'>If we want to replace a particular part of a SIP message, the operation can be split in two steps, first deleting the part we don't need anymore by calling del_lump, and then using the returned lump to add a new lump after it.<br />\\<br />Example of replacing the content of the RPID header :<br />(:source lang=C -link -getcode :)<br />      /* first parse the header to figure out where it actually starts in the SIP message */<br />      if( parse_headers(msg,HDR_RPID_F,0)&lt;0 || msg-&gt;rpid == NULL ){ <br />            LM_DBG(“No rpid header – nothing to delete \n”);<br />	    return 0;<br />      }<br /><br />      /* delete just the contents of the RPID header */<br />      del =  del_lump(msg, msg-&gt;rpid-&gt;body.s-msg-&gt;buf, msg-&gt;rpid-&gt;body.len,HDR_RPID_T);<br />      if ( del == NULL) {<br />            LM_ERR(“Failed to delete RPID header \n”);<br />	    return -1;<br />      }<br /><br />      len =  sizeof(“sip:new_rpid@my_domain.com\r\n”) -1;<br />      new_rpid=pkg_malloc(len);<br />      if (!new_rpid) {<br />            LM_ERR(“No more pkg mem\n”);<br />	    return -1;<br />      }<br />      memcpy(new_rpid,“sip:new_rpid@my_domain.com\r\n”,len);<br /><br />      if(insert_new_lump_after(del,new_rpid,len,HDR_RPID_T)==NULL) { <br />            LM_ERR(&quot;Failed to insert new callid\n&quot;); <br />            pkg_free(new_rpid); <br />            return -1; <br />      } <br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397851303-1397851075-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397851303:1397851075:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 09:57 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 312-378:</div>
        <div class='diffadd'><div class='diffmarkup'><br />'''data_lump.h''' exposes <br /><br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      after/before - the lump where we will connect our new lump<br />      new_hdr - string to be added<br />      len - length of the string to be added<br />      type - header type that is affected by the current change ( can be 0 )<br />Returns :<br />      the created lump structure for adding to the SIP message. Can be further used to chain together different types of lumps in the message attached list of lumps. NULL is returned in case of internal error.<br />*/<br />struct lump* insert_new_lump_after(struct lump* after,                                            <br />                char* new_hdr, unsigned int len, enum _hdr_types_t type);                                        <br />struct lump* insert_new_lump_before(struct lump* before, char* new_hdr,<br />                unsigned int len,enum _hdr_types_t type);<br />(:sourceend:)<br />\\<br />If the developer's desire is just to add a particular string to the SIP message, a new anchor lump must be created, that will then have to be provided as the first parameter to insert_new_lump_after/insert_new_lump_before.<br />\\<br />For creating a new anchor lump, data_lump.h also exports<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      msg - the SIP message that will be affected by the lump anchor<br />      offset - the offset in the SIP message where the anchor will be placed<br />      len - not currently used ( should be 0 )<br />      type - header type that is affected by the current change ( can be 0 )<br />Returns:<br />      the created lump structure for adding to the SIP message. Can be further used to chain together different types of lumps in the message attached list of lumps. NULL is returned in case of internal error.<br />struct lump* anchor_lump(struct sip_msg* msg, unsigned int offset, <br />                int unsigned len, enum _hdr_types_t type) <br />(:sourceend:)<br />\\<br />Example of adding a new SIP header at the end of the SIP message headers :<br />(:source lang=C -link -getcode :)<br />      /* make sure we detect all headers */<br />      if (parse_headers(msg, HDR_EOH_F, 0) == -1) { <br />            LM_ERR(&quot;error while parsing message\n&quot;); <br />            return -1; <br />      } <br /><br />      /* add the anchor at the very end of the SIP headers */<br />      anchor = anchor_lump(msg, msg-&gt;unparsed - msg-&gt;buf, 0, 0);<br />      if (anchor == NULL) {<br />            LM_ERR(“Failed to create lump anchor\n”);<br />	    return -1;<br />      }<br />      len =  sizeof(“MY_HDR: MY_VAL\r\n”) -1;<br />      new_hdr=pkg_malloc(len);<br />      if (!new_hdr) {<br />            LM_ERR(“No more pkg mem\n”);<br />	    return -1;<br />      }<br /><br />      memcpy(new_hdr,”MY_HDR: MY_VAL\r\n”,len);<br />      if (insert_new_lump_after(anchor, new_hdr, len, 0) == 0) { <br />            LM_ERR(&quot;can't insert lump\n&quot;); <br />            pkg_free(new_hdr); <br />            return -1; <br />      } <br /><br />      /* job done, the PKG new_hdr mem will be free internally when the lump will be applied */<br />      return 0;<br />(:sourceend:)<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397851075-1397850661-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397851075:1397850661:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 09:51 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 279-309:</div>
        <div class='diffadd'><div class='diffmarkup'><br />'''data_lump.h''' exposes <br /><br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      msg - the SIP message the lump will affect<br />      offset - the offset in the SIP message at which to start deleting<br />      len - the number of characters to delete from the SIP message<br />      type - indication on which header the current lump affects ( can be 0 )<br />Returns :<br />      the created lump structure for deleting part of the SIP message. Can be further used to chain together different types of lumps in the message attached list of lumps. NULL is returned in case of internal error.<br />*/<br />struct lump* del_lump(struct sip_msg* msg, unsigned int offset, <br />        unsigned int len, enum _hdr_types_t type); <br />(:sourceend:)<br />\\<br />Example of deleting the RPID header :<br />(:source lang=C -link -getcode :)<br />      /* first parse the header to figure out where it actually starts in the SIP message */<br />      if( parse_headers(msg,HDR_RPID_F,0)&lt;0 || msg-&gt;rpid == NULL ){ <br />            LM_DBG(“No rpid header – nothing to delete \n”);<br />	    return 0;<br />      }<br /><br />      /* delete the entire RPID header */<br />      if ( del_lump(msg, msg-&gt;rpid-&gt;name.s-msg-&gt;buf, msg-&gt;rpid-&gt;len,HDR_RPID_T )== NULL) {<br />            LM_ERR(“Failed to delete RPID header \n”);<br />	    return -1;<br />      }<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397850661-1397850412-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397850661:1397850412:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 09:46 PM 
        by <span class='diffauthor' title='79.112.212.8'>79.112.212.8</span> - </div>
        <div class='difftype'>Added lines 273-280:</div>
        <div class='diffadd'><div class='diffmarkup'><br />This type of lumps operate on the current SIP message context. <br />\\<br />From operational point of view, they are also split into two categories :<br /><br />!!!!!! Delete Lumps<br /><br />!!!!!! Add Lumps</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397850412-1397843358-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397850412:1397843358:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:49 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 265-274 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!! Changing SIP Messages</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!! Changing SIP Messages<br />The standard mechanism for performing changes on SIP messages within OpenSIPS is by using the so called '''lumps system'''.<br />\\<br />The lump system works very similarly to the diff/patch tools in the Linux environment – the developer adds add and/or remove operations to a SIP message. The lumps are stored in a list, and are only applied after the OpenSIPS script is fully executed and before the SIP message is relayed. Because of this, changes done on a SIP message are not immediately reflected on the SIP message upon further inspection ( eg. Adding a new header from the script and then checking for the header's existence ).<br />\\<br />When talking about the SIP message they have an effect on, the lumps can be split into the following categories :<br /><br />!!!!! SIP Message Lumps<br /><br />!!!!! SIP Reply Lumps</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397843358-1397843255-minor&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397843358:1397843255:minor&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:47 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 263 from:</div>
        <div class='diffdel'><div class='diffmarkup'>The function will internally populate '''_m-&gt;sdp''' , '''see parser/sdp/sdp.h''' for more details on the '''sdp_info''' structure.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>The function will internally populate '''_m-&gt;sdp''' , see '''parser/sdp/sdp.h''' for more details on the '''sdp_info''' structure.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397843255-1397843208-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397843255:1397843208:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:46 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 127 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 129 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Deleted lines 135-136:</div>
        <div class='diffdel'><div class='diffmarkup'><br />'''HDR_EOH_F''' is exposed in case the developer wants to parse all the headers in the current SIP message.</div></div>
        <div class='difftype'>Added lines 137-138:</div>
        <div class='diffadd'><div class='diffmarkup'>'''HDR_EOH_F''' is exposed in case the developer wants to parse all the headers in the current SIP message.<br />\\</div></div>
        <div class='difftype'>Deleted lines 193-194:</div>
        <div class='diffdel'><div class='diffmarkup'><br />Note that the '''void *parsed''' element in the hdr_field structure will contain the header specific  parser structure, which will also be allocated into private memory and automatically freed when the SIP message processing has finished.</div></div>
        <div class='difftype'>Added lines 195-196:</div>
        <div class='diffadd'><div class='diffmarkup'>Note that the '''void *parsed''' element in the hdr_field structure will contain the header specific  parser structure, which will also be allocated into private memory and automatically freed when the SIP message processing has finished.<br />\\</div></div>
        <div class='difftype'>Deleted lines 218-219:</div>
        <div class='diffdel'><div class='diffmarkup'><br />The parse_uri() function does not allocate any memory, it just populates the sip_uri structure with references to the buf parameter provided as input.</div></div>
        <div class='difftype'>Added lines 220-221:</div>
        <div class='diffadd'><div class='diffmarkup'>The parse_uri() function does not allocate any memory, it just populates the sip_uri structure with references to the buf parameter provided as input.<br />\\</div></div>
        <div class='difftype'>Changed line 251 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397843208:1397843140:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397843208:1397843140:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397843208:1397843140:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:45 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 262 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397843140-1397843091-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397843140:1397843091:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:44 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 235-264:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!!! Parsing the SDP Body<br /><br />OpenSIPS exposes functions for operating on the SIP message body.<br />\\<br />'''parser/msg_parser.h''' exposes <br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      msg - the SIP message to fetch the body for<br />      body - output param, which will hold the body pointer inside the SIP message and the body length, or {NULL,0} in case of no body present<br />Returns :<br />      0 in case of success, or -1 in the case of parsing errors ( the function needs to internally parse all the headers in order to detect the body length ).<br />*/<br />int get_body(struct sip_msg *msg, str *body)<br />(:sourceend:)<br /><br />For parsing the SDP body and extracting various information about the session(s) , '''parser/sdp/sdp.h''' exposes<br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      _m - the SIP message to have it's SDP parsed<br />Returns :<br />      0 in case of success, negative in case of error<br />*/<br />int parse_sdp(struct sip_msg* _m);<br />(:sourceend:)<br /><br />The function will internally populate '''_m-&gt;sdp''' , '''see parser/sdp/sdp.h''' for more details on the '''sdp_info''' structure.<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397843091-1397842752-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397843091:1397842752:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:39 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 203-234:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Parsing SIP URIs<br /><br />The OpenSIPS parser also exposes the functionality of parsing individual SIP URI.\\<br />'''parser/parse_uri.h''' exposes :<br /><br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      buf - the string which contains our SIP URI<br />      len - length of the SIP URI buffer<br />      uri - structure which will be populated by the function in case of success. <br />      See full struct sip_uri members in parser/msg_parser.h<br />Returns :<br />      0 in case of success, negative value in case of error parsing the URI<br />int parse_uri(char *buf, int len, struct sip_uri* uri);<br />(:sourceend:)<br /><br />The parse_uri() function does not allocate any memory, it just populates the sip_uri structure with references to the buf parameter provided as input.<br />\\<br />Here is an example of parsing the TO URI :<br />(:source lang=C -link -getcode :)<br />      /* make sure TO header is parsed before this */<br />      struct to_body *tb = get_to(msg);<br />      if (parse_uri(tb-&gt;uri.s, tb-&gt;uri.len , &amp;tb-&gt;parsed_uri)&lt;0) { <br />            LM_ERR(&quot;failed to parse To uri\n&quot;); <br />  	    return -1;<br />      }<br /><br />      LM_INFO(“TO URI user is %.*s and TO URI domain is %.*s\n”,<br />      tb-&gt;parsed_uri.user.len, tb-&gt;parsed_uri.user.s,<br />      tb-&gt;parsed_uri.domain.len, tb-&gt;parsed_uri.domain.s);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397842752-1397842480-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842752:1397842480:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:34 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 195 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Note that the void *parsed element in the hdr_field structure will contain the header specific  parser structure, which will also be allocated into private memory and automatically freed when the SIP message processing has finished.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Note that the '''void *parsed''' element in the hdr_field structure will contain the header specific  parser structure, which will also be allocated into private memory and automatically freed when the SIP message processing has finished.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397842480-1397842442-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842480:1397842442:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:34 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 194-202:</div>
        <div class='diffadd'><div class='diffmarkup'><br />Note that the void *parsed element in the hdr_field structure will contain the header specific  parser structure, which will also be allocated into private memory and automatically freed when the SIP message processing has finished.<br />\\<br />After parse_to_header() successfully returns, the developer can start accessing the parsed TO header in the following way :<br /><br />(:source lang=C -link -getcode :)<br />LM_INFO(“The TO header tag value is %.*s \n”,get_to(msg)-&gt;tag_value.len, get_to(msg)-&gt;tag_value.s);<br />(:sourceend:)<br /></div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842442:1397842357:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842442:1397842357:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842442:1397842357:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:32 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 111-112:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!!! Generic Header Parser</div></div>
        <div class='difftype'>Added lines 148-149:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!!! Specific Header Parsing</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397842357-1397842206-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842357:1397842206:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:30 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added line 142:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added lines 145-188:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />For parsing a specific header type, and extracting the header type relevant information, the parser/ folder contains all implementations for known headers. <br />The naming convention is that parser/parse_X.h will expose the parsing for the X header name.<br />\\<br />For example, here is the implementation of the parsing of the TO header, exposed by '''parser/parse_to.h''' :<br /><br />(:source lang=C -link -getcode :)<br />int parse_to_header( struct sip_msg *msg) <br />{       <br />      struct to_body* to_b; <br />        <br />      if ( !msg-&gt;to &amp;&amp; ( parse_headers(msg,HDR_TO_F,0)==-1 || !msg-&gt;to)) { <br />            LM_ERR(&quot;bad msg or missing To header\n&quot;); <br />            goto error; <br />      } <br /><br />      /* maybe the header is already parsed! */ <br />      if (msg-&gt;to-&gt;parsed) <br />            return 0; <br /><br />      /* bad luck! :-( - we have to parse it */ <br />      /* first, get some memory */ <br />      to_b = pkg_malloc(sizeof(struct to_body)); <br />      if (to_b == 0) { <br />            LM_ERR(&quot;out of pkg_memory\n&quot;); <br />            goto error; <br />      } <br /><br />      /* now parse it!! */ <br />      memset(to_b, 0, sizeof(struct to_body)); <br />      parse_to(msg-&gt;to-&gt;body.s,msg-&gt;to-&gt;body.s+msg-&gt;to-&gt;body.len+1,to_b); <br />      if (to_b-&gt;error == PARSE_ERROR) { <br />            LM_ERR(&quot;bad to header\n&quot;); <br />            pkg_free(to_b); <br />            goto error; <br />      } <br /><br />      msg-&gt;to-&gt;parsed = to_b; <br /> <br />      return 0; <br />error: <br />      return -1; <br />} </div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842206:1397841938:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842206:1397841938:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397842206:1397841938:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:25 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 135-144:</div>
        <div class='diffadd'><div class='diffmarkup'>'''HDR_EOH_F''' is exposed in case the developer wants to parse all the headers in the current SIP message.<br />\\<br />Important to note that the parse_headers() function will not duplicate SIP headers at all – the hooks in the struct sip_msg structure will be populated with pointers that point directly in the SIP message buffer.<br />\\<br />Upon return, if successful, the function will populate the respective hooks in the  sip_msg structure for known headers.The hdr_field* structures are allocated in pkg memory, and will automatically be freed when the SIP message processing has finished.<br />\\<br />After succesful parsing, the developer can access the header name and body like this :<br />(:source lang=C -link -getcode :)<br />LM_INFO(“The callid header name is %.*s and the callid header body is %.*s \n”, req-&gt;callid-&gt;name.len, req-&gt;callid-&gt;name.s, req-&gt;callid-&gt;bodylen.  req-&gt;callid-&gt;body.s);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397841938-1397841712-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841938:1397841712:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:21 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841712:1397841695:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841712:1397841695:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841712:1397841695:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:21 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 124-132:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />Example of usage :<br /><br />(:source lang=C -link -getcode :)<br />if(parse_headers(req,HDR_CALLID_F|HDR_TO_F|HDR_FROM_F,0)&lt;0 || !req-&gt;callid || !req-&gt;to || !req-&gt;from) { <br />      LM_ERR(&quot;bad request or missing CALLID/TO/FROM hdr \n&quot;); <br />      return -1; <br />}</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841695:1397841557:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841695:1397841557:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841695:1397841557:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:19 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 96-126 from:</div>
        <div class='diffdel'><div class='diffmarkup'>(:sourceend:)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>(:sourceend:)<br /><br />!!!! Parsing SIP Messages<br /><br />The OpenSIPS SIP message parser is a lazy parser, which performs very well in terms of performance. The behavior is the following :<br />* when the message is received, only the 'critical' headers are parsed ( eg : topmost VIA )<br />* for known header types, when the developer wants to extract the first occurrence of a header, it does not have to parse the entire message, but rather the parser will stop parsing when the first needed header type was identified<br />\\<br />Also, important to note that there are two types of parsing :<br />* parsing in the sense of identifying header boundaries and separating between the header name and header body ( eg : parsing the 'To : vlad@opensips.org;tag=123\r\n' header, and identifying that first, the header is present, and secondly that the body is 'vlad@opensips.org;tag=123\r\n' )<br />* in-depth parsing of a specific header type, for identifying header specific information ( in our example, extracting the to-tag in the TO header, etc ).<br />\\<br />Also, all parsing is done in a stateful manner, in the sense that the OpenSIPS parser know which header was parsed and by internally storing a bitmask. Thus, once the TO header was first parsed, any subsequent attempts of parsing the TO header will return immediately.<br />\\<br />Parser implementations are generally exported in the '''parser/''' folder.<br />The generic parser of SIP headers is exposed by '''parser/msg_parser.h''' . The function to be used is :<br /><br />(:source lang=C -link -getcode :)<br />/*<br />Parameters :<br />      msg : the SIP message that needs to be parsed – see parser/msg_parser.h for details on the struct sip_msg structure<br />      flags : bitmask of header types that need to be parsed<br />      next : specifies whether the parser should explicitly force the parsing of new headers from the provided bitmask, even though those header types were already previously found. Can be useful when trying to find a second occurrence of a header ( in the case that header can appear multiple times in a SIP message – eg. Route )<br /><br />Returns :<br />      0 in case of error, -1 in case of error ( either header was not found or some other error occurred ).<br />*/<br />int parse_headers(struct sip_msg* msg, hdr_flags_t flags, int next);<br />(:sourceend:)<br /><br />!!!! Changing SIP Messages</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397841557-1397841246-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841557:1397841246:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:14 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 67-96 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Also, since allocations of chunks of shared memory can be requested from all the OpenSIPS processes, the shared memory allocator internally uses locking in order to ensure consistency. Due to this, as a general guideline, it is recommended to avoid big fragmentation of the shared memory ( by requesting many small chunks ), by merging as much information that is meaningfully tied together in a single shared memory chunk.</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Also, since allocations of chunks of shared memory can be requested from all the OpenSIPS processes, the shared memory allocator internally uses locking in order to ensure consistency. Due to this, as a general guideline, it is recommended to avoid big fragmentation of the shared memory ( by requesting many small chunks ), by merging as much information that is meaningfully tied together in a single shared memory chunk.<br /><br />mem/shm_mem.h exposes all the shared memory related functions :<br /><br />(:source lang=C -link -getcode :)<br />/* <br />Parameters :<br />      size - size in bytes of the request shared memory<br />Returns :<br />      the actual allocated buffer, or NULL is case of error<br />*/<br />void *shm_malloc(unsigned int size);<br /><br />/*<br />Parameters :<br />      buf - the buffer to be freed<br />*/<br />void shm_free(void *buf)<br /><br />/*<br />Parameters :<br />      buf - buffer that we want to reallocate<br />      size - the new desired buffer size<br />Returns :<br />	the new buffer address if reallocation is successful, or NULL in case of error. <br /><br />Note that shm_realloc(NULL,size) is equivalent to shm_malloc(size)<br />*/<br />void *shm_realloc(void *buf, unsigned int size);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397841246-1397841098-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841246:1397841098:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:11 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 66 from:</div>
        <div class='diffdel'><div class='diffmarkup'>Shared memory is and can be accessible from all OpenSIPS processes. Thus, generally speaking, all write access to a shared memory buffer should be guarded by some form of synchronization mechanism in order to ensure consistency.\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>Shared memory can be accessible from all OpenSIPS processes. Thus, generally speaking, all write access to a shared memory buffer should be guarded by some form of synchronization mechanism in order to ensure consistency.\\</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841098:1397841066:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841098:1397841066:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841098:1397841066:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:11 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 28 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397841066-1397841039-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841066:1397841039:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:10 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 65-67 from:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Shared (SHM) Memory</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!! Shared (SHM) Memory<br />Shared memory is and can be accessible from all OpenSIPS processes. Thus, generally speaking, all write access to a shared memory buffer should be guarded by some form of synchronization mechanism in order to ensure consistency.\\<br />Also, since allocations of chunks of shared memory can be requested from all the OpenSIPS processes, the shared memory allocator internally uses locking in order to ensure consistency. Due to this, as a general guideline, it is recommended to avoid big fragmentation of the shared memory ( by requesting many small chunks ), by merging as much information that is meaningfully tied together in a single shared memory chunk.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397841039-1397840983-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397841039:1397840983:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:09 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 41 from:</div>
        <div class='diffdel'><div class='diffmarkup'>      size – size in bytes of the request private memory</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>      size - size in bytes of the request private memory</div></div>
        <div class='difftype'>Added lines 46-62:</div>
        <div class='diffadd'><div class='diffmarkup'><br />/*<br />Parameters :<br />      buf - the buffer to be freed<br />*/<br />void pkg_free(void *buf)<br /><br />/*<br />Parameters :<br />      buf - buffer that we want to reallocate<br />      size - the new desired buffer size<br />Returns :<br />	the new buffer address if reallocation is successful, or NULL in case of error. <br /><br />Note that pkg_realloc(NULL,size) is equivalent to pkg_malloc(size)<br />*/<br />void *pkg_realloc(void *buf, unsigned int size);</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840983:1397840865:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840983:1397840865:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840983:1397840865:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:07 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 39-40 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/* Parameters :</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* <br />Parameters :</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840865:1397840847:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840865:1397840847:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840865:1397840847:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:07 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 39-43 from:</div>
        <div class='diffdel'><div class='diffmarkup'>/* wtf */</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>/* Parameters :<br />      size – size in bytes of the request private memory<br />Returns :<br />      the actual allocated buffer, or NULL is case of error<br />*/</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840847:1397840774:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840847:1397840774:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840847:1397840774:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:06 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 36-37:</div>
        <div class='diffadd'><div class='diffmarkup'>'''mem/mem.h''' exposes all the private memory related functions<br /></div></div>
        <div class='difftype'>Added line 39:</div>
        <div class='diffadd'><div class='diffmarkup'>/* wtf */</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840774-1397840684-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840774:1397840684:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:04 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 28-29 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\\<br /></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840684-1397840591-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840684:1397840591:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:03 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 22 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 24 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 26 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 28 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 32 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 34 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840591-1397840552-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840591:1397840552:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:02 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed lines 22-23 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>Changed lines 24-25 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>Changed lines 26-27 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>Changed lines 28-29 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\<br /></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>Changed line 32 from:</div>
        <div class='diffdel'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\\</div></div>
        <div class='difftype'>Changed line 34 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\\</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840552-1397840488-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840552:1397840488:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:01 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added line 23:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 26:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div>
        <div class='difftype'>Added line 29:</div>
        <div class='diffadd'><div class='diffmarkup'></div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840488-1397840456-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840488:1397840456:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 07:00 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Deleted lines 17-18:</div>
        <div class='diffdel'><div class='diffmarkup'>!!!!! Private (PKG) Memory<br /></div></div>
        <div class='difftype'>Changed line 22 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 24 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Changed line 26 from:</div>
        <div class='diffdel'><div class='diffmarkup'></div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>\\</div></div>
        <div class='difftype'>Added lines 28-34:</div>
        <div class='diffadd'><div class='diffmarkup'>\\<br /><br />!!!!! Private (PKG) Memory<br /><br />Private memory is only specific to a single OpenSIPS process. Since it has no visibility outside the current process, no locking mechanisms are required while using such memory. <br />\\<br />Also, note the common use case where , before forking OpenSIPS processes, the developer stores some static variables in private memory of the main process. After forking, all the child processes will inherit that private memory chunk and each will have it's individual copy of it.</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840456-1397840249-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840456:1397840249:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 06:57 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 31 from:</div>
        <div class='diffdel'><div class='diffmarkup'>(:source lang=C -link :)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>(:source lang=C -link -getcode :)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840249-1397840199-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840249:1397840199:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 06:56 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Changed line 31 from:</div>
        <div class='diffdel'><div class='diffmarkup'>(:source lang=C :)</div></div>
        <div class='difftype'>to:</div>
        <div class='diffadd'><div class='diffmarkup'>(:source lang=C -link :)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840199-1397840134-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840199:1397840134:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 06:55 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 30-33:</div>
        <div class='diffadd'><div class='diffmarkup'><br />(:source lang=C :)<br />void *pkg_malloc(unsigned int size);<br />(:sourceend:)</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397840134-1397839555-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397840134:1397839555:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 06:45 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 19-29:</div>
        <div class='diffadd'><div class='diffmarkup'><br />OpenSIPS has it's own memory allocator, and this provides some important advantages over the system memory allocator :<br />* the ability to hard limit the memory that OpenSIPS uses<br />* improved performance over the system memory allocator<br />* multiple allocators are available, each with different use cases ( options are the standard allocator, the memory debugging allocator – useful for debugging memory leaks and memory corruptions – and some others , check the menuconfig configurations options ).<br /><br />Furthermore, since OpenSIPS is a multi-process application, the use of shared memory is required in many very common scenarios. The OpenSIPS allocators also hide the shared memory implementations details, and expose a very simple API, very similar to the system allocator.<br /><br />All OpenSIPS allocators request from the system memory, at startup, the maximum configured memory for OpenSIPS, and then it manages it internally as OpenSIPS starts to use memory while processing traffic.<br /><br />From OpenSIPS perspective, there are two types of memory, one that is related to the context of a single Process ( Private Memory ) , and another that is shared between all OpenSIPS processes ( Shared Memory ).</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397839555-1397839484-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397839555:1397839484:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 06:44 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 11-20:</div>
        <div class='diffadd'><div class='diffmarkup'><br />!!!! Introduction<br /><br />!!!! General Architecture<br /><br />!!!! Memory Management<br /><br />!!!!! Private (PKG) Memory<br /><br />!!!!! Shared (SHM) Memory</div></div></div>
      <div class='diffrestore'><a href="Development-Manual-action=edit&restore=diff-1397839484-1397838980-&preview=y.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397839484:1397838980:&preview=y">Restore</a></div>
      <div class='diffbox'><div class='difftime'>April 18, 2014, at 06:36 PM 
        by <span class='diffauthor' title='213.233.84.113'>213.233.84.113</span> - </div>
        <div class='difftype'>Added lines 1-10:</div>
        <div class='diffadd'><div class='diffmarkup'>!!!!!Documentation -&gt; [[Documentation.Manuals|Manuals]] -&gt; OpenSIPS Development Manual<br />----<br /><br />\\<br /><br />|| %color=#185662%[+'''OpenSIPS Development Manual'''+]%% ||<br /><br />----<br /><br />(:toc-float Table of Content:)</div></div></div>
      <div class='diffrestore'><a href="javascript:if(confirm(%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397838980:1397838980:&preview=y  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397838980:1397838980:&preview=y%27" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit&restore=diff:1397838980:1397838980:&preview=y">Restore</a></div></div></div>
  
<!--PageRightFmt--><!--/PageRightFmt--></td>
</tr></table>
<!--PageFooterFmt-->
  <div id='wikifoot'>
  <hr class="bottomline" /></td>
    <div class='footnav'>
	
      <a rel="nofollow" href="Development-Manual-action=edit.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=edit">Edit</a> |
      <a rel="nofollow" href="Development-Manual-action=diff.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=diff">History</a> |
      <a rel="nofollow" href="Development-Manual-action=print.htm" tppabs="http://www.opensips.org/Documentation/Development-Manual?action=print" target='_blank'>Print</a> |
      <a href="RecentChanges.htm" tppabs="http://www.opensips.org/Documentation/RecentChanges">Recent Changes</a> |
      <a href="javascript:if(confirm(%27http://www.opensips.org/Site/Search  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.opensips.org/Site/Search%27" tppabs="http://www.opensips.org/Site/Search">Search</a></div>
    <div class='lastmod'>Page last modified on July 06, 2014, at 08:09 PM</div></div>
<!--HTMLFooter-->
</div>
</body>
</html>
